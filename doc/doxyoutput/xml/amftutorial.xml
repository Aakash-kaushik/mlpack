<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="amftutorial" kind="page">
    <compoundname>amftutorial</compoundname>
    <title>Alternating Matrix Factorization tutorial</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<sect1 id="amftutorial_1intro_amftut">
<title>Introduction</title>
<para>Alternating Matrix Factorization</para>
<para>Alternating matrix factorization decomposes matrx V in the form <formula id="73">$ V \approx WH $</formula> where W is called the basis matrix and H is called the encoding matrix. V is taken to be of size n x m and the obtained W is n x r and H is r x m. The size r is called the rank of the factorization. Factorization is done by alternately calculating W and H respectively while holding the other matrix constant.</para>
<para><bold>mlpack</bold> provides:</para>
<para><itemizedlist>
<listitem><para>a <ref refid="amftutorial_1amf_amftut" kindref="member">simple C++ interface</ref> to perform Alternating Matrix Factorization</para>
</listitem></itemizedlist>
</para>
</sect1>
<sect1 id="amftutorial_1toc_amftut">
<title>Table of Contents</title>
<para>A list of all the sections this tutorial contains.</para>
<para><itemizedlist>
<listitem><para><ref refid="amftutorial_1intro_amftut" kindref="member">Introduction</ref></para>
</listitem><listitem><para><ref refid="amftutorial_1toc_amftut" kindref="member">Table of Contents</ref></para>
</listitem><listitem><para><ref refid="amftutorial_1amf_amftut" kindref="member">The &apos;AMF&apos; class</ref><itemizedlist>
<listitem><para><ref refid="amftutorial_1t_policy_amftut" kindref="member">Using different termination policies</ref></para>
</listitem><listitem><para><ref refid="amftutorial_1init_rule_amftut" kindref="member">Using different initialization policies</ref></para>
</listitem><listitem><para><ref refid="amftutorial_1update_rule_amftut" kindref="member">Using different update rules</ref></para>
</listitem><listitem><para><ref refid="amftutorial_1nmf_amftut" kindref="member">Using Non-Negative Matrix Factorization with AMF</ref></para>
</listitem><listitem><para><ref refid="amftutorial_1svd_amftut" kindref="member">Using Singular Value Decomposition with AMF</ref></para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para><ref refid="amftutorial_1further_doc_amftut" kindref="member">Further documentation</ref></para>
</listitem></itemizedlist>
</para>
</sect1>
<sect1 id="amftutorial_1amf_amftut">
<title>The &apos;AMF&apos; class</title>
<para>The AMF class is templatized with 3 parameters; the first contains the policy used to determine when the algorithm has converged; the second contains the initialization rule for the W and H matrix; the last contains the update rule to be used during each iteration. This templatization allows the user to try various update rules, initialization rules, and termination policies (including ones not supplied with mlpack) for factorization.</para>
<para>The class provides the following method that performs factorization <programlisting><codeline><highlight class="normal">template&lt;typename<sp/>MatType&gt;<sp/>double<sp/>Apply(const<sp/>MatType&amp;<sp/>V,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>size_t<sp/>r,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>arma::mat&amp;<sp/>W,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>arma::mat&amp;<sp/>H);</highlight></codeline>
</programlisting></para>
<sect2 id="amftutorial_1t_policy_amftut">
<title>Using different termination policies</title>
<para>The AMF implementation comes with different termination policies to support many implemented algorithms. Every termination policy implements the following method which returns the status of convergence. <programlisting><codeline><highlight class="normal">bool<sp/>IsConverged(arma::mat&amp;<sp/>W,<sp/>arma::mat&amp;<sp/>H)</highlight></codeline>
</programlisting></para>
<para>Below is a list of all the termination policies that mlpack contains.</para>
<para><itemizedlist>
<listitem><para><ref refid="classmlpack_1_1amf_1_1SimpleResidueTermination" kindref="compound">mlpack::amf::SimpleResidueTermination</ref></para>
</listitem><listitem><para><ref refid="classmlpack_1_1amf_1_1SimpleToleranceTermination" kindref="compound">mlpack::amf::SimpleToleranceTermination</ref></para>
</listitem><listitem><para><ref refid="classmlpack_1_1amf_1_1ValidationRMSETermination" kindref="compound">mlpack::amf::ValidationRMSETermination</ref></para>
</listitem></itemizedlist>
</para>
<para>In <computeroutput>SimpleResidueTermination</computeroutput>, termination decision depends on two factors, value of residue and number of iteration. If the current value of residue drops below the threshold or the number of iterations goes beyond the threshold, positive termination signal is passed to AMF.</para>
<para>In <computeroutput>SimpleToleranceTermination</computeroutput>, termination criterion is met when the increase in residue value drops below the given tolerance. To accommodate spikes, certain number of successive residue drops are accepted. Secondary termination criterion terminates algorithm when iteration count goes beyond the threshold.</para>
<para><computeroutput>ValidationRMSETermination</computeroutput> divides the data into 2 sets, training set and validation set. Entries of validation set are nullifed in the input matrix. Termination criterion is met when increase in validation set RMSe value drops below the given tolerance. To accommodate spikes certain number of successive validation RMSE drops are accepted. This upper imit on successive drops can be adjusted with <computeroutput>reverseStepCount</computeroutput>. A secondary termination criterion terminates the algorithm when the iteration count goes above the threshold. Though this termination policy is better measure of convergence than the above 2 termination policies, it may cause a decrease in performance since it is computationally expensive.</para>
<para>On the other hand, <ref refid="classmlpack_1_1amf_1_1CompleteIncrementalTermination" kindref="compound">CompleteIncrementalTermination</ref> and <ref refid="classmlpack_1_1amf_1_1IncompleteIncrementalTermination" kindref="compound">IncompleteIncrementalTermination</ref> are just wrapper classes for other termination policies. These policies are used when AMF is applied with <ref refid="classmlpack_1_1amf_1_1SVDCompleteIncrementalLearning" kindref="compound">SVDCompleteIncrementalLearning</ref> and <ref refid="classmlpack_1_1amf_1_1SVDIncompleteIncrementalLearning" kindref="compound">SVDIncompleteIncrementalLearning</ref>, respectively.</para>
</sect2>
<sect2 id="amftutorial_1init_rule_amftut">
<title>Using different initialization policies</title>
<para>mlpack currently has 2 initialization policies implemented for AMF:</para>
<para><itemizedlist>
<listitem><para><ref refid="classmlpack_1_1amf_1_1RandomInitialization" kindref="compound">RandomInitialization</ref></para>
</listitem><listitem><para><ref refid="classmlpack_1_1amf_1_1RandomAcolInitialization" kindref="compound">RandomAcolInitialization</ref></para>
</listitem></itemizedlist>
</para>
<para><computeroutput>RandomInitialization</computeroutput> initializes matrices W and H with random uniform distribution while <computeroutput>RandomAcolInitialization</computeroutput> initializes the W matrix by averaging p randomly chosen columns of V. In the case of <computeroutput>RandomAcolInitialization</computeroutput>, p is a template parameter.</para>
<para>To implement their own initialization policy, users need to define the following function in their class.</para>
<para><programlisting><codeline><highlight class="normal">template&lt;typename<sp/>MatType&gt;</highlight></codeline>
<codeline><highlight class="normal">inline<sp/>static<sp/>void<sp/>Initialize(const<sp/>MatType&amp;<sp/>V,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>size_t<sp/>r,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>arma::mat&amp;<sp/>W,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>arma::mat&amp;<sp/>H)</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="amftutorial_1update_rule_amftut">
<title>Using different update rules</title>
<para>mlpack implements the following update rules for the AMF class:</para>
<para><itemizedlist>
<listitem><para><ref refid="classmlpack_1_1amf_1_1NMFALSUpdate" kindref="compound">AMFALSUpdate</ref></para>
</listitem><listitem><para><ref refid="classmlpack_1_1amf_1_1NMFMultiplicativeDistanceUpdate" kindref="compound">NMFMultiplicativeDistanceUpdate</ref></para>
</listitem><listitem><para><ref refid="classmlpack_1_1amf_1_1NMFMultiplicativeDivergenceUpdate" kindref="compound">NMFMultiplicativeDivergenceUpdate</ref></para>
</listitem><listitem><para><ref refid="classmlpack_1_1amf_1_1SVDBatchLearning" kindref="compound">SVDBatchLearning</ref></para>
</listitem><listitem><para><ref refid="classmlpack_1_1amf_1_1SVDIncompleteIncrementalLearning" kindref="compound">SVDIncompleteIncrementalLearning</ref></para>
</listitem><listitem><para><ref refid="classmlpack_1_1amf_1_1SVDCompleteIncrementalLearning" kindref="compound">SVDCompleteIncrementalLearning</ref></para>
</listitem></itemizedlist>
</para>
<para>Non-Negative Matrix factorization can be achieved with <computeroutput>NMFALSUpdate</computeroutput>, <computeroutput>NMFMultiplicativeDivergenceUpdate</computeroutput> or <computeroutput>NMFMultiplicativeDivergenceUpdate</computeroutput>. <computeroutput>NMFALSUpdate</computeroutput> implements a simple Alternating Least Squares optimization while the other rules implement algorithms given in the paper &apos;Algorithms for Non-negative Matrix Factorization&apos;.</para>
<para>The remaining update rules perform the singular value decomposition of the matrix V. This SVD factorization is optimized for use by mlpack&apos;s collaborative filtering code (<ref refid="cftutorial" kindref="compound">Collaborative filtering tutorial</ref>). This use of SVD factorizers for collaborative filtering is described in the paper &apos;A Guide to Singular Value Decomposition for Collaborative Filtering&apos; by Chih-Chao Ma. For further details about the algorithms refer to the respective class documentation.</para>
</sect2>
<sect2 id="amftutorial_1nmf_amftut">
<title>Using Non-Negative Matrix Factorization with AMF</title>
<para>The use of AMF for Non-Negative Matrix factorization is simple. The AMF module defines <ref refid="namespacemlpack_1_1amf_1a3e3179901b352438bc974218b6ba0fab" kindref="member">NMFALSFactorizer</ref> which can be used directly without knowing the internal structure of AMF. For example:</para>
<para><programlisting><codeline><highlight class="normal">#include<sp/>&lt;mlpack/core.hpp&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;mlpack/methods/amf/amf.hpp&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">using<sp/>namespace<sp/>std;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>namespace<sp/>arma;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>namespace<sp/>mlpack::amf;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">int<sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>NMFALSFactorizer<sp/>nmf;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>mat<sp/>W,<sp/>H;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>mat<sp/>V<sp/>=<sp/>randu&lt;mat&gt;(100,<sp/>100);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>double<sp/>residue<sp/>=<sp/>nmf.Apply(V,<sp/>W,<sp/>H);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para><computeroutput>NMFALSFactorizer</computeroutput> uses <computeroutput>SimpleResidueTermination</computeroutput>, which is most preferred with Non-Negative Matrix factorizers. The initialization of W and H in <computeroutput>NMFALSFactorizer</computeroutput> is random. The <computeroutput>Apply()</computeroutput> function returns the residue obtained by comparing the constructed matrix W * H with the original matrix V.</para>
</sect2>
<sect2 id="amftutorial_1svd_amftut">
<title>Using Singular Value Decomposition with AMF</title>
<para>mlpack has the following SVD factorizers implemented for AMF:</para>
<para><itemizedlist>
<listitem><para><ref refid="namespacemlpack_1_1amf_1aedb113157f87759c24e2368dfd7b9216" kindref="member">SVDBatchFactorizer</ref></para>
</listitem><listitem><para><ref refid="namespacemlpack_1_1amf_1a681ac877cb603d00766e015ff4d4c294" kindref="member">SVDIncompleteIncrementalFactorizer</ref></para>
</listitem><listitem><para><ref refid="namespacemlpack_1_1amf_1aeaa4b749fc1afc70451f096dca4228b5" kindref="member">SVDCompleteIncrementalFactorizer</ref></para>
</listitem></itemizedlist>
</para>
<para>Each of these factorizers takes a template parameter <computeroutput>MatType</computeroutput>, which specifies the type of the matrix V (dense or sparse<mdash/>these have types <computeroutput>arma::mat</computeroutput> and <computeroutput>arma::sp_mat</computeroutput>, respectively). When the matrix to be factorized is relatively sparse, specifying <computeroutput>MatType</computeroutput> <computeroutput>=</computeroutput> <computeroutput>arma::sp_mat</computeroutput> can provide a runtime boost.</para>
<para><programlisting><codeline><highlight class="normal">#include<sp/>&lt;mlpack/core.hpp&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;mlpack/methods/amf/amf.hpp&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">using<sp/>namespace<sp/>std;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>namespace<sp/>arma;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>namespace<sp/>mlpack::amf;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">int<sp/>main()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>sp_mat<sp/>V<sp/>=<sp/>randu&lt;sp_mat&gt;(100,100);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>mat<sp/>W,<sp/>H;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>SVDBatchFactorizer&lt;sp_mat&gt;<sp/>svd;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>double<sp/>residue<sp/>=<sp/>svd.Apply(V,<sp/>W,<sp/>H);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect2>
</sect1>
<sect1 id="amftutorial_1further_doc_amftut">
<title>Further documentation</title>
<para>For further documentation on the AMF class, consult the <ref refid="classmlpack_1_1amf_1_1AMF" kindref="compound">complete API documentation</ref>. </para>
</sect1>
    </detaileddescription>
    <location file="/home/aakash/mlpack/doc/tutorials/amf/amf.txt"/>
  </compounddef>
</doxygen>
