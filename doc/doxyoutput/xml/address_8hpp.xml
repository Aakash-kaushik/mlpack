<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="address_8hpp" kind="file" language="C++">
    <compoundname>address.hpp</compoundname>
    <includedby refid="ub__tree__split_8hpp" local="yes">/home/aakash/mlpack/src/mlpack/core/tree/binary_space_tree/ub_tree_split.hpp</includedby>
    <includedby refid="cellbound_8hpp" local="yes">/home/aakash/mlpack/src/mlpack/core/tree/cellbound.hpp</includedby>
    <invincdepgraph>
      <node id="6">
        <label>/home/aakash/mlpack/src/mlpack/core/tree/binary_space_tree/single_tree_traverser.hpp</label>
        <link refid="binary__space__tree_2single__tree__traverser_8hpp"/>
        <childnode refid="3" relation="include">
        </childnode>
      </node>
      <node id="38">
        <label>/home/aakash/mlpack/src/mlpack/methods/kmeans/pelleg_moore_kmeans.hpp</label>
        <link refid="pelleg__moore__kmeans_8hpp"/>
      </node>
      <node id="58">
        <label>/home/aakash/mlpack/src/mlpack/core/tree/spill_tree/spill_dual_tree_traverser.hpp</label>
        <link refid="spill__dual__tree__traverser_8hpp"/>
        <childnode refid="55" relation="include">
        </childnode>
      </node>
      <node id="51">
        <label>/home/aakash/mlpack/src/mlpack/core/tree/space_split/projection_vector.hpp</label>
        <link refid="projection__vector_8hpp"/>
        <childnode refid="52" relation="include">
        </childnode>
      </node>
      <node id="21">
        <label>/home/aakash/mlpack/src/mlpack/methods/lmnn/lmnn_function.hpp</label>
        <link refid="lmnn__function_8hpp"/>
        <childnode refid="22" relation="include">
        </childnode>
      </node>
      <node id="39">
        <label>/home/aakash/mlpack/src/mlpack/methods/range_search/range_search.hpp</label>
        <link refid="range__search_8hpp"/>
        <childnode refid="40" relation="include">
        </childnode>
        <childnode refid="41" relation="include">
        </childnode>
      </node>
      <node id="54">
        <label>/home/aakash/mlpack/src/mlpack/core/tree/spill_tree/typedef.hpp</label>
        <link refid="core_2tree_2spill__tree_2typedef_8hpp"/>
        <childnode refid="55" relation="include">
        </childnode>
      </node>
      <node id="24">
        <label>/home/aakash/mlpack/src/mlpack/methods/neighbor_search/typedef.hpp</label>
        <link refid="methods_2neighbor__search_2typedef_8hpp"/>
        <childnode refid="7" relation="include">
        </childnode>
      </node>
      <node id="52">
        <label>/home/aakash/mlpack/src/mlpack/core/tree/space_split/hyperplane.hpp</label>
        <link refid="hyperplane_8hpp"/>
        <childnode refid="53" relation="include">
        </childnode>
        <childnode refid="60" relation="include">
        </childnode>
        <childnode refid="61" relation="include">
        </childnode>
      </node>
      <node id="11">
        <label>/home/aakash/mlpack/src/mlpack/methods/cf/cf_model.hpp</label>
        <link refid="cf__model_8hpp"/>
      </node>
      <node id="60">
        <label>/home/aakash/mlpack/src/mlpack/core/tree/space_split/midpoint_space_split.hpp</label>
        <link refid="midpoint__space__split_8hpp"/>
        <childnode refid="56" relation="include">
        </childnode>
        <childnode refid="54" relation="include">
        </childnode>
      </node>
      <node id="13">
        <label>/home/aakash/mlpack/src/mlpack/methods/cf/decomposition_policies/regularized_svd_method.hpp</label>
        <link refid="regularized__svd__method_8hpp"/>
      </node>
      <node id="55">
        <label>/home/aakash/mlpack/src/mlpack/core/tree/spill_tree.hpp</label>
        <link refid="spill__tree_8hpp"/>
        <childnode refid="56" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
      </node>
      <node id="61">
        <label>/home/aakash/mlpack/src/mlpack/core/tree/space_split/space_split.hpp</label>
        <link refid="space__split_8hpp"/>
      </node>
      <node id="48">
        <label>/home/aakash/mlpack/src/mlpack/core/tree/bounds.hpp</label>
        <link refid="bounds_8hpp"/>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="49" relation="include">
        </childnode>
        <childnode refid="50" relation="include">
        </childnode>
        <childnode refid="51" relation="include">
        </childnode>
        <childnode refid="55" relation="include">
        </childnode>
      </node>
      <node id="5">
        <label>/home/aakash/mlpack/src/mlpack/core/tree/binary_space_tree/dual_tree_traverser.hpp</label>
        <link refid="binary__space__tree_2dual__tree__traverser_8hpp"/>
        <childnode refid="3" relation="include">
        </childnode>
      </node>
      <node id="10">
        <label>/home/aakash/mlpack/src/mlpack/methods/cf/decomposition_policies/bias_svd_method.hpp</label>
        <link refid="bias__svd__method_8hpp"/>
      </node>
      <node id="8">
        <label>/home/aakash/mlpack/src/mlpack/methods/cf/cf.hpp</label>
        <link refid="cf_8hpp"/>
        <childnode refid="9" relation="include">
        </childnode>
        <childnode refid="11" relation="include">
        </childnode>
        <childnode refid="12" relation="include">
        </childnode>
        <childnode refid="14" relation="include">
        </childnode>
      </node>
      <node id="16">
        <label>/home/aakash/mlpack/src/mlpack/methods/cf/neighbor_search_policies/cosine_search.hpp</label>
        <link refid="cosine__search_8hpp"/>
      </node>
      <node id="46">
        <label>/home/aakash/mlpack/src/mlpack/methods/rann/ra_typedef.hpp</label>
        <link refid="ra__typedef_8hpp"/>
        <childnode refid="45" relation="include">
        </childnode>
      </node>
      <node id="40">
        <label>/home/aakash/mlpack/src/mlpack/methods/dbscan/dbscan.hpp</label>
        <link refid="dbscan_8hpp"/>
      </node>
      <node id="34">
        <label>/home/aakash/mlpack/src/mlpack/methods/gmm/gmm.hpp</label>
        <link refid="gmm_8hpp"/>
        <childnode refid="33" relation="include">
        </childnode>
      </node>
      <node id="42">
        <label>/home/aakash/mlpack/src/mlpack/tests/main_tests/range_search_utils.hpp</label>
        <link refid="range__search__utils_8hpp"/>
      </node>
      <node id="19">
        <label>/home/aakash/mlpack/src/mlpack/methods/kmeans/dual_tree_kmeans.hpp</label>
        <link refid="dual__tree__kmeans_8hpp"/>
      </node>
      <node id="59">
        <label>/home/aakash/mlpack/src/mlpack/core/tree/spill_tree/spill_single_tree_traverser.hpp</label>
        <link refid="spill__single__tree__traverser_8hpp"/>
        <childnode refid="55" relation="include">
        </childnode>
      </node>
      <node id="14">
        <label>/home/aakash/mlpack/src/mlpack/methods/svdplusplus/svdplusplus.hpp</label>
        <link refid="svdplusplus_8hpp"/>
        <childnode refid="15" relation="include">
        </childnode>
      </node>
      <node id="32">
        <label>/home/aakash/mlpack/src/mlpack/methods/gmm/diagonal_gmm.hpp</label>
        <link refid="diagonal__gmm_8hpp"/>
        <childnode refid="33" relation="include">
        </childnode>
      </node>
      <node id="23">
        <label>/home/aakash/mlpack/src/mlpack/methods/neighbor_search/ns_model.hpp</label>
        <link refid="ns__model_8hpp"/>
      </node>
      <node id="45">
        <label>/home/aakash/mlpack/src/mlpack/methods/rann/ra_search.hpp</label>
        <link refid="ra__search_8hpp"/>
        <childnode refid="43" relation="include">
        </childnode>
        <childnode refid="46" relation="include">
        </childnode>
      </node>
      <node id="37">
        <label>/home/aakash/mlpack/src/mlpack/methods/nystroem_method/nystroem_method.hpp</label>
        <link refid="nystroem__method_2nystroem__method_8hpp"/>
        <childnode refid="36" relation="include">
        </childnode>
      </node>
      <node id="56">
        <label>/home/aakash/mlpack/src/mlpack/core/tree/spill_tree/spill_tree.hpp</label>
        <link refid="spill__tree_2spill__tree_8hpp"/>
        <childnode refid="57" relation="include">
        </childnode>
        <childnode refid="58" relation="include">
        </childnode>
        <childnode refid="59" relation="include">
        </childnode>
        <childnode refid="55" relation="include">
        </childnode>
      </node>
      <node id="20">
        <label>/home/aakash/mlpack/src/mlpack/methods/lmnn/constraints.hpp</label>
        <link refid="constraints_8hpp"/>
        <childnode refid="21" relation="include">
        </childnode>
      </node>
      <node id="17">
        <label>/home/aakash/mlpack/src/mlpack/methods/cf/neighbor_search_policies/lmetric_search.hpp</label>
        <link refid="lmetric__search_8hpp"/>
        <childnode refid="8" relation="include">
        </childnode>
      </node>
      <node id="1">
        <label>/home/aakash/mlpack/src/mlpack/core/tree/address.hpp</label>
        <link refid="address_8hpp"/>
        <childnode refid="2" relation="include">
        </childnode>
        <childnode refid="47" relation="include">
        </childnode>
      </node>
      <node id="22">
        <label>/home/aakash/mlpack/src/mlpack/methods/lmnn/lmnn.hpp</label>
        <link refid="lmnn_8hpp"/>
      </node>
      <node id="9">
        <label>/home/aakash/mlpack/src/mlpack/methods/bias_svd/bias_svd.hpp</label>
        <link refid="bias__svd_8hpp"/>
        <childnode refid="10" relation="include">
        </childnode>
      </node>
      <node id="2">
        <label>/home/aakash/mlpack/src/mlpack/core/tree/binary_space_tree/ub_tree_split.hpp</label>
        <link refid="ub__tree__split_8hpp"/>
        <childnode refid="3" relation="include">
        </childnode>
      </node>
      <node id="4">
        <label>/home/aakash/mlpack/src/mlpack/core/tree/binary_space_tree/binary_space_tree.hpp</label>
        <link refid="binary__space__tree_2binary__space__tree_8hpp"/>
        <childnode refid="5" relation="include">
        </childnode>
        <childnode refid="6" relation="include">
        </childnode>
        <childnode refid="3" relation="include">
        </childnode>
        <childnode refid="7" relation="include">
        </childnode>
      </node>
      <node id="43">
        <label>/home/aakash/mlpack/src/mlpack/methods/rann/ra_model.hpp</label>
        <link refid="ra__model_8hpp"/>
      </node>
      <node id="31">
        <label>/home/aakash/mlpack/src/mlpack/methods/gmm/em_fit.hpp</label>
        <link refid="em__fit_8hpp"/>
        <childnode refid="32" relation="include">
        </childnode>
        <childnode refid="34" relation="include">
        </childnode>
      </node>
      <node id="29">
        <label>/home/aakash/mlpack/src/mlpack/methods/kde/kde_model.hpp</label>
        <link refid="kde__model_8hpp"/>
      </node>
      <node id="3">
        <label>/home/aakash/mlpack/src/mlpack/core/tree/binary_space_tree.hpp</label>
        <link refid="binary__space__tree_8hpp"/>
        <childnode refid="4" relation="include">
        </childnode>
        <childnode refid="25" relation="include">
        </childnode>
        <childnode refid="26" relation="include">
        </childnode>
        <childnode refid="27" relation="include">
        </childnode>
        <childnode refid="28" relation="include">
        </childnode>
        <childnode refid="29" relation="include">
        </childnode>
        <childnode refid="19" relation="include">
        </childnode>
        <childnode refid="30" relation="include">
        </childnode>
        <childnode refid="38" relation="include">
        </childnode>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="39" relation="include">
        </childnode>
        <childnode refid="41" relation="include">
        </childnode>
        <childnode refid="43" relation="include">
        </childnode>
        <childnode refid="44" relation="include">
        </childnode>
        <childnode refid="45" relation="include">
        </childnode>
      </node>
      <node id="15">
        <label>/home/aakash/mlpack/src/mlpack/methods/cf/decomposition_policies/svdplusplus_method.hpp</label>
        <link refid="svdplusplus__method_8hpp"/>
      </node>
      <node id="12">
        <label>/home/aakash/mlpack/src/mlpack/methods/regularized_svd/regularized_svd.hpp</label>
        <link refid="regularized__svd_8hpp"/>
        <childnode refid="13" relation="include">
        </childnode>
      </node>
      <node id="44">
        <label>/home/aakash/mlpack/src/mlpack/methods/rann/ra_query_stat.hpp</label>
        <link refid="ra__query__stat_8hpp"/>
        <childnode refid="45" relation="include">
        </childnode>
      </node>
      <node id="57">
        <label>/home/aakash/mlpack/src/mlpack/core/tree/spill_tree/is_spill_tree.hpp</label>
        <link refid="is__spill__tree_8hpp"/>
        <childnode refid="55" relation="include">
        </childnode>
      </node>
      <node id="7">
        <label>/home/aakash/mlpack/src/mlpack/methods/neighbor_search/neighbor_search.hpp</label>
        <link refid="neighbor__search_8hpp"/>
        <childnode refid="8" relation="include">
        </childnode>
        <childnode refid="16" relation="include">
        </childnode>
        <childnode refid="17" relation="include">
        </childnode>
        <childnode refid="18" relation="include">
        </childnode>
        <childnode refid="19" relation="include">
        </childnode>
        <childnode refid="20" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="24" relation="include">
        </childnode>
      </node>
      <node id="41">
        <label>/home/aakash/mlpack/src/mlpack/methods/range_search/rs_model.hpp</label>
        <link refid="rs__model_8hpp"/>
        <childnode refid="42" relation="include">
        </childnode>
      </node>
      <node id="28">
        <label>/home/aakash/mlpack/src/mlpack/methods/kde/kde.hpp</label>
        <link refid="kde_8hpp"/>
        <childnode refid="29" relation="include">
        </childnode>
      </node>
      <node id="18">
        <label>/home/aakash/mlpack/src/mlpack/methods/cf/neighbor_search_policies/pearson_search.hpp</label>
        <link refid="pearson__search_8hpp"/>
      </node>
      <node id="30">
        <label>/home/aakash/mlpack/src/mlpack/methods/kmeans/kmeans.hpp</label>
        <link refid="kmeans_8hpp"/>
        <childnode refid="31" relation="include">
        </childnode>
        <childnode refid="35" relation="include">
        </childnode>
      </node>
      <node id="49">
        <label>/home/aakash/mlpack/src/mlpack/core/tree/octree.hpp</label>
        <link refid="octree_8hpp"/>
        <childnode refid="29" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="41" relation="include">
        </childnode>
        <childnode refid="43" relation="include">
        </childnode>
      </node>
      <node id="27">
        <label>/home/aakash/mlpack/src/mlpack/methods/emst/dtb.hpp</label>
        <link refid="dtb_8hpp"/>
      </node>
      <node id="35">
        <label>/home/aakash/mlpack/src/mlpack/methods/nystroem_method/kmeans_selection.hpp</label>
        <link refid="kmeans__selection_8hpp"/>
        <childnode refid="36" relation="include">
        </childnode>
        <childnode refid="37" relation="include">
        </childnode>
      </node>
      <node id="33">
        <label>/home/aakash/mlpack/src/mlpack/methods/hmm/hmm_model.hpp</label>
        <link refid="hmm__model_8hpp"/>
      </node>
      <node id="36">
        <label>/home/aakash/mlpack/src/mlpack/methods/kernel_pca/kernel_rules/nystroem_method.hpp</label>
        <link refid="kernel__pca_2kernel__rules_2nystroem__method_8hpp"/>
      </node>
      <node id="25">
        <label>/home/aakash/mlpack/src/mlpack/core/tree/binary_space_tree/breadth_first_dual_tree_traverser.hpp</label>
        <link refid="breadth__first__dual__tree__traverser_8hpp"/>
        <childnode refid="3" relation="include">
        </childnode>
      </node>
      <node id="26">
        <label>/home/aakash/mlpack/src/mlpack/core/tree/binary_space_tree/typedef.hpp</label>
        <link refid="core_2tree_2binary__space__tree_2typedef_8hpp"/>
        <childnode refid="3" relation="include">
        </childnode>
      </node>
      <node id="50">
        <label>/home/aakash/mlpack/src/mlpack/core/tree/rectangle_tree.hpp</label>
        <link refid="rectangle__tree_8hpp"/>
        <childnode refid="29" relation="include">
        </childnode>
        <childnode refid="7" relation="include">
        </childnode>
        <childnode refid="23" relation="include">
        </childnode>
        <childnode refid="41" relation="include">
        </childnode>
        <childnode refid="43" relation="include">
        </childnode>
      </node>
      <node id="53">
        <label>/home/aakash/mlpack/src/mlpack/core/tree/space_split/mean_space_split.hpp</label>
        <link refid="mean__space__split_8hpp"/>
        <childnode refid="54" relation="include">
        </childnode>
      </node>
      <node id="47">
        <label>/home/aakash/mlpack/src/mlpack/core/tree/cellbound.hpp</label>
        <link refid="cellbound_8hpp"/>
        <childnode refid="48" relation="include">
        </childnode>
      </node>
    </invincdepgraph>
    <innernamespace refid="namespacemlpack">mlpack</innernamespace>
    <innernamespace refid="namespacemlpack_1_1bound">mlpack::bound</innernamespace>
    <innernamespace refid="namespacemlpack_1_1bound_1_1addr">mlpack::bound::addr</innernamespace>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para><simplesect kind="author"><para>Mikhail Lozhnikov</para>
</simplesect>
This file contains a series of functions for translating points to addresses and back and functions for comparing addresses.</para>
<para>The notion of addresses is described in the following paper. <programlisting><codeline><highlight class="normal">@inproceedings{bayer1997,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>author<sp/>=<sp/>{Bayer,<sp/>Rudolf},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>title<sp/>=<sp/>{The<sp/>Universal<sp/>B-Tree<sp/>for<sp/>Multidimensional<sp/>Indexing:<sp/>General</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Concepts},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>booktitle<sp/>=<sp/>{Proceedings<sp/>of<sp/>the<sp/>International<sp/>Conference<sp/>on<sp/>Worldwide</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>Computing<sp/>and<sp/>Its<sp/>Applications},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>series<sp/>=<sp/>{WWCA<sp/>&apos;97},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>year<sp/>=<sp/>{1997},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>isbn<sp/>=<sp/>{3-540-63343-X},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pages<sp/>=<sp/>{198--209},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>numpages<sp/>=<sp/>{12},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>publisher<sp/>=<sp/>{Springer-Verlag},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>address<sp/>=<sp/>{London,<sp/>UK,<sp/>UK},</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>
    </detaileddescription>
    <programlisting>
<codeline lineno="1"><highlight class="normal"></highlight></codeline>
<codeline lineno="26"><highlight class="normal"></highlight><highlight class="preprocessor">#ifndef<sp/>MLPACK_CORE_TREE_ADDRESS_HPP</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="27"><highlight class="normal"></highlight><highlight class="preprocessor">#define<sp/>MLPACK_CORE_TREE_ADDRESS_HPP</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="28"><highlight class="normal"></highlight></codeline>
<codeline lineno="29"><highlight class="normal"></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal"><ref refid="namespacemlpack" kindref="compound">mlpack</ref><sp/>{</highlight></codeline>
<codeline lineno="30" refid="namespacemlpack_1_1bound" refkind="compound"><highlight class="normal"></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">bound<sp/>{</highlight></codeline>
<codeline lineno="31" refid="namespacemlpack_1_1bound_1_1addr" refkind="compound"><highlight class="normal"></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">addr<sp/>{</highlight></codeline>
<codeline lineno="32"><highlight class="normal"></highlight></codeline>
<codeline lineno="56"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>AddressType,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>VecType&gt;</highlight></codeline>
<codeline lineno="57" refid="namespacemlpack_1_1bound_1_1addr_1acfd59826c56bc489ec735101a942eb79" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="namespacemlpack_1_1bound_1_1addr_1acfd59826c56bc489ec735101a942eb79" kindref="member">PointToAddress</ref>(AddressType&amp;<sp/>address,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>VecType&amp;<sp/>point)</highlight></codeline>
<codeline lineno="58"><highlight class="normal">{</highlight></codeline>
<codeline lineno="59"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>VecType::elem_type<sp/>VecElemType;</highlight></codeline>
<codeline lineno="60"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Check<sp/>that<sp/>the<sp/>arguments<sp/>are<sp/>compatible.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="61"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>std::conditional&lt;</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(VecElemType)<sp/>*<sp/>CHAR_BIT<sp/>&lt;=<sp/>32,</highlight></codeline>
<codeline lineno="62"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint32_t,</highlight></codeline>
<codeline lineno="63"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint64_t&gt;::type<sp/>AddressElemType;</highlight></codeline>
<codeline lineno="64"><highlight class="normal"></highlight></codeline>
<codeline lineno="65"><highlight class="normal"><sp/><sp/>static_assert(std::is_same&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>AddressType::elem_type,</highlight></codeline>
<codeline lineno="66"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>AddressElemType&gt;::value<sp/>==<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>vector<sp/>element<sp/>type<sp/>does<sp/>not<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="67"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;correspond<sp/>to<sp/>the<sp/>address<sp/>element<sp/>type.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="68"><highlight class="normal"><sp/><sp/>arma::Col&lt;AddressElemType&gt;<sp/>result(point.n_elem);</highlight></codeline>
<codeline lineno="69"><highlight class="normal"></highlight></codeline>
<codeline lineno="70"><highlight class="normal"><sp/><sp/>constexpr<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>order<sp/>=<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(AddressElemType)<sp/>*<sp/>CHAR_BIT;</highlight></codeline>
<codeline lineno="71"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Calculate<sp/>the<sp/>number<sp/>of<sp/>bits<sp/>for<sp/>the<sp/>exponent.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="72"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>numExpBits<sp/>=<sp/>std::ceil(std::log2(</highlight></codeline>
<codeline lineno="73"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::numeric_limits&lt;VecElemType&gt;::max_exponent<sp/>-</highlight></codeline>
<codeline lineno="74"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::numeric_limits&lt;VecElemType&gt;::min_exponent<sp/>+<sp/>1.0));</highlight></codeline>
<codeline lineno="75"><highlight class="normal"></highlight></codeline>
<codeline lineno="76"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Calculate<sp/>the<sp/>number<sp/>of<sp/>bits<sp/>for<sp/>the<sp/>mantissa.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="77"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>numMantBits<sp/>=<sp/>order<sp/>-<sp/>numExpBits<sp/>-<sp/>1;</highlight></codeline>
<codeline lineno="78"><highlight class="normal"></highlight></codeline>
<codeline lineno="79"><highlight class="normal"><sp/><sp/>assert(point.n_elem<sp/>==<sp/>address.n_elem);</highlight></codeline>
<codeline lineno="80"><highlight class="normal"><sp/><sp/>assert(address.n_elem<sp/>&gt;<sp/>0);</highlight></codeline>
<codeline lineno="81"><highlight class="normal"></highlight></codeline>
<codeline lineno="82"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>point.n_elem;<sp/>++i)</highlight></codeline>
<codeline lineno="83"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="84"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>e;</highlight></codeline>
<codeline lineno="85"><highlight class="normal"><sp/><sp/><sp/><sp/>VecElemType<sp/>normalizedVal<sp/>=<sp/>std::frexp(point(i),<sp/>&amp;e);</highlight></codeline>
<codeline lineno="86"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>sgn<sp/>=<sp/>std::signbit(normalizedVal);</highlight></codeline>
<codeline lineno="87"><highlight class="normal"></highlight></codeline>
<codeline lineno="88"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(point(i)<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="89"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>e<sp/>=<sp/>std::numeric_limits&lt;VecElemType&gt;::min_exponent;</highlight></codeline>
<codeline lineno="90"><highlight class="normal"></highlight></codeline>
<codeline lineno="91"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(sgn)</highlight></codeline>
<codeline lineno="92"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>normalizedVal<sp/>=<sp/>-normalizedVal;</highlight></codeline>
<codeline lineno="93"><highlight class="normal"></highlight></codeline>
<codeline lineno="94"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(e<sp/>&lt;<sp/>std::numeric_limits&lt;VecElemType&gt;::min_exponent)</highlight></codeline>
<codeline lineno="95"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="96"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>AddressElemType<sp/>tmp<sp/>=<sp/>(AddressElemType)<sp/>1<sp/>&lt;&lt;</highlight></codeline>
<codeline lineno="97"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(std::numeric_limits&lt;VecElemType&gt;::min_exponent<sp/>-<sp/>e);</highlight></codeline>
<codeline lineno="98"><highlight class="normal"></highlight></codeline>
<codeline lineno="99"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>e<sp/>=<sp/>std::numeric_limits&lt;VecElemType&gt;::min_exponent;</highlight></codeline>
<codeline lineno="100"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>normalizedVal<sp/>/=<sp/>tmp;</highlight></codeline>
<codeline lineno="101"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="102"><highlight class="normal"></highlight></codeline>
<codeline lineno="103"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Extract<sp/>the<sp/>mantissa.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="104"><highlight class="normal"><sp/><sp/><sp/><sp/>AddressElemType<sp/>tmp<sp/>=<sp/>(AddressElemType)<sp/>1<sp/>&lt;&lt;<sp/>numMantBits;</highlight></codeline>
<codeline lineno="105"><highlight class="normal"><sp/><sp/><sp/><sp/>result(i)<sp/>=<sp/>std::floor(normalizedVal<sp/>*<sp/>tmp);</highlight></codeline>
<codeline lineno="106"><highlight class="normal"></highlight></codeline>
<codeline lineno="107"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Add<sp/>the<sp/>exponent.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="108"><highlight class="normal"><sp/><sp/><sp/><sp/>assert(result(i)<sp/>&lt;<sp/>((AddressElemType)<sp/>1<sp/>&lt;&lt;<sp/>numMantBits));</highlight></codeline>
<codeline lineno="109"><highlight class="normal"><sp/><sp/><sp/><sp/>result(i)<sp/>|=<sp/>((AddressElemType)</highlight></codeline>
<codeline lineno="110"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(e<sp/>-<sp/>std::numeric_limits&lt;VecElemType&gt;::min_exponent))<sp/>&lt;&lt;<sp/>numMantBits;</highlight></codeline>
<codeline lineno="111"><highlight class="normal"></highlight></codeline>
<codeline lineno="112"><highlight class="normal"><sp/><sp/><sp/><sp/>assert(result(i)<sp/>&lt;<sp/>((AddressElemType)<sp/>1<sp/>&lt;&lt;<sp/>(order<sp/>-<sp/>1))<sp/>-<sp/>1);</highlight></codeline>
<codeline lineno="113"><highlight class="normal"></highlight></codeline>
<codeline lineno="114"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Negative<sp/>values<sp/>should<sp/>be<sp/>inverted.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="115"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(sgn)</highlight></codeline>
<codeline lineno="116"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="117"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>result(i)<sp/>=<sp/>((AddressElemType)<sp/>1<sp/>&lt;&lt;<sp/>(order<sp/>-<sp/>1))<sp/>-<sp/>1<sp/>-<sp/>result(i);</highlight></codeline>
<codeline lineno="118"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>assert((result(i)<sp/>&gt;&gt;<sp/>(order<sp/>-<sp/>1))<sp/>==<sp/>0);</highlight></codeline>
<codeline lineno="119"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="120"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="121"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="122"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>result(i)<sp/>|=<sp/>(AddressElemType)<sp/>1<sp/>&lt;&lt;<sp/>(order<sp/>-<sp/>1);</highlight></codeline>
<codeline lineno="123"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>assert((result(i)<sp/>&gt;&gt;<sp/>(order<sp/>-<sp/>1))<sp/>==<sp/>1);</highlight></codeline>
<codeline lineno="124"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="125"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="126"><highlight class="normal"></highlight></codeline>
<codeline lineno="127"><highlight class="normal"><sp/><sp/>address.zeros(point.n_elem);</highlight></codeline>
<codeline lineno="128"><highlight class="normal"></highlight></codeline>
<codeline lineno="129"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Interleave<sp/>the<sp/>bits<sp/>of<sp/>the<sp/>new<sp/>representation<sp/>across<sp/>all<sp/>the<sp/>elements</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="130"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>in<sp/>the<sp/>address<sp/>vector.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="131"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>order;<sp/>++i)</highlight></codeline>
<codeline lineno="132"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>point.n_elem;<sp/>++j)</highlight></codeline>
<codeline lineno="133"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="134"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>bit<sp/>=<sp/>(i<sp/>*<sp/>point.n_elem<sp/>+<sp/>j)<sp/>%<sp/>order;</highlight></codeline>
<codeline lineno="135"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>row<sp/>=<sp/>(i<sp/>*<sp/>point.n_elem<sp/>+<sp/>j)<sp/>/<sp/>order;</highlight></codeline>
<codeline lineno="136"><highlight class="normal"></highlight></codeline>
<codeline lineno="137"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>address(row)<sp/>|=<sp/>(((result(j)<sp/>&gt;&gt;<sp/>(order<sp/>-<sp/>1<sp/>-<sp/>i))<sp/>&amp;<sp/>1)<sp/>&lt;&lt;</highlight></codeline>
<codeline lineno="138"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(order<sp/>-<sp/>1<sp/>-<sp/>bit));</highlight></codeline>
<codeline lineno="139"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="140"><highlight class="normal">}</highlight></codeline>
<codeline lineno="141"><highlight class="normal"></highlight></codeline>
<codeline lineno="152"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>AddressType,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>VecType&gt;</highlight></codeline>
<codeline lineno="153" refid="namespacemlpack_1_1bound_1_1addr_1a55e57f732bc2f6f587b58e59d6fb918a" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="namespacemlpack_1_1bound_1_1addr_1a55e57f732bc2f6f587b58e59d6fb918a" kindref="member">AddressToPoint</ref>(VecType&amp;<sp/>point,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>AddressType&amp;<sp/>address)</highlight></codeline>
<codeline lineno="154"><highlight class="normal">{</highlight></codeline>
<codeline lineno="155"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>VecType::elem_type<sp/>VecElemType;</highlight></codeline>
<codeline lineno="156"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Check<sp/>that<sp/>the<sp/>arguments<sp/>are<sp/>compatible.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="157"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">typedef</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>std::conditional&lt;</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(VecElemType)<sp/>*<sp/>CHAR_BIT<sp/>&lt;=<sp/>32,</highlight></codeline>
<codeline lineno="158"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint32_t,</highlight></codeline>
<codeline lineno="159"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>uint64_t&gt;::type<sp/>AddressElemType;</highlight></codeline>
<codeline lineno="160"><highlight class="normal"></highlight></codeline>
<codeline lineno="161"><highlight class="normal"><sp/><sp/>static_assert(std::is_same&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>AddressType::elem_type,</highlight></codeline>
<codeline lineno="162"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>AddressElemType&gt;::value<sp/>==<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;The<sp/>vector<sp/>element<sp/>type<sp/>does<sp/>not<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="163"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;correspond<sp/>to<sp/>the<sp/>address<sp/>element<sp/>type.&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="164"><highlight class="normal"></highlight></codeline>
<codeline lineno="165"><highlight class="normal"><sp/><sp/>constexpr<sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>order<sp/>=<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(AddressElemType)<sp/>*<sp/>CHAR_BIT;</highlight></codeline>
<codeline lineno="166"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Calculate<sp/>the<sp/>number<sp/>of<sp/>bits<sp/>for<sp/>the<sp/>exponent.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="167"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>numExpBits<sp/>=<sp/>std::ceil(std::log2(</highlight></codeline>
<codeline lineno="168"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::numeric_limits&lt;VecElemType&gt;::max_exponent<sp/>-</highlight></codeline>
<codeline lineno="169"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>std::numeric_limits&lt;VecElemType&gt;::min_exponent<sp/>+<sp/>1.0));</highlight></codeline>
<codeline lineno="170"><highlight class="normal"></highlight></codeline>
<codeline lineno="171"><highlight class="normal"><sp/><sp/>assert(point.n_elem<sp/>==<sp/>address.n_elem);</highlight></codeline>
<codeline lineno="172"><highlight class="normal"><sp/><sp/>assert(address.n_elem<sp/>&gt;<sp/>0);</highlight></codeline>
<codeline lineno="173"><highlight class="normal"></highlight></codeline>
<codeline lineno="174"><highlight class="normal"><sp/><sp/>arma::Col&lt;AddressElemType&gt;<sp/>rearrangedAddress(address.n_elem,</highlight></codeline>
<codeline lineno="175"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>arma::fill::zeros);</highlight></codeline>
<codeline lineno="176"><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Calculate<sp/>the<sp/>number<sp/>of<sp/>bits<sp/>for<sp/>the<sp/>mantissa.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="177"><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>numMantBits<sp/>=<sp/>order<sp/>-<sp/>numExpBits<sp/>-<sp/>1;</highlight></codeline>
<codeline lineno="178"><highlight class="normal"></highlight></codeline>
<codeline lineno="179"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>order;<sp/>++i)</highlight></codeline>
<codeline lineno="180"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>address.n_elem;<sp/>++j)</highlight></codeline>
<codeline lineno="181"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="182"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>bit<sp/>=<sp/>(i<sp/>*<sp/>address.n_elem<sp/>+<sp/>j)<sp/>%<sp/>order;</highlight></codeline>
<codeline lineno="183"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>row<sp/>=<sp/>(i<sp/>*<sp/>address.n_elem<sp/>+<sp/>j)<sp/>/<sp/>order;</highlight></codeline>
<codeline lineno="184"><highlight class="normal"></highlight></codeline>
<codeline lineno="185"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>rearrangedAddress(j)<sp/>|=<sp/>(((address(row)<sp/>&gt;&gt;<sp/>(order<sp/>-<sp/>1<sp/>-<sp/>bit))<sp/>&amp;<sp/>1)<sp/>&lt;&lt;</highlight></codeline>
<codeline lineno="186"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(order<sp/>-<sp/>1<sp/>-<sp/>i));</highlight></codeline>
<codeline lineno="187"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="188"><highlight class="normal"></highlight></codeline>
<codeline lineno="189"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>rearrangedAddress.n_elem;<sp/>++i)</highlight></codeline>
<codeline lineno="190"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="191"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>sgn<sp/>=<sp/>rearrangedAddress(i)<sp/>&amp;<sp/>((AddressElemType)<sp/>1<sp/>&lt;&lt;<sp/>(order<sp/>-<sp/>1));</highlight></codeline>
<codeline lineno="192"><highlight class="normal"></highlight></codeline>
<codeline lineno="193"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!sgn)</highlight></codeline>
<codeline lineno="194"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="195"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>rearrangedAddress(i)<sp/>=<sp/>((AddressElemType)<sp/>1<sp/>&lt;&lt;<sp/>(order<sp/>-<sp/>1))<sp/>-<sp/>1<sp/>-</highlight></codeline>
<codeline lineno="196"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>rearrangedAddress(i);</highlight></codeline>
<codeline lineno="197"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="198"><highlight class="normal"></highlight></codeline>
<codeline lineno="199"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Extract<sp/>the<sp/>mantissa.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="200"><highlight class="normal"><sp/><sp/><sp/><sp/>AddressElemType<sp/>tmp<sp/>=<sp/>(AddressElemType)<sp/>1<sp/>&lt;&lt;<sp/>numMantBits;</highlight></codeline>
<codeline lineno="201"><highlight class="normal"><sp/><sp/><sp/><sp/>AddressElemType<sp/>mantissa<sp/>=<sp/>rearrangedAddress(i)<sp/>&amp;<sp/>(tmp<sp/>-<sp/>1);</highlight></codeline>
<codeline lineno="202"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(mantissa<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="203"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>mantissa<sp/>=<sp/>1;</highlight></codeline>
<codeline lineno="204"><highlight class="normal"></highlight></codeline>
<codeline lineno="205"><highlight class="normal"><sp/><sp/><sp/><sp/>VecElemType<sp/>normalizedVal<sp/>=<sp/>(VecElemType)<sp/>mantissa<sp/>/<sp/>tmp;</highlight></codeline>
<codeline lineno="206"><highlight class="normal"></highlight></codeline>
<codeline lineno="207"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!sgn)</highlight></codeline>
<codeline lineno="208"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>normalizedVal<sp/>=<sp/>-normalizedVal;</highlight></codeline>
<codeline lineno="209"><highlight class="normal"></highlight></codeline>
<codeline lineno="210"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Extract<sp/>the<sp/>exponent</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="211"><highlight class="normal"><sp/><sp/><sp/><sp/>tmp<sp/>=<sp/>(AddressElemType)<sp/>1<sp/>&lt;&lt;<sp/>numExpBits;</highlight></codeline>
<codeline lineno="212"><highlight class="normal"><sp/><sp/><sp/><sp/>AddressElemType<sp/>e<sp/>=<sp/>(rearrangedAddress(i)<sp/>&gt;&gt;<sp/>numMantBits)<sp/>&amp;<sp/>(tmp<sp/>-<sp/>1);</highlight></codeline>
<codeline lineno="213"><highlight class="normal"></highlight></codeline>
<codeline lineno="214"><highlight class="normal"><sp/><sp/><sp/><sp/>e<sp/>+=<sp/>std::numeric_limits&lt;VecElemType&gt;::min_exponent;</highlight></codeline>
<codeline lineno="215"><highlight class="normal"></highlight></codeline>
<codeline lineno="216"><highlight class="normal"><sp/><sp/><sp/><sp/>point(i)<sp/>=<sp/>std::ldexp(normalizedVal,<sp/>e);</highlight></codeline>
<codeline lineno="217"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(std::isinf(point(i)))</highlight></codeline>
<codeline lineno="218"><highlight class="normal"><sp/><sp/><sp/><sp/>{</highlight></codeline>
<codeline lineno="219"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(point(i)<sp/>&gt;<sp/>0)</highlight></codeline>
<codeline lineno="220"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>point(i)<sp/>=<sp/>std::numeric_limits&lt;VecElemType&gt;::max();</highlight></codeline>
<codeline lineno="221"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="222"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>point(i)<sp/>=<sp/>std::numeric_limits&lt;VecElemType&gt;::lowest();</highlight></codeline>
<codeline lineno="223"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="224"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="225"><highlight class="normal">}</highlight></codeline>
<codeline lineno="226"><highlight class="normal"></highlight></codeline>
<codeline lineno="232"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>AddressType1,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>AddressType2&gt;</highlight></codeline>
<codeline lineno="233" refid="namespacemlpack_1_1bound_1_1addr_1ad39b49870fa074ad011a4d4c0ee93665" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/><ref refid="namespacemlpack_1_1bound_1_1addr_1ad39b49870fa074ad011a4d4c0ee93665" kindref="member">CompareAddresses</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>AddressType1&amp;<sp/>addr1,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>AddressType2&amp;<sp/>addr2)</highlight></codeline>
<codeline lineno="234"><highlight class="normal">{</highlight></codeline>
<codeline lineno="235"><highlight class="normal"><sp/><sp/>static_assert(std::is_same&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>AddressType1::elem_type,</highlight></codeline>
<codeline lineno="236"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>AddressType2::elem_type&gt;::value<sp/>==<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">,<sp/></highlight><highlight class="stringliteral">&quot;Can&apos;t<sp/>compare<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="237"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;addresses<sp/>of<sp/>distinct<sp/>types&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="238"><highlight class="normal"></highlight></codeline>
<codeline lineno="239"><highlight class="normal"><sp/><sp/>assert(addr1.n_elem<sp/>==<sp/>addr2.n_elem);</highlight></codeline>
<codeline lineno="240"><highlight class="normal"></highlight></codeline>
<codeline lineno="241"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>addr1.n_elem;<sp/>++i)</highlight></codeline>
<codeline lineno="242"><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline lineno="243"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(addr1[i]<sp/>&lt;<sp/>addr2[i])</highlight></codeline>
<codeline lineno="244"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline lineno="245"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(addr2[i]<sp/>&lt;<sp/>addr1[i])</highlight></codeline>
<codeline lineno="246"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline lineno="247"><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline lineno="248"><highlight class="normal"></highlight></codeline>
<codeline lineno="249"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline lineno="250"><highlight class="normal">}</highlight></codeline>
<codeline lineno="251"><highlight class="normal"></highlight></codeline>
<codeline lineno="255"><highlight class="normal"></highlight><highlight class="keyword">template</highlight><highlight class="normal">&lt;</highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>AddressType1,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>AddressType2,<sp/></highlight><highlight class="keyword">typename</highlight><highlight class="normal"><sp/>AddressType3&gt;</highlight></codeline>
<codeline lineno="256" refid="namespacemlpack_1_1bound_1_1addr_1a64110a8c86f23288f4fef77ff8ac63a4" refkind="member"><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/><ref refid="namespacemlpack_1_1bound_1_1addr_1a64110a8c86f23288f4fef77ff8ac63a4" kindref="member">Contains</ref>(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>AddressType1&amp;<sp/>address,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>AddressType2&amp;<sp/>loBound,</highlight></codeline>
<codeline lineno="257"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>AddressType3&amp;<sp/>hiBound)</highlight></codeline>
<codeline lineno="258"><highlight class="normal">{</highlight></codeline>
<codeline lineno="259"><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>((<ref refid="namespacemlpack_1_1bound_1_1addr_1ad39b49870fa074ad011a4d4c0ee93665" kindref="member">CompareAddresses</ref>(loBound,<sp/>address)<sp/>&lt;=<sp/>0)<sp/>&amp;&amp;</highlight></codeline>
<codeline lineno="260"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(<ref refid="namespacemlpack_1_1bound_1_1addr_1ad39b49870fa074ad011a4d4c0ee93665" kindref="member">CompareAddresses</ref>(hiBound,<sp/>address)<sp/>&gt;=<sp/>0));</highlight></codeline>
<codeline lineno="261"><highlight class="normal">}</highlight></codeline>
<codeline lineno="262"><highlight class="normal"></highlight></codeline>
<codeline lineno="263"><highlight class="normal">}<sp/></highlight><highlight class="comment">//<sp/>namespace<sp/>addr</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="264"><highlight class="normal">}<sp/></highlight><highlight class="comment">//<sp/>namespace<sp/>bound</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="265"><highlight class="normal">}<sp/></highlight><highlight class="comment">//<sp/>namespace<sp/>mlpack</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="266"><highlight class="normal"></highlight></codeline>
<codeline lineno="267"><highlight class="normal"></highlight><highlight class="preprocessor">#endif<sp/></highlight><highlight class="comment">//<sp/>MLPACK_CORE_TREE_ADDRESS_HPP</highlight><highlight class="normal"></highlight></codeline>
    </programlisting>
    <location file="/home/aakash/mlpack/src/mlpack/core/tree/address.hpp"/>
  </compounddef>
</doxygen>
