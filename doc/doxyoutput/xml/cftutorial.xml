<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="cftutorial" kind="page">
    <compoundname>cftutorial</compoundname>
    <title>Collaborative filtering tutorial</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<sect1 id="cftutorial_1intro_cftut">
<title>Introduction</title>
<para>Collaborative filtering is an increasingly popular approach for recommender systems. A typical formulation of the problem is as follows: there are <formula id="180">$n$</formula> users and <formula id="181">$m$</formula> items, and each user has rated some of the items. We want to provide each user with a recommendation for an item they have not rated yet, which they are likely to rate highly. In another formulation, we may want to predict a user&apos;s rating of an item. This type of problem has been considered extensively, especially in the context of the Netflix prize. The winning approach for the Netflix prize was a collaborative filtering approach which utilized matrix decomposition. More information on their approach can be found in the following paper:</para>
<para><programlisting><codeline><highlight class="normal">@article{koren2009matrix,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>title={Matrix<sp/>factorization<sp/>techniques<sp/>for<sp/>recommender<sp/>systems},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>author={Koren,<sp/>Yehuda<sp/>and<sp/>Bell,<sp/>Robert<sp/>and<sp/>Volinsky,<sp/>Chris},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>journal={Computer},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>number={8},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pages={30--37},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>year={2009},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>publisher={IEEE}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>The key to this approach is that the data is represented as an incomplete matrix <formula id="182">$V \in \Re^{n \times m}$</formula>, where <formula id="183">$V_{ij}$</formula> represents user <formula id="184">$i$</formula>&apos;s rating of item <formula id="185">$j$</formula>, if that rating exists. The task, then, is to complete the entries of the matrix.</para>
<para>In the matrix factorization framework, the matrix <formula id="186">$V$</formula> is assumed to be low-rank and decomposed into components as <formula id="187">$V \approx WH$</formula> according to some heuristic.</para>
<para>In order to solve problems of this form, <bold>mlpack</bold> provides:</para>
<para><itemizedlist>
<listitem><para>a <ref refid="cftutorial_1cli_cftut" kindref="member">simple command-line interface</ref> to perform collaborative filtering</para>
</listitem><listitem><para>a <ref refid="cftutorial_1cf_cftut" kindref="member">simple C++ interface</ref> to perform collaborative filtering</para>
</listitem><listitem><para>an <ref refid="cftutorial_1cpp_cftut" kindref="member">extensible C++ interface</ref> for implementing new collaborative filtering techniques</para>
</listitem></itemizedlist>
</para>
</sect1>
<sect1 id="cftutorial_1toc_cftut">
<title>Table of Contents</title>
<para><itemizedlist>
<listitem><para><ref refid="cftutorial_1intro_cftut" kindref="member">Introduction</ref></para>
</listitem><listitem><para><ref refid="cftutorial_1toc_cftut" kindref="member">Table of Contents</ref></para>
</listitem><listitem><para><ref refid="cftutorial_1cli_cftut" kindref="member">The &apos;mlpack_cf&apos; program</ref><itemizedlist>
<listitem><para><ref refid="cftutorial_1cli_input_format" kindref="member">Input format for mlpack_cf</ref></para>
</listitem><listitem><para><ref refid="cftutorial_1ex1_cf_cli" kindref="member">mlpack_cf with default parameters</ref></para>
</listitem><listitem><para><ref refid="cftutorial_1ex1a_cf_cli" kindref="member">Saving mlpack_cf models</ref></para>
</listitem><listitem><para><ref refid="cftutorial_1ex1b_cf_cli" kindref="member">Loading mlpack_cf models</ref></para>
</listitem><listitem><para><ref refid="cftutorial_1ex2_cf_cli" kindref="member">Specifying rank of mlpack_cf decomposition</ref></para>
</listitem><listitem><para><ref refid="cftutorial_1ex3_cf_cli" kindref="member">mlpack_cf with single-user recommendation</ref></para>
</listitem><listitem><para><ref refid="cftutorial_1ex4_cf_cli" kindref="member">mlpack_cf with non-default factorizer</ref></para>
</listitem><listitem><para><ref refid="cftutorial_1ex5_cf_cli" kindref="member">mlpack_cf with non-default neighborhood size</ref></para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para><ref refid="cftutorial_1cf_cftut" kindref="member">The &apos;CF&apos; class</ref><itemizedlist>
<listitem><para><ref refid="cftutorial_1ex1_cf_cpp" kindref="member">CF with default parameters</ref></para>
</listitem><listitem><para><ref refid="cftutorial_1ex2_cf_cpp" kindref="member">CF with other factorizers</ref></para>
</listitem><listitem><para><ref refid="cftutorial_1ex3_cf_cpp" kindref="member">Predicting individual user/item ratings</ref></para>
</listitem><listitem><para><ref refid="cftutorial_1ex4_cf_cpp" kindref="member">Other operations with the W and H matrices</ref></para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para><ref refid="cftutorial_1cpp_cftut" kindref="member">Template parameters for the &apos;CF&apos; class</ref></para>
</listitem><listitem><para><ref refid="cftutorial_1further_doc_cftut" kindref="member">Further documentation</ref></para>
</listitem></itemizedlist>
</para>
</sect1>
<sect1 id="cftutorial_1cli_cftut">
<title>The &apos;mlpack_cf&apos; program</title>
<para><bold>mlpack</bold> provides a command-line program, <computeroutput>mlpack_cf</computeroutput>, which is used to perform collaborative filtering on a given dataset. It can provide neighborhood-based recommendations for users. The algorithm used for matrix factorization is configurable, and the parameters of each algorithm are also configurable.</para>
<para>The following examples detail usage of the <computeroutput>mlpack_cf</computeroutput> program. Note that you can get documentation on all the possible parameters by typing:</para>
<para><programlisting><codeline><highlight class="normal">$<sp/>mlpack_cf<sp/>--help</highlight></codeline>
</programlisting></para>
<sect2 id="cftutorial_1cli_input_format">
<title>Input format for mlpack_cf</title>
<para>The input file for the <computeroutput>mlpack_cf</computeroutput> program is specified with the <computeroutput><ndash/>training_file</computeroutput> or <computeroutput>-t</computeroutput> option. This file is a coordinate-format sparse matrix, similar to the Matrix Market (MM) format. The first coordinate is the user id; the second coordinate is the item id; and the third coordinate is the rating. So, for instance, a dataset with 3 users and 2 items, and ratings between 1 and 5, might look like the following:</para>
<para><programlisting><codeline><highlight class="normal">$<sp/>cat<sp/>dataset.csv</highlight></codeline>
<codeline><highlight class="normal">0,<sp/>1,<sp/>4</highlight></codeline>
<codeline><highlight class="normal">1,<sp/>0,<sp/>5</highlight></codeline>
<codeline><highlight class="normal">1,<sp/>1,<sp/>1</highlight></codeline>
<codeline><highlight class="normal">2,<sp/>0,<sp/>2</highlight></codeline>
</programlisting></para>
<para>This dataset has four ratings: user 0 has rated item 1 with a rating of 4; user 1 has rated item 0 with a rating of 5; user 1 has rated item 1 with a rating of 1; and user 2 has rated item 0 with a rating of 2. Note that the user and item indices start from 0, and the identifiers must be numeric indices, and not names.</para>
<para>The type does not necessarily need to be a csv; it can be any supported storage format, assuming that it is a coordinate-format file in the format specified above. For more information on mlpack file formats, see the documentation for <ref refid="namespacemlpack_1_1data_1abbff2a667bf247e00b1fc09b7ca5f831" kindref="member">mlpack::data::Load()</ref>.</para>
</sect2>
<sect2 id="cftutorial_1ex1_cf_cli">
<title>mlpack_cf with default parameters</title>
<para>In this example, we have a dataset from MovieLens, and we want to use <computeroutput>mlpack_cf</computeroutput> with the default parameters, which will provide 5 recommendations for each user, and we wish to save the results in the file <computeroutput>recommendations.csv</computeroutput>. Assuming that our dataset is in the file <computeroutput>MovieLens-100k.csv</computeroutput> and it is in the correct format, we may use the <computeroutput>mlpack_cf</computeroutput> executable as below:</para>
<para><programlisting><codeline><highlight class="normal">$<sp/>mlpack_cf<sp/>-t<sp/>MovieLens-100k.csv<sp/>-v<sp/>-o<sp/>recommendations.csv</highlight></codeline>
</programlisting></para>
<para>The <computeroutput>-v</computeroutput> option provides verbose output, and may be omitted if desired. Now, for each user, we have recommendations in <computeroutput>recommendations.csv:</computeroutput> </para>
<para><programlisting><codeline><highlight class="normal">$<sp/>head<sp/>recommendations.csv</highlight></codeline>
<codeline><highlight class="normal">317,422,482,356,495</highlight></codeline>
<codeline><highlight class="normal">116,120,180,6,327</highlight></codeline>
<codeline><highlight class="normal">312,49,116,99,236</highlight></codeline>
<codeline><highlight class="normal">312,116,99,236,285</highlight></codeline>
<codeline><highlight class="normal">55,190,317,194,63</highlight></codeline>
<codeline><highlight class="normal">171,209,180,175,95</highlight></codeline>
<codeline><highlight class="normal">208,0,94,87,57</highlight></codeline>
<codeline><highlight class="normal">99,97,0,203,172</highlight></codeline>
<codeline><highlight class="normal">257,99,180,287,0</highlight></codeline>
<codeline><highlight class="normal">171,203,172,209,88</highlight></codeline>
</programlisting></para>
<para>So, for user 0, the top 5 recommended items that user 0 has not rated are items 317, 422, 482, 356, and 495. For user 5, the recommendations are on the sixth line: 171, 209, 180, 175, 95.</para>
<para>The <computeroutput>mlpack_cf</computeroutput> program can be built into a larger recommendation framework, with a preprocessing step that can turn user information and item information into numeric IDs, and a postprocessing step that can map these numeric IDs back to the original information.</para>
</sect2>
<sect2 id="cftutorial_1ex1a_cf_cli">
<title>Saving mlpack_cf models</title>
<para>The <computeroutput>mlpack_cf</computeroutput> program is able to save a particular model for later loading. Saving a model can be done with the <computeroutput><ndash/>output_model_file</computeroutput> or <computeroutput>-M</computeroutput> option. The example below builds a CF model on the <computeroutput>MovieLens-100k.csv</computeroutput> dataset, and then saves the model to the file <computeroutput>cf-model.xml</computeroutput> for later usage.</para>
<para><programlisting><codeline><highlight class="normal">$<sp/>mlpack_cf<sp/>-t<sp/>MovieLens-100k.csv<sp/>-M<sp/>cf-model.xml<sp/>-v</highlight></codeline>
</programlisting></para>
<para>The models can also be saved as <computeroutput></computeroutput>.bin or <computeroutput></computeroutput>.txt; the <computeroutput></computeroutput>.xml format provides a human-inspectable format (though the models tend to be quite complex and may be difficult to read). These models can then be re-used to provide specific recommendations for certain users, or other tasks.</para>
</sect2>
<sect2 id="cftutorial_1ex1b_cf_cli">
<title>Loading mlpack_cf models</title>
<para>Instead of training a model, the <computeroutput>mlpack_cf</computeroutput> model can also load a model to provide recommendations, using the <computeroutput><ndash/>input_model_file</computeroutput> or <computeroutput>-m</computeroutput> option. For instance, the example below will load the model from <computeroutput>cf-model.xml</computeroutput> and then generate 3 recommendations for each user in the dataset, saving the results to <computeroutput>recommendations.csv</computeroutput>.</para>
<para><programlisting><codeline><highlight class="normal">$<sp/>mlpack_cf<sp/>-m<sp/>cf-model.xml<sp/>-v<sp/>-o<sp/>recommendations.csv</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="cftutorial_1ex2_cf_cli">
<title>Specifying rank of mlpack_cf decomposition</title>
<para>By default, the matrix factorizations in the <computeroutput>mlpack_cf</computeroutput> program decompose the data matrix into two matrices <formula id="188">$W$</formula> and <formula id="189">$H$</formula> with rank two. Often, this default parameter is not correct, and it makes sense to use a higher-rank decomposition. The rank can be specified with the <computeroutput><ndash/>rank</computeroutput> or <computeroutput>-R</computeroutput> parameter:</para>
<para><programlisting><codeline><highlight class="normal">$<sp/>mlpack_cf<sp/>-t<sp/>MovieLens-100k.csv<sp/>-R<sp/>10<sp/>-v</highlight></codeline>
</programlisting></para>
<para>In the example above, the data matrix will be decomposed into two matrices of rank 10. In general, higher-rank decompositions will take longer, but will give more accurate predictions.</para>
</sect2>
<sect2 id="cftutorial_1ex3_cf_cli">
<title>mlpack_cf with single-user recommendation</title>
<para>In the previous two examples, the output file <computeroutput>recommendations.csv</computeroutput> contains one line for each user in the input dataset. But often, recommendations may only be desired for a few users. In that case, we can assemble a file of query users, with one user per line:</para>
<para><programlisting><codeline><highlight class="normal">$<sp/>cat<sp/>query.csv</highlight></codeline>
<codeline><highlight class="normal">0</highlight></codeline>
<codeline><highlight class="normal">17</highlight></codeline>
<codeline><highlight class="normal">31</highlight></codeline>
</programlisting></para>
<para>Now, if we run the <computeroutput>mlpack_cf</computeroutput> executable with this query file, we will obtain recommendations for users 0, 17, and 31:</para>
<para><programlisting><codeline><highlight class="normal">$<sp/>mlpack_cf<sp/>-i<sp/>MovieLens-100k.csv<sp/>-R<sp/>10<sp/>-q<sp/>query.csv<sp/>-o<sp/>recommendations.csv</highlight></codeline>
<codeline><highlight class="normal">$<sp/>cat<sp/>recommendations.csv</highlight></codeline>
<codeline><highlight class="normal">474,356,317,432,473</highlight></codeline>
<codeline><highlight class="normal">510,172,204,483,182</highlight></codeline>
<codeline><highlight class="normal">0,120,236,257,126</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="cftutorial_1ex4_cf_cli">
<title>mlpack_cf with non-default factorizer</title>
<para>The <computeroutput><ndash/>algorithm</computeroutput> (or <computeroutput>-a</computeroutput> ) parameter controls the factorizer that is used. Several options are available:</para>
<para><itemizedlist>
<listitem><para><computeroutput>&apos;NMF&apos;</computeroutput>: non-negative matrix factorization; see mlpack::amf::AMF&lt;&gt;</para>
</listitem><listitem><para><computeroutput>&apos;SVDBatch&apos;</computeroutput>: SVD batch factorization</para>
</listitem><listitem><para><computeroutput>&apos;SVDIncompleteIncremental&apos;</computeroutput>: incomplete incremental SVD</para>
</listitem><listitem><para><computeroutput>&apos;SVDCompleteIncremental&apos;</computeroutput>: complete incremental SVD</para>
</listitem><listitem><para><computeroutput>&apos;RegSVD&apos;</computeroutput>: regularized SVD; see <ref refid="classmlpack_1_1svd_1_1RegularizedSVD" kindref="compound">mlpack::svd::RegularizedSVD</ref></para>
</listitem></itemizedlist>
</para>
<para>The default factorizer is <computeroutput>&apos;NMF&apos;</computeroutput>. The example below uses the &apos;RegSVD&apos; factorizer:</para>
<para><programlisting><codeline><highlight class="normal">$<sp/>mlpack_cf<sp/>-i<sp/>MovieLens-100k.csv<sp/>-R<sp/>10<sp/>-q<sp/>query.csv<sp/>-a<sp/>RegSVD<sp/>-o<sp/>recommendations.csv</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="cftutorial_1ex5_cf_cli">
<title>mlpack_cf with non-default neighborhood size</title>
<para>The <computeroutput>mlpack_cf</computeroutput> program produces recommendations using a neighborhood: similar users in the query user&apos;s neighborhood will be averaged to produce predictions. The size of this neighborhood is controlled with the <computeroutput><ndash/>neighborhood</computeroutput> (or <computeroutput>-n</computeroutput> ) option. An example using a neighborhood with 10 similar users is below:</para>
<para><programlisting><codeline><highlight class="normal">$<sp/>mlpack_cf<sp/>-i<sp/>MovieLens-100k.csv<sp/>-R<sp/>10<sp/>-q<sp/>query.csv<sp/>-a<sp/>RegSVD<sp/>-n<sp/>10</highlight></codeline>
</programlisting></para>
</sect2>
</sect1>
<sect1 id="cftutorial_1cf_cftut">
<title>The &apos;CF&apos; class</title>
<para>The <computeroutput>CF</computeroutput> class in <bold>mlpack</bold> offers a simple, flexible API for performing collaborative filtering for recommender systems within C++ applications. In the constructor, the <computeroutput>CF</computeroutput> class takes a coordinate-list dataset and decomposes the matrix according to the specified <computeroutput>FactorizerType</computeroutput> template parameter.</para>
<para>Then, the <computeroutput>GetRecommendations()</computeroutput> function may be called to obtain recommendations for certain users (or all users), and the <computeroutput>W()</computeroutput> and <computeroutput>H()</computeroutput> matrices may be accessed to perform other computations.</para>
<para>The data which the <computeroutput>CF</computeroutput> constructor takes should be an Armadillo matrix (<computeroutput>arma::mat</computeroutput> ) with three rows. The first row corresponds to users; the second row corresponds to items; the third column corresponds to the rating. This is a coordinate list format, like the format the <computeroutput>cf</computeroutput> executable takes. The <ref refid="namespacemlpack_1_1data_1abbff2a667bf247e00b1fc09b7ca5f831" kindref="member">data::Load()</ref> function can be used to load data.</para>
<para>The following examples detail a few ways that the <computeroutput>CF</computeroutput> class can be used.</para>
<sect2 id="cftutorial_1ex1_cf_cpp">
<title>CF with default parameters</title>
<para>This example constructs the <computeroutput>CF</computeroutput> object with default parameters and obtains recommendations for each user, storing the output in the <computeroutput>recommendations</computeroutput> matrix.</para>
<para><programlisting><codeline><highlight class="normal">#include<sp/>&lt;mlpack/methods/cf/cf.hpp&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">using<sp/>namespace<sp/>mlpack::cf;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>The<sp/>coordinate<sp/>list<sp/>of<sp/>ratings<sp/>that<sp/>we<sp/>have.</highlight></codeline>
<codeline><highlight class="normal">extern<sp/>arma::mat<sp/>data;</highlight></codeline>
<codeline><highlight class="normal">//<sp/>The<sp/>size<sp/>of<sp/>the<sp/>neighborhood<sp/>to<sp/>use<sp/>to<sp/>get<sp/>recommendations.</highlight></codeline>
<codeline><highlight class="normal">extern<sp/>size_t<sp/>neighborhood;</highlight></codeline>
<codeline><highlight class="normal">//<sp/>The<sp/>rank<sp/>of<sp/>the<sp/>decomposition.</highlight></codeline>
<codeline><highlight class="normal">extern<sp/>size_t<sp/>rank;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Build<sp/>the<sp/>CF<sp/>object<sp/>and<sp/>perform<sp/>the<sp/>decomposition.</highlight></codeline>
<codeline><highlight class="normal">//<sp/>The<sp/>constructor<sp/>takes<sp/>a<sp/>default-constructed<sp/>factorizer,<sp/>which,<sp/>by<sp/>default,</highlight></codeline>
<codeline><highlight class="normal">//<sp/>is<sp/>of<sp/>type<sp/>amf::NMFALSFactorizer.</highlight></codeline>
<codeline><highlight class="normal">CF<sp/>cf(data,<sp/>amf::NMFALSFactorizer(),<sp/>neighborhood,<sp/>rank);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Store<sp/>the<sp/>results<sp/>in<sp/>this<sp/>object.</highlight></codeline>
<codeline><highlight class="normal">arma::Mat&lt;size_t&gt;<sp/>recommendations;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Get<sp/>5<sp/>recommendations<sp/>for<sp/>all<sp/>users.</highlight></codeline>
<codeline><highlight class="normal">cf.GetRecommendations(5,<sp/>recommendations);</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="cftutorial_1ex2_cf_cpp">
<title>CF with other factorizers</title>
<para><bold>mlpack</bold> provides a number of existing factorizers which can be used in place of the default <ref refid="namespacemlpack_1_1amf_1a3e3179901b352438bc974218b6ba0fab" kindref="member">mlpack::amf::NMFALSFactorizer</ref> (which is non-negative matrix factorization with alternating least squares update rules). These include:</para>
<para><itemizedlist>
<listitem><para><ref refid="namespacemlpack_1_1amf_1aedb113157f87759c24e2368dfd7b9216" kindref="member">mlpack::amf::SVDBatchFactorizer</ref></para>
</listitem><listitem><para><ref refid="namespacemlpack_1_1amf_1aeaa4b749fc1afc70451f096dca4228b5" kindref="member">mlpack::amf::SVDCompleteIncrementalFactorizer</ref></para>
</listitem><listitem><para><ref refid="namespacemlpack_1_1amf_1a681ac877cb603d00766e015ff4d4c294" kindref="member">mlpack::amf::SVDIncompleteIncrementalFactorizer</ref></para>
</listitem><listitem><para><ref refid="namespacemlpack_1_1amf_1a3e3179901b352438bc974218b6ba0fab" kindref="member">mlpack::amf::NMFALSFactorizer</ref></para>
</listitem><listitem><para><ref refid="classmlpack_1_1svd_1_1RegularizedSVD" kindref="compound">mlpack::svd::RegularizedSVD</ref></para>
</listitem><listitem><para><ref refid="classmlpack_1_1svd_1_1QUIC__SVD" kindref="compound">mlpack::svd::QUIC_SVD</ref></para>
</listitem></itemizedlist>
</para>
<para>The amf::AMF&lt;&gt; class has many other possibilities than those listed here; it is a framework for alternating matrix factorization techniques. See the <ref refid="classmlpack_1_1amf_1_1AMF" kindref="compound">class documentation</ref> or <ref refid="amftutorial" kindref="compound">tutorial on AMF</ref> for more information.</para>
<para>The use of another factorizer is straightforward; the example from the previous section is adapted below to use svd::RegularizedSVD:</para>
<para><programlisting><codeline><highlight class="normal">#include<sp/>&lt;mlpack/methods/cf/cf.hpp&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;mlpack/methods/regularized_svd/regularized_svd.hpp&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">using<sp/>namespace<sp/>mlpack::cf;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>The<sp/>coordinate<sp/>list<sp/>of<sp/>ratings<sp/>that<sp/>we<sp/>have.</highlight></codeline>
<codeline><highlight class="normal">extern<sp/>arma::mat<sp/>data;</highlight></codeline>
<codeline><highlight class="normal">//<sp/>The<sp/>size<sp/>of<sp/>the<sp/>neighborhood<sp/>to<sp/>use<sp/>to<sp/>get<sp/>recommendations.</highlight></codeline>
<codeline><highlight class="normal">extern<sp/>size_t<sp/>neighborhood;</highlight></codeline>
<codeline><highlight class="normal">//<sp/>The<sp/>rank<sp/>of<sp/>the<sp/>decomposition.</highlight></codeline>
<codeline><highlight class="normal">extern<sp/>size_t<sp/>rank;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Build<sp/>the<sp/>CF<sp/>object<sp/>and<sp/>perform<sp/>the<sp/>decomposition.</highlight></codeline>
<codeline><highlight class="normal">CF<sp/>cf(data,<sp/>svd::RegularizedSVD(),<sp/>neighborhood,<sp/>rank);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Store<sp/>the<sp/>results<sp/>in<sp/>this<sp/>object.</highlight></codeline>
<codeline><highlight class="normal">arma::Mat&lt;size_t&gt;<sp/>recommendations;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Get<sp/>5<sp/>recommendations<sp/>for<sp/>all<sp/>users.</highlight></codeline>
<codeline><highlight class="normal">cf.GetRecommendations(5,<sp/>recommendations);</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="cftutorial_1ex3_cf_cpp">
<title>Predicting individual user/item ratings</title>
<para>The <computeroutput>Predict()</computeroutput> method can be used to predict the rating of an item by a certain user, using the same neighborhood-based approach as the <computeroutput>GetRecommendations()</computeroutput> function or the <computeroutput>cf</computeroutput> executable. Below is an example of the use of that function.</para>
<para>The example below will obtain the predicted rating for item 50 by user 12.</para>
<para><programlisting><codeline><highlight class="normal">#include<sp/>&lt;mlpack/methods/cf/cf.hpp&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">using<sp/>namespace<sp/>mlpack::cf;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>The<sp/>coordinate<sp/>list<sp/>of<sp/>ratings<sp/>that<sp/>we<sp/>have.</highlight></codeline>
<codeline><highlight class="normal">extern<sp/>arma::mat<sp/>data;</highlight></codeline>
<codeline><highlight class="normal">//<sp/>The<sp/>size<sp/>of<sp/>the<sp/>neighborhood<sp/>to<sp/>use<sp/>to<sp/>get<sp/>recommendations.</highlight></codeline>
<codeline><highlight class="normal">extern<sp/>size_t<sp/>neighborhood;</highlight></codeline>
<codeline><highlight class="normal">//<sp/>The<sp/>rank<sp/>of<sp/>the<sp/>decomposition.</highlight></codeline>
<codeline><highlight class="normal">extern<sp/>size_t<sp/>rank;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Build<sp/>the<sp/>CF<sp/>object<sp/>and<sp/>perform<sp/>the<sp/>decomposition.</highlight></codeline>
<codeline><highlight class="normal">//<sp/>The<sp/>constructor<sp/>takes<sp/>a<sp/>default-constructed<sp/>factorizer,<sp/>which,<sp/>by<sp/>default,</highlight></codeline>
<codeline><highlight class="normal">//<sp/>is<sp/>of<sp/>type<sp/>amf::NMFALSFactorizer.</highlight></codeline>
<codeline><highlight class="normal">CF<sp/>cf(data,<sp/>amf::NMFALSFactorizer(),<sp/>neighborhood,<sp/>rank);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">const<sp/>double<sp/>prediction<sp/>=<sp/>cf.Predict(12,<sp/>50);<sp/>//<sp/>User<sp/>12,<sp/>item<sp/>50.</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="cftutorial_1ex4_cf_cpp">
<title>Other operations with the W and H matrices</title>
<para>Sometimes, the raw decomposed W and H matrices can be useful. The example below obtains these matrices, and multiplies them against each other to obtain a reconstructed data matrix with no missing values.</para>
<para><programlisting><codeline><highlight class="normal">#include<sp/>&lt;mlpack/methods/cf/cf.hpp&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">using<sp/>namespace<sp/>mlpack::cf;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>The<sp/>coordinate<sp/>list<sp/>of<sp/>ratings<sp/>that<sp/>we<sp/>have.</highlight></codeline>
<codeline><highlight class="normal">extern<sp/>arma::mat<sp/>data;</highlight></codeline>
<codeline><highlight class="normal">//<sp/>The<sp/>size<sp/>of<sp/>the<sp/>neighborhood<sp/>to<sp/>use<sp/>to<sp/>get<sp/>recommendations.</highlight></codeline>
<codeline><highlight class="normal">extern<sp/>size_t<sp/>neighborhood;</highlight></codeline>
<codeline><highlight class="normal">//<sp/>The<sp/>rank<sp/>of<sp/>the<sp/>decomposition.</highlight></codeline>
<codeline><highlight class="normal">extern<sp/>size_t<sp/>rank;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Build<sp/>the<sp/>CF<sp/>object<sp/>and<sp/>perform<sp/>the<sp/>decomposition.</highlight></codeline>
<codeline><highlight class="normal">//<sp/>The<sp/>constructor<sp/>takes<sp/>a<sp/>default-constructed<sp/>factorizer,<sp/>which,<sp/>by<sp/>default,</highlight></codeline>
<codeline><highlight class="normal">//<sp/>is<sp/>of<sp/>type<sp/>amf::NMFALSFactorizer.</highlight></codeline>
<codeline><highlight class="normal">CF<sp/>cf(data,<sp/>amf::NMFALSFactorizer(),<sp/>neighborhood,<sp/>rank);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>References<sp/>to<sp/>W<sp/>and<sp/>H<sp/>matrices.</highlight></codeline>
<codeline><highlight class="normal">const<sp/>arma::mat&amp;<sp/>W<sp/>=<sp/>cf.W();</highlight></codeline>
<codeline><highlight class="normal">const<sp/>arma::mat&amp;<sp/>H<sp/>=<sp/>cf.H();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Multiply<sp/>the<sp/>matrices<sp/>together.</highlight></codeline>
<codeline><highlight class="normal">arma::mat<sp/>reconstructed<sp/>=<sp/>W<sp/>*<sp/>H;</highlight></codeline>
</programlisting></para>
</sect2>
</sect1>
<sect1 id="cftutorial_1cpp_cftut">
<title>Template parameters for the &apos;CF&apos; class</title>
<para>The <computeroutput>CF</computeroutput> class takes the <computeroutput>FactorizerType</computeroutput> as a template parameter to some of its constructors and to the <computeroutput>Train()</computeroutput> function. The <computeroutput>FactorizerType</computeroutput> class defines the algorithm used for matrix factorization. There are a number of existing factorizers that can be used in <bold>mlpack</bold>; these were detailed in the <ref refid="cftutorial_1ex2_cf_cpp" kindref="member">&apos;other factorizers&apos; example</ref> of the previous section.</para>
<para>The <computeroutput>FactorizerType</computeroutput> class must implement one of the two following methods:</para>
<para><itemizedlist>
<listitem><para><computeroutput>Apply(arma::mat&amp; data, const size_t rank, arma::mat&amp; W, arma::mat&amp; H);</computeroutput></para>
</listitem><listitem><para><computeroutput>Apply(arma::sp_mat&amp; data, const size_t rank, arma::mat&amp; W, arma::mat&amp; H);</computeroutput></para>
</listitem></itemizedlist>
</para>
<para>The difference between these two methods is whether <computeroutput>arma::mat</computeroutput> or <computeroutput>arma::sp_mat</computeroutput> is used as input. If <computeroutput>arma::mat</computeroutput> is used, then the data matrix is a coordinate list with three columns, as in the constructor to the <computeroutput>CF</computeroutput> class. If <computeroutput>arma::sp_mat</computeroutput> is used, then a sparse matrix is passed with the number of rows equal to the number of items and the number of columns equal to the number of users, and each nonzero element in the matrix corresponds to a non-missing rating.</para>
<para>The method that the factorizer implements is specified via the <computeroutput>FactorizerTraits</computeroutput> class, which is a template metaprogramming traits class:</para>
<para><programlisting><codeline><highlight class="normal">template&lt;typename<sp/>FactorizerType&gt;</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>FactorizerTraits</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>/**</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>If<sp/>true,<sp/>then<sp/>the<sp/>passed<sp/>data<sp/>matrix<sp/>is<sp/>used<sp/>for<sp/>factorizer.Apply().</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*<sp/>Otherwise,<sp/>it<sp/>is<sp/>modified<sp/>into<sp/>a<sp/>form<sp/>suitable<sp/>for<sp/>factorization.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static<sp/>const<sp/>bool<sp/>UsesCoordinateList<sp/>=<sp/>false;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para>
<para>If <computeroutput>FactorizerTraits&lt;MyFactorizer&gt;::UsesCoordinateList</computeroutput> is <computeroutput>true</computeroutput>, then <computeroutput>CF</computeroutput> will try to call <computeroutput>Apply()</computeroutput> with an <computeroutput>arma::mat</computeroutput> object. Otherwise, <computeroutput>CF</computeroutput> will try to call <computeroutput>Apply()</computeroutput> with an <computeroutput>arma::sp_mat</computeroutput> object. Specifying the value of <computeroutput>UsesCoordinateList</computeroutput> is straightforward; provide this specialization of the <computeroutput>FactorizerTraits</computeroutput> class:</para>
<para><programlisting><codeline><highlight class="normal">template&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>FactorizerTraits&lt;MyFactorizer&gt;</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>static<sp/>const<sp/>bool<sp/>UsesCoordinateList<sp/>=<sp/>true;<sp/>//<sp/>Set<sp/>your<sp/>value<sp/>here.</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para>
<para>The <computeroutput>Apply()</computeroutput> function also takes a reference to the matrices <computeroutput>W</computeroutput> and <computeroutput>H</computeroutput>. When the <computeroutput>Apply()</computeroutput> function returns, the input data matrix should be decomposed into these two matrices. <computeroutput>W</computeroutput> should have number of rows equal to the number of items and number of columns equal to the <computeroutput>rank</computeroutput> parameter, and <computeroutput>H</computeroutput> should have number of rows equal to the <computeroutput>rank</computeroutput> parameter, and number of columns equal to the number of users.</para>
<para>The <ref refid="classmlpack_1_1amf_1_1AMF" kindref="compound">amf::AMF&lt;&gt; class</ref> can be used as a base for factorizers that alternate between updating <computeroutput>W</computeroutput> and updating <computeroutput>H</computeroutput>. A useful reference is the <ref refid="amftutorial" kindref="compound">AMF tutorial</ref>.</para>
</sect1>
<sect1 id="cftutorial_1further_doc_cftut">
<title>Further documentation</title>
<para>Further documentation for the <computeroutput>CF</computeroutput> class may be found in the <ref refid="namespacemlpack_1_1cf" kindref="compound">complete API documentation</ref>. In addition, more information on the <computeroutput>AMF</computeroutput> class of factorizers may be found in its <ref refid="classmlpack_1_1amf_1_1AMF" kindref="compound">complete API documentation</ref>. </para>
</sect1>
    </detaileddescription>
    <location file="/home/aakash/mlpack/doc/tutorials/cf/cf.txt"/>
  </compounddef>
</doxygen>
