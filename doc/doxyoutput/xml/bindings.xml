<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="bindings" kind="page">
    <compoundname>bindings</compoundname>
    <title>mlpack automatic bindings to other languages</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<sect1 id="bindings_1bindings_overview">
<title>Overview</title>
<para>mlpack has a system to automatically generate bindings to other languages, such as Python and command-line programs, and it is extensible to other languages with some amount of ease. The maintenance burden of this system is low, and it is designed in such a way that the bindings produced are always up to date across languages and up to date with the mlpack library itself.</para>
<para>This document describes the full functioning of the system, and is a good place to start for someone who wishes to understand the system so that they can contribute a new binding language, or someone who wants to understand so they can adapt the system for use in their own project, or someone who is simply curious enough to see how the sausage is made.</para>
<para>The document is split into several sections:</para>
<para><itemizedlist>
<listitem><para><ref refid="bindings_1bindings_intro" kindref="member">Introduction</ref></para>
</listitem><listitem><para><ref refid="bindings_1bindings_code" kindref="member">Writing code that can be turned into a binding</ref></para>
</listitem><listitem><para><ref refid="bindings_1bindings_general" kindref="member">How to write mlpack bindings</ref><itemizedlist>
<listitem><para><ref refid="bindings_1bindings_general_program_doc" kindref="member">Documenting a program with</ref></para>
</listitem><listitem><para><ref refid="bindings_1bindings_general_define_params" kindref="member">Defining parameters for a program</ref></para>
</listitem><listitem><para><ref refid="bindings_1bindings_general_functions" kindref="member">Using IO in an mlpackMain() function</ref></para>
</listitem><listitem><para><ref refid="bindings_1bindings_general_more" kindref="member">More documentation on using IO</ref></para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para><ref refid="bindings_1bindings_structure" kindref="member">Structure of IO module and associated macros</ref></para>
</listitem><listitem><para><ref refid="bindings_1bindings_cli" kindref="member">Command-line program bindings</ref><itemizedlist>
<listitem><para><ref refid="bindings_1bindings_cli_mlpack_main" kindref="member">mlpackMain() definition</ref></para>
</listitem><listitem><para><ref refid="bindings_1bindings_cli_matrix" kindref="member">Matrix and model parameter handling</ref></para>
</listitem><listitem><para><ref refid="bindings_1bindings_cli_parsing" kindref="member">Parsing the command line</ref></para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para><ref refid="bindings_1bindings_python" kindref="member">Python bindings</ref><itemizedlist>
<listitem><para><ref refid="bindings_1bindings_python_matrix" kindref="member">Passing matrices to/from Python</ref></para>
</listitem><listitem><para><ref refid="bindings_1bindings_python_model" kindref="member">Passing model parameter to/from Python</ref></para>
</listitem><listitem><para><ref refid="bindings_1bindings_python_setup_py" kindref="member">CMake generation of setup.py</ref></para>
</listitem><listitem><para><ref refid="bindings_1bindings_python_build_pyx" kindref="member">Building the .pyx files</ref></para>
</listitem><listitem><para><ref refid="bindings_1bindings_python_testing" kindref="member">Testing the Python bindings</ref></para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para><ref refid="bindings_1bindings_new" kindref="member">Adding new binding types</ref></para>
</listitem></itemizedlist>
</para>
</sect1>
<sect1 id="bindings_1bindings_intro">
<title>Introduction</title>
<para>C++ is not the most popular language on the planet, and it (unfortunately) can scare many away with its ultra-verbose error messages, confusing template rules, and complex metaprogramming techniques. Most practitioners of machine learning tend to avoid writing native C++ and instead prefer other languages<mdash/>probably most notably Python.</para>
<para>In the case of Python, many projects will use tools like SWIG (<ulink url="http://www.swig.org/">http://www.swig.org/</ulink>) to automatically generate bindings, or they might hand-write Cython. The same types of strategies may be used for other languages; hand-written MEX files may be used for MATLAB, hand-written RCpp bindings might be used for R bindings, and so forth.</para>
<para>However, these approaches have a fundamental flaw: the hand-written bindings must be maintained, and risk going out of date as the rest of the library changes or new functionality is added. This incurs a maintenance burden: each major change to the library means that someone must update the bindings and test that they are still working. mlpack is not prepared to handle this maintenance workload; therefore an alternate solution is needed.</para>
<para>At the time of the design of this system, mlpack shipped headers for a C++ library as well as many (~40) hand-written command-line programs that used the <ref refid="classmlpack_1_1IO" kindref="compound">mlpack::IO</ref> object to manage command-line arguments. These programs all had similar structure, and could be logically split into three sections:</para>
<para><itemizedlist>
<listitem><para>parse the input options supplied by the user</para>
</listitem><listitem><para>run the machine learning algorithm</para>
</listitem><listitem><para>prepare the output to return to the user</para>
</listitem></itemizedlist>
</para>
<para>The user might interface with this command-line program like the following:</para>
<para><programlisting><codeline><highlight class="normal">$<sp/>mlpack_knn<sp/>-r<sp/>reference.csv<sp/>-q<sp/>query.csv<sp/>-k<sp/>3<sp/>-d<sp/>d.csv<sp/>-n<sp/>n.csv</highlight></codeline>
</programlisting></para>
<para>That is, they would pass a number of input options<mdash/>some were numeric values (like <computeroutput>-k</computeroutput> <computeroutput>3</computeroutput> ); some were filenames (like <computeroutput>-r</computeroutput> <computeroutput>reference.csv</computeroutput> ); and a few other types also. Therefore, the first stage of the program<mdash/>parsing input options<mdash/>would be handled by reading the command line and loading any input matrices. Preparing the output, which usually consists of data matrices (i.e. <computeroutput>-d</computeroutput> <computeroutput>d.csv</computeroutput> ) involves saving the matrix returned by the algorithm to the user&apos;s desired file.</para>
<para>Ideally, any binding to any language would have this same structure, and the actual &quot;run the machine learning algorithm&quot; code could be identical. For MATLAB, for instance, we would not need to read the file <computeroutput>reference.csv</computeroutput> but instead the user would simply pass their data matrix as an argument. So each input and output parameter would need to be handled differently, but the algorithm could be run identically across all bindings.</para>
<para>Therefore, design of an automatically-generated binding system would simply involve generating the boilerplate code necessary to parse input options for a given language, and to return output options to a user.</para>
</sect1>
<sect1 id="bindings_1bindings_code">
<title>Writing code that can be turned into a binding</title>
<para>This section details what a binding file might actually look like. It is good to have this API in mind when reading the following sections.</para>
<para>Each mlpack binding is typically contained in the <computeroutput>src/mlpack/methods/</computeroutput> folder corresponding to a given machine learning algorithm, with the suffix <computeroutput>_main.cpp</computeroutput> ; so an example is <computeroutput>src/mlpack/methods/pca/pca_main.cpp</computeroutput> .</para>
<para>These files have roughly two parts:</para>
<para><itemizedlist>
<listitem><para>definition of the input and output parameters with <computeroutput>PARAM</computeroutput> macros</para>
</listitem><listitem><para>implementation of <computeroutput>mlpackMain()</computeroutput>, which is the actual machine learning code</para>
</listitem></itemizedlist>
</para>
<para>Here is a simple example file:</para>
<para><programlisting><codeline><highlight class="normal">//<sp/>This<sp/>is<sp/>a<sp/>stripped<sp/>version<sp/>of<sp/>mean_shift_main.cpp.</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;mlpack/prereqs.hpp&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;mlpack/core/util/cli.hpp&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;mlpack/core/util/mlpack_main.hpp&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;mlpack/core/kernels/gaussian_kernel.hpp&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&quot;mean_shift.hpp&quot;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">using<sp/>namespace<sp/>mlpack;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>namespace<sp/>mlpack::meanshift;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>namespace<sp/>mlpack::kernel;</highlight></codeline>
<codeline><highlight class="normal">using<sp/>namespace<sp/>std;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Define<sp/>the<sp/>help<sp/>text<sp/>for<sp/>the<sp/>program.<sp/><sp/>The<sp/>PRINT_PARAM_STRING()<sp/>and</highlight></codeline>
<codeline><highlight class="normal">//<sp/>PRINT_DATASET()<sp/>macros<sp/>are<sp/>used<sp/>to<sp/>print<sp/>the<sp/>name<sp/>of<sp/>the<sp/>parameter<sp/>as<sp/>seen<sp/>in</highlight></codeline>
<codeline><highlight class="normal">//<sp/>the<sp/>binding<sp/>type<sp/>that<sp/>is<sp/>being<sp/>used,<sp/>and<sp/>the<sp/>PRINT_CALL()<sp/>macro<sp/>generates<sp/>a</highlight></codeline>
<codeline><highlight class="normal">//<sp/>sample<sp/>invocation<sp/>of<sp/>the<sp/>program<sp/>in<sp/>the<sp/>language<sp/>of<sp/>the<sp/>binding<sp/>type<sp/>that<sp/>is</highlight></codeline>
<codeline><highlight class="normal">//<sp/>being<sp/>used.<sp/><sp/>Note<sp/>that<sp/>the<sp/>macros<sp/>must<sp/>have<sp/>+<sp/>on<sp/>either<sp/>side<sp/>of<sp/>them.<sp/><sp/>We</highlight></codeline>
<codeline><highlight class="normal">//<sp/>provide<sp/>some<sp/>extra<sp/>references<sp/>with<sp/>the<sp/>&quot;SEE_ALSO()&quot;<sp/>macro,<sp/>which<sp/>is<sp/>used<sp/>to</highlight></codeline>
<codeline><highlight class="normal">//<sp/>generate<sp/>documentation<sp/>for<sp/>the<sp/>website.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Program<sp/>Name.</highlight></codeline>
<codeline><highlight class="normal">BINDING_NAME(&quot;Mean<sp/>Shift<sp/>Clustering&quot;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Short<sp/>description.</highlight></codeline>
<codeline><highlight class="normal">BINDING_SHORT_DESC(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&quot;A<sp/>fast<sp/>implementation<sp/>of<sp/>mean-shift<sp/>clustering<sp/>using<sp/>dual-tree<sp/>range<sp/>&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&quot;search.<sp/><sp/>Given<sp/>a<sp/>dataset,<sp/>this<sp/>uses<sp/>the<sp/>mean<sp/>shift<sp/>algorithm<sp/>to<sp/>produce<sp/>&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&quot;and<sp/>return<sp/>a<sp/>clustering<sp/>of<sp/>the<sp/>data.&quot;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Long<sp/>description.</highlight></codeline>
<codeline><highlight class="normal">BINDING_LONG_DESC(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&quot;This<sp/>program<sp/>performs<sp/>mean<sp/>shift<sp/>clustering<sp/>on<sp/>the<sp/>given<sp/>dataset,<sp/>storing<sp/>&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&quot;the<sp/>learned<sp/>cluster<sp/>assignments<sp/>either<sp/>as<sp/>a<sp/>column<sp/>of<sp/>labels<sp/>in<sp/>the<sp/>input<sp/>&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&quot;dataset<sp/>or<sp/>separately.&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&quot;\n\n&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&quot;The<sp/>input<sp/>dataset<sp/>should<sp/>be<sp/>specified<sp/>with<sp/>the<sp/>&quot;<sp/>+</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>PRINT_PARAM_STRING(&quot;input&quot;)<sp/>+<sp/>&quot;<sp/>parameter,<sp/>and<sp/>the<sp/>radius<sp/>used<sp/>for<sp/>search&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&quot;<sp/>can<sp/>be<sp/>specified<sp/>with<sp/>the<sp/>&quot;<sp/>+<sp/>PRINT_PARAM_STRING(&quot;radius&quot;)<sp/>+<sp/>&quot;<sp/>&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&quot;parameter.<sp/><sp/>The<sp/>maximum<sp/>number<sp/>of<sp/>iterations<sp/>before<sp/>algorithm<sp/>termination<sp/>&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&quot;is<sp/>controlled<sp/>with<sp/>the<sp/>&quot;<sp/>+<sp/>PRINT_PARAM_STRING(&quot;max_iterations&quot;)<sp/>+<sp/>&quot;<sp/>&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&quot;parameter.&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&quot;\n\n&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&quot;The<sp/>output<sp/>labels<sp/>may<sp/>be<sp/>saved<sp/>with<sp/>the<sp/>&quot;<sp/>+<sp/>PRINT_PARAM_STRING(&quot;output&quot;)<sp/>+</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&quot;<sp/>output<sp/>parameter<sp/>and<sp/>the<sp/>centroids<sp/>of<sp/>each<sp/>cluster<sp/>may<sp/>be<sp/>saved<sp/>with<sp/>the&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&quot;<sp/>&quot;<sp/>+<sp/>PRINT_PARAM_STRING(&quot;centroid&quot;)<sp/>+<sp/>&quot;<sp/>output<sp/>parameter.&quot;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Example.</highlight></codeline>
<codeline><highlight class="normal">BINDING_EXAMPLE(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&quot;For<sp/>example,<sp/>to<sp/>run<sp/>mean<sp/>shift<sp/>clustering<sp/>on<sp/>the<sp/>dataset<sp/>&quot;<sp/>+</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>PRINT_DATASET(&quot;data&quot;)<sp/>+<sp/>&quot;<sp/>and<sp/>store<sp/>the<sp/>centroids<sp/>to<sp/>&quot;<sp/>+</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>PRINT_DATASET(&quot;centroids&quot;)<sp/>+<sp/>&quot;,<sp/>the<sp/>following<sp/>command<sp/>may<sp/>be<sp/>used:<sp/>&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&quot;\n\n&quot;<sp/>+</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>PRINT_CALL(&quot;mean_shift&quot;,<sp/>&quot;input&quot;,<sp/>&quot;data&quot;,<sp/>&quot;centroid&quot;,<sp/>&quot;centroids&quot;));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>See<sp/>also...</highlight></codeline>
<codeline><highlight class="normal">BINDING_SEE_ALSO(&quot;@kmeans&quot;,<sp/>&quot;#kmeans&quot;);</highlight></codeline>
<codeline><highlight class="normal">BINDING_SEE_ALSO(&quot;@dbscan&quot;,<sp/>&quot;#dbscan&quot;);</highlight></codeline>
<codeline><highlight class="normal">BINDING_SEE_ALSO(&quot;Mean<sp/>shift<sp/>on<sp/>Wikipedia&quot;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;https://en.wikipedia.org/wiki/Mean_shift&quot;);</highlight></codeline>
<codeline><highlight class="normal">BINDING_SEE_ALSO(&quot;Mean<sp/>Shift,<sp/>Mode<sp/>Seeking,<sp/>and<sp/>Clustering<sp/>(pdf)&quot;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.510.1222&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;&amp;rep=rep1&amp;type=pdf&quot;);</highlight></codeline>
<codeline><highlight class="normal">BINDING_SEE_ALSO(&quot;mlpack::mean_shift::MeanShift<sp/>C++<sp/>class<sp/>documentation&quot;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;@doxygen/classmlpack_1_1meanshift_1_1MeanShift.html&quot;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Define<sp/>parameters<sp/>for<sp/>the<sp/>executable.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Required<sp/>option:<sp/>the<sp/>user<sp/>must<sp/>give<sp/>us<sp/>a<sp/>matrix.</highlight></codeline>
<codeline><highlight class="normal">PARAM_MATRIX_IN_REQ(&quot;input&quot;,<sp/>&quot;Input<sp/>dataset<sp/>to<sp/>perform<sp/>clustering<sp/>on.&quot;,<sp/>&quot;i&quot;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Output<sp/>options:<sp/>the<sp/>user<sp/>can<sp/>save<sp/>the<sp/>output<sp/>matrix<sp/>of<sp/>labels<sp/>and/or<sp/>the</highlight></codeline>
<codeline><highlight class="normal">//<sp/>centroids.</highlight></codeline>
<codeline><highlight class="normal">PARAM_UCOL_OUT(&quot;output&quot;,<sp/>&quot;Matrix<sp/>to<sp/>write<sp/>output<sp/>labels<sp/>to.&quot;,<sp/>&quot;o&quot;);</highlight></codeline>
<codeline><highlight class="normal">PARAM_MATRIX_OUT(&quot;centroid&quot;,<sp/>&quot;If<sp/>specified,<sp/>the<sp/>centroids<sp/>of<sp/>each<sp/>cluster<sp/>will<sp/>&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&quot;be<sp/>written<sp/>to<sp/>the<sp/>given<sp/>matrix.&quot;,<sp/>&quot;C&quot;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>Mean<sp/>shift<sp/>configuration<sp/>options.</highlight></codeline>
<codeline><highlight class="normal">PARAM_INT_IN(&quot;max_iterations&quot;,<sp/>&quot;Maximum<sp/>number<sp/>of<sp/>iterations<sp/>before<sp/>mean<sp/>shift<sp/>&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&quot;terminates.&quot;,<sp/>&quot;m&quot;,<sp/>1000);</highlight></codeline>
<codeline><highlight class="normal">PARAM_DOUBLE_IN(&quot;radius&quot;,<sp/>&quot;If<sp/>the<sp/>distance<sp/>between<sp/>two<sp/>centroids<sp/>is<sp/>less<sp/>than<sp/>&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&quot;the<sp/>given<sp/>radius,<sp/>one<sp/>will<sp/>be<sp/>removed.<sp/><sp/>A<sp/>radius<sp/>of<sp/>0<sp/>or<sp/>less<sp/>means<sp/>an<sp/>&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&quot;estimate<sp/>will<sp/>be<sp/>calculated<sp/>and<sp/>used<sp/>for<sp/>the<sp/>radius.&quot;,<sp/>&quot;r&quot;,<sp/>0);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>mlpackMain()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Process<sp/>the<sp/>parameters<sp/>that<sp/>the<sp/>user<sp/>passed.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>double<sp/>radius<sp/>=<sp/>IO::GetParam&lt;double&gt;(&quot;radius&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>int<sp/>maxIterations<sp/>=<sp/>IO::GetParam&lt;int&gt;(&quot;max_iterations&quot;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(maxIterations<sp/>&lt;<sp/>0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Log::Fatal<sp/>&lt;&lt;<sp/>&quot;Invalid<sp/>value<sp/>for<sp/>maximum<sp/>iterations<sp/>(&quot;<sp/>&lt;&lt;<sp/>maxIterations<sp/>&lt;&lt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;)!<sp/>Must<sp/>be<sp/>greater<sp/>than<sp/>or<sp/>equal<sp/>to<sp/>0.&quot;<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Warn,<sp/>if<sp/>the<sp/>user<sp/>did<sp/>not<sp/>specify<sp/>that<sp/>they<sp/>wanted<sp/>any<sp/>output.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(!IO::HasParam(&quot;output&quot;)<sp/>&amp;&amp;<sp/>!IO::HasParam(&quot;centroid&quot;))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Log::Warn<sp/>&lt;&lt;<sp/>&quot;--output_file,<sp/>--in_place,<sp/>and<sp/>--centroid_file<sp/>are<sp/>not<sp/>set;<sp/>&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>&quot;no<sp/>results<sp/>will<sp/>be<sp/>saved.&quot;<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>arma::mat<sp/>dataset<sp/>=<sp/>std::move(IO::GetParam&lt;arma::mat&gt;(&quot;input&quot;));</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arma::mat<sp/>centroids;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arma::Col&lt;size_t&gt;<sp/>assignments;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Prepare<sp/>and<sp/>run<sp/>the<sp/>actual<sp/>algorithm.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MeanShift&lt;&gt;<sp/>meanShift(radius,<sp/>maxIterations);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>Timer::Start(&quot;clustering&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Log::Info<sp/>&lt;&lt;<sp/>&quot;Performing<sp/>mean<sp/>shift<sp/>clustering...&quot;<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>meanShift.Cluster(dataset,<sp/>assignments,<sp/>centroids);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Timer::Stop(&quot;clustering&quot;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>Log::Info<sp/>&lt;&lt;<sp/>&quot;Found<sp/>&quot;<sp/>&lt;&lt;<sp/>centroids.n_cols<sp/>&lt;&lt;<sp/>&quot;<sp/>centroids.&quot;<sp/>&lt;&lt;<sp/>endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(radius<sp/>&lt;=<sp/>0.0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Log::Info<sp/>&lt;&lt;<sp/>&quot;Estimated<sp/>radius<sp/>was<sp/>&quot;<sp/>&lt;&lt;<sp/>meanShift.Radius()<sp/>&lt;&lt;<sp/>&quot;.\n&quot;;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Should<sp/>we<sp/>give<sp/>the<sp/>user<sp/>the<sp/>output<sp/>matrix?</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(IO::HasParam(&quot;output&quot;))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>IO::GetParam&lt;arma::Col&lt;size_t&gt;&gt;(&quot;output&quot;)<sp/>=<sp/>std::move(assignments);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Should<sp/>we<sp/>give<sp/>the<sp/>user<sp/>the<sp/>centroid<sp/>matrix?</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(IO::HasParam(&quot;centroid&quot;))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>IO::GetParam&lt;arma::mat&gt;(&quot;centroid&quot;)<sp/>=<sp/>std::move(centroids);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>We can see that we have defined the basic program information in the <computeroutput><ref refid="param_8hpp_1a3610abda0a69dc19a08c50e713f615b7" kindref="member">BINDING_NAME()</ref></computeroutput>, <computeroutput><ref refid="param_8hpp_1a013f7f337d6139c7f6de3a4f0fa7b019" kindref="member">BINDING_SHORT_DESC()</ref></computeroutput>, <computeroutput><ref refid="param_8hpp_1a7f7cbd16d4fecab7136b5ca1cbcbb0a7" kindref="member">BINDING_LONG_DESC()</ref></computeroutput>, <computeroutput><ref refid="param_8hpp_1a9ffe1d6d254b3e50a5611f77ee381838" kindref="member">BINDING_EXAMPLE()</ref></computeroutput> and <computeroutput><ref refid="param_8hpp_1add4a79815b7f3972699cc414bfc9fe57" kindref="member">BINDING_SEE_ALSO()</ref></computeroutput> macros. This is, for instance, what is displayed to describe the binding if the user passed the <computeroutput>--help</computeroutput> option for a command-line program.</para>
<para>Then, we define five parameters, three input and two output, that define the data and options that the mean shift clustering will function on. These parameters are defined with the <computeroutput>PARAM</computeroutput> macros, of which there are many. The names of these macros specify the type, whether the parameter is required, and whether the parameter is input or output. Some examples:</para>
<para><itemizedlist>
<listitem><para><computeroutput><ref refid="param_8hpp_1a9514ae93b51ba592bc3299da8326bb80" kindref="member">PARAM_STRING_IN()</ref></computeroutput> <ndash/> a string-type input parameter</para>
</listitem><listitem><para><computeroutput><ref refid="param_8hpp_1a20f436f371a7613b532ae3a4c0416b30" kindref="member">PARAM_MATRIX_OUT()</ref></computeroutput> <ndash/> a matrix-type output parameter</para>
</listitem><listitem><para><computeroutput><ref refid="param_8hpp_1a1236858e19f2e8be7da663d4aecfac9f" kindref="member">PARAM_DOUBLE_IN_REQ()</ref></computeroutput> <ndash/> a required double-type input parameter</para>
</listitem><listitem><para><computeroutput><ref refid="param_8hpp_1a0db58e2b5c75754d200638093b9cc40f" kindref="member">PARAM_UMATRIX_IN()</ref></computeroutput> <ndash/> an unsigned matrix-type input parameter</para>
</listitem><listitem><para><computeroutput><ref refid="param_8hpp_1a663f71826f69f70d119b5f577d20721e" kindref="member">PARAM_MODEL_IN()</ref></computeroutput> <ndash/> a serializable model-type input parameter</para>
</listitem></itemizedlist>
</para>
<para>Note that each of these macros may have slightly different syntax. See the links above for further documentation.</para>
<para>In order to write a new binding, then, you simply must write <computeroutput><ref refid="param_8hpp_1a3610abda0a69dc19a08c50e713f615b7" kindref="member">BINDING_NAME()</ref></computeroutput>, <computeroutput><ref refid="param_8hpp_1a013f7f337d6139c7f6de3a4f0fa7b019" kindref="member">BINDING_SHORT_DESC()</ref></computeroutput>, <computeroutput><ref refid="param_8hpp_1a7f7cbd16d4fecab7136b5ca1cbcbb0a7" kindref="member">BINDING_LONG_DESC()</ref></computeroutput>, <computeroutput><ref refid="param_8hpp_1a9ffe1d6d254b3e50a5611f77ee381838" kindref="member">BINDING_EXAMPLE()</ref></computeroutput> and <computeroutput><ref refid="param_8hpp_1add4a79815b7f3972699cc414bfc9fe57" kindref="member">BINDING_SEE_ALSO()</ref></computeroutput> definitions of the program with some docuentation, define the input and output parameters as <computeroutput>PARAM</computeroutput> macros, and then write an <computeroutput>mlpackMain()</computeroutput> function that actually performs the functionality of the binding. Inside of <computeroutput>mlpackMain()</computeroutput>:</para>
<para><itemizedlist>
<listitem><para>All input parameters are accessible through <computeroutput>IO::GetParam&lt;type&gt;</computeroutput>(&quot;name&quot;).</para>
</listitem><listitem><para>All output parameters should be set by the end of the function with the <computeroutput>IO::GetParam&lt;type&gt;</computeroutput>(&quot;name&quot;) method.</para>
</listitem></itemizedlist>
</para>
<para>Then, assuming that your program is saved in the file <computeroutput>program_name_main.cpp</computeroutput>, generating bindings for other languages is a simple addition to the <computeroutput>CMakeLists.txt</computeroutput> file:</para>
<para><programlisting><codeline><highlight class="normal">add_cli_executable(program_name)</highlight></codeline>
<codeline><highlight class="normal">add_python_binding(program_name)</highlight></codeline>
<codeline><highlight class="normal">add_markdown_docs(program_name<sp/>&quot;cli;python&quot;<sp/>&quot;category&quot;)</highlight></codeline>
</programlisting></para>
<para>In this example, <computeroutput>add_markdown_docs()</computeroutput> will generate documentation that is typically used to build the website. The &quot;category&quot; parameter should be one of the categories in <computeroutput>src/mlpack/bindings/markdown/MarkdownCategories.cmake</computeroutput>.</para>
</sect1>
<sect1 id="bindings_1bindings_general">
<title>How to write mlpack bindings</title>
<para>This section describes the general structure of the <computeroutput>IO</computeroutput> code and how one might write a new binding for mlpack. After reading this section it should be relatively clear how one could use the <computeroutput>IO</computeroutput> functionality along with CMake to add a binding for a new mlpack machine learning method. If it is not clear, then the examples in the following sections should clarify.</para>
<sect2 id="bindings_1bindings_general_program_doc">
<title>Documenting a program with</title>
<para><computeroutput><ref refid="param_8hpp_1a3610abda0a69dc19a08c50e713f615b7" kindref="member">BINDING_NAME()</ref></computeroutput>, <computeroutput><ref refid="param_8hpp_1a013f7f337d6139c7f6de3a4f0fa7b019" kindref="member">BINDING_SHORT_DESC()</ref></computeroutput>, <computeroutput><ref refid="param_8hpp_1a7f7cbd16d4fecab7136b5ca1cbcbb0a7" kindref="member">BINDING_LONG_DESC()</ref></computeroutput>, <computeroutput><ref refid="param_8hpp_1a9ffe1d6d254b3e50a5611f77ee381838" kindref="member">BINDING_EXAMPLE()</ref></computeroutput> and <computeroutput><ref refid="param_8hpp_1add4a79815b7f3972699cc414bfc9fe57" kindref="member">BINDING_SEE_ALSO()</ref></computeroutput>.</para>
<para>Any mlpack program should be documented with the <computeroutput><ref refid="param_8hpp_1a3610abda0a69dc19a08c50e713f615b7" kindref="member">BINDING_NAME()</ref></computeroutput>, <computeroutput><ref refid="param_8hpp_1a013f7f337d6139c7f6de3a4f0fa7b019" kindref="member">BINDING_SHORT_DESC()</ref></computeroutput>, <computeroutput><ref refid="param_8hpp_1a7f7cbd16d4fecab7136b5ca1cbcbb0a7" kindref="member">BINDING_LONG_DESC()</ref></computeroutput> , <computeroutput><ref refid="param_8hpp_1a9ffe1d6d254b3e50a5611f77ee381838" kindref="member">BINDING_EXAMPLE()</ref></computeroutput> and <computeroutput><ref refid="param_8hpp_1add4a79815b7f3972699cc414bfc9fe57" kindref="member">BINDING_SEE_ALSO()</ref></computeroutput> macros, which is available from the <computeroutput>&lt;<ref refid="mlpack__main_8hpp" kindref="compound">mlpack/core/util/mlpack_main.hpp</ref>&gt;</computeroutput> header. The macros are of the form</para>
<para><programlisting><codeline><highlight class="normal">BINDING_NAME(&quot;program<sp/>name&quot;);</highlight></codeline>
<codeline><highlight class="normal">BINDING_SHORT_DESC(&quot;This<sp/>is<sp/>a<sp/>short,<sp/>two-sentence<sp/>description<sp/>of<sp/>what<sp/>the<sp/>program<sp/>does.&quot;);</highlight></codeline>
<codeline><highlight class="normal">BINDING_LONG_DESC(&quot;This<sp/>is<sp/>a<sp/>long<sp/>description<sp/>of<sp/>what<sp/>the<sp/>program<sp/>does.&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&quot;<sp/>It<sp/>might<sp/>be<sp/>many<sp/>lines<sp/>long<sp/>and<sp/>have<sp/>lots<sp/>of<sp/>details<sp/>about<sp/>different<sp/>options.&quot;);</highlight></codeline>
<codeline><highlight class="normal">BINDING_EXAMPLE(&quot;This<sp/>contains<sp/>one<sp/>example<sp/>for<sp/>this<sp/>particular<sp/>binding.\n&quot;<sp/>+</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>PROGRAM_CALL(...));</highlight></codeline>
<codeline><highlight class="normal">BINDING_EXAMPLE(&quot;This<sp/>contains<sp/>another<sp/>example<sp/>for<sp/>this<sp/>particular<sp/>binding.\n&quot;<sp/>+</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>PROGRAM_CALL(...));</highlight></codeline>
<codeline><highlight class="normal">//<sp/>There<sp/>could<sp/>be<sp/>many<sp/>of<sp/>these<sp/>&quot;see<sp/>alsos&quot;.</highlight></codeline>
<codeline><highlight class="normal">BINDING_SEE_ALSO(&quot;https://en.wikipedia.org/wiki/Machine_learning&quot;);</highlight></codeline>
</programlisting></para>
<para>The short documentation should be two sentences indicating what the program implements and does, and a quick overview of how it can be used and what it should be used for. When writing new short documentation, it is a good idea to take a look at the existing documentation to get an idea of the general format.</para>
<para>For the &quot;see also&quot; section, you can specify as many <computeroutput>SEE_ALSO()</computeroutput> calls as you see fit. These are links used at the &quot;see also&quot; section of the website documentation for each binding, and it&apos;s very important that relevant links are provided (also to other bindings). See the <computeroutput>SEE_ALSO()</computeroutput> documentation for more details.</para>
<para>Although it is possible to provide very short documentation, it is certainly better to provide a long description including</para>
<para><itemizedlist>
<listitem><para>what the program does</para>
</listitem><listitem><para>a basic overview of what input and output parameters the program has</para>
</listitem><listitem><para>at least one example invocation</para>
</listitem></itemizedlist>
</para>
<para>Examples are very important, and are probably what most users are going to immediately search for, instead of taking a long time to read and carefully consider all of the written documentation.</para>
<para>However, it is difficult to write language-agnostic documentation. For instance, in a command-line program, an output parameter &apos;--output_file&apos; would be specified on the command line as an input parameter, but in Python, the output parameter &apos;output&apos; would actually simply be returned from the call to the Python function. Therefore, we must be careful how our documentation refers to input and output parameters. The following general guidelines can help:</para>
<para><itemizedlist>
<listitem><para>Always refer to output parameters as &quot;output parameters&quot;, which is a fairly close term that can be interpreted to mean both &quot;return values&quot; for languages like Python and MATLAB and also &quot;arguments given on the command line&quot; for command line programs.</para>
</listitem><listitem><para>Use the provided <computeroutput>PRINT_PARAM_STRING()</computeroutput> macro to print the names of parameters. For instance, <computeroutput>PRINT_PARAM_STRING(&quot;shuffle&quot;)</computeroutput> will print <computeroutput>&apos;--shuffle&apos;</computeroutput> for a command line program and <computeroutput>&apos;shuffle&apos;</computeroutput> for a Python binding. The <computeroutput>PRINT_PARAM_STRING()</computeroutput> macro also takes into account the type of the parameter.</para>
</listitem><listitem><para>Use the provided <computeroutput>PRINT_DATASET()</computeroutput> and <computeroutput>PRINT_MODEL()</computeroutput> macro to introduce example datasets or models, which can be useful when introducing an example usage of the program. So you could write <computeroutput>&apos;&quot;to @c run @c with @c a
   @c dataset @c &quot;</computeroutput> <computeroutput>+</computeroutput> <computeroutput>PRINT_DATASET</computeroutput>(&quot;data&quot;) <computeroutput>+</computeroutput> <computeroutput>&quot;...&quot;&apos;</computeroutput>.</para>
</listitem><listitem><para>Use the provided <computeroutput>PRINT_CALL()</computeroutput> macro to print example invocations of the program. The first argument is the name of the program, and then the following arguments should be the name of a parameter followed by the value of that parameter.</para>
</listitem><listitem><para>Never mention files in the documentation<mdash/>files are only relevant to command-line programs. Similarly, avoid mentioning anything language-specific.</para>
</listitem><listitem><para>Remember that some languages give output through return values and some give output using other input parameters. So the right verbiage to use is, e.g., <computeroutput>&apos;the results may be saved using the PRINT_PARAM_STRING(&quot;output&quot;) parameter&apos;</computeroutput>, and <bold>not</bold> <computeroutput>&apos;the results are returned through the PRINT_PARAM_STRING(&quot;output&quot;) parameter&apos;</computeroutput>.</para>
</listitem></itemizedlist>
</para>
<para>Each of these macros (<computeroutput>PRINT_PARAM_STRING()</computeroutput>, <computeroutput>PRINT_DATASET()</computeroutput>, <computeroutput>PRINT_MODEL()</computeroutput>, and <computeroutput>PRINT_CALL()</computeroutput> ) provides different output depending on the language. Below are some example of documentation strings and their outputs for different languages. Note that the output might not be <emphasis>exactly</emphasis> as written or formatted here, but the general gist should be the same.</para>
<para><programlisting><codeline><highlight class="normal">Input<sp/>C++<sp/>(snippet):</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>&quot;The<sp/>parameter<sp/>&quot;<sp/>+<sp/>PRINT_PARAM_STRING(&quot;shuffle&quot;)<sp/>+<sp/>&quot;,<sp/>if<sp/>set,<sp/>will<sp/>shuffle<sp/>&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&quot;the<sp/>data<sp/>before<sp/>learning.&quot;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Command-line<sp/>program<sp/>output<sp/>(snippet):</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>The<sp/>parameter<sp/>&apos;--shuffle&apos;,<sp/>if<sp/>set,<sp/>will<sp/>shuffle<sp/>the<sp/>data<sp/>before<sp/>learning.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Python<sp/>binding<sp/>output<sp/>(snippet):</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>The<sp/>parameter<sp/>&apos;shuffle&apos;,<sp/>if<sp/>set,<sp/>will<sp/>shuffle<sp/>the<sp/>data<sp/>before<sp/>learning.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Julia<sp/>binding<sp/>output<sp/>(snippet):</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>The<sp/>parameter<sp/>`shuffle`,<sp/>if<sp/>set,<sp/>will<sp/>shuffle<sp/>the<sp/>data<sp/>before<sp/>learning.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Go<sp/>binding<sp/>output<sp/>(snippet):</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>The<sp/>parameter<sp/>&quot;Shuffle&quot;,<sp/>if<sp/>set,<sp/>will<sp/>shuffle<sp/>the<sp/>data<sp/>before<sp/>learning.</highlight></codeline>
</programlisting></para>
<para><programlisting><codeline><highlight class="normal">Input<sp/>C++<sp/>(snippet):</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>&quot;The<sp/>output<sp/>matrix<sp/>can<sp/>be<sp/>saved<sp/>with<sp/>the<sp/>&quot;<sp/>+<sp/>PRINT_PARAM_STRING(&quot;output&quot;)<sp/>+</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&quot;<sp/>output<sp/>parameter.&quot;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Command-line<sp/>program<sp/>output<sp/>(snippet):</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>The<sp/>output<sp/>matrix<sp/>can<sp/>be<sp/>saved<sp/>with<sp/>the<sp/>&apos;--output_file&apos;<sp/>output<sp/>parameter.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Python<sp/>binding<sp/>output<sp/>(snippet):</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>The<sp/>output<sp/>matrix<sp/>can<sp/>be<sp/>saved<sp/>with<sp/>the<sp/>&apos;output&apos;<sp/>output<sp/>parameter.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Julia<sp/>binding<sp/>output<sp/>(snippet):</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>The<sp/>output<sp/>matrix<sp/>can<sp/>be<sp/>saved<sp/>with<sp/>the<sp/>`output`<sp/>output<sp/>parameter.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Go<sp/>binding<sp/>output<sp/>(snippet):</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>The<sp/>output<sp/>matrix<sp/>can<sp/>be<sp/>saved<sp/>with<sp/>the<sp/>&quot;output&quot;<sp/>output<sp/>parameter.</highlight></codeline>
</programlisting></para>
<para><programlisting><codeline><highlight class="normal">Input<sp/>C++<sp/>(snippet):</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>&quot;For<sp/>example,<sp/>to<sp/>train<sp/>a<sp/>model<sp/>on<sp/>the<sp/>dataset<sp/>&quot;<sp/>+<sp/>PRINT_DATASET(&quot;x&quot;)<sp/>+<sp/>&quot;<sp/>and<sp/>&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&quot;save<sp/>the<sp/>output<sp/>model<sp/>to<sp/>&quot;<sp/>+<sp/>PRINT_MODEL(&quot;model&quot;)<sp/>+<sp/>&quot;,<sp/>the<sp/>following<sp/>command&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&quot;<sp/>can<sp/>be<sp/>used:&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&quot;\n\n&quot;<sp/>+</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>PRINT_CALL(&quot;program&quot;,<sp/>&quot;input&quot;,<sp/>&quot;x&quot;,<sp/>&quot;output_model&quot;,<sp/>&quot;model&quot;)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Command-line<sp/>program<sp/>output<sp/>(snippet):</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>For<sp/>example,<sp/>to<sp/>train<sp/>a<sp/>model<sp/>on<sp/>the<sp/>dataset<sp/>&apos;x.csv&apos;<sp/>and<sp/>save<sp/>the<sp/>output<sp/>model</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>to<sp/>&apos;model.bin&apos;,<sp/>the<sp/>following<sp/>command<sp/>can<sp/>be<sp/>used:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>$<sp/>program<sp/>--input_file<sp/>x.csv<sp/>--output_model_file<sp/>model.bin</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Python<sp/>binding<sp/>output<sp/>(snippet):</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>For<sp/>example,<sp/>to<sp/>train<sp/>a<sp/>model<sp/>on<sp/>the<sp/>dataset<sp/>&apos;x&apos;<sp/>and<sp/>save<sp/>the<sp/>output<sp/>model<sp/>to</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&apos;model&apos;,<sp/>the<sp/>following<sp/>command<sp/>can<sp/>be<sp/>used:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>&gt;&gt;&gt;<sp/>output<sp/>=<sp/>program(input=x)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&gt;&gt;&gt;<sp/>model<sp/>=<sp/>output[&apos;output_model&apos;]</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Julia<sp/>binding<sp/>output<sp/>(snippet):</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>For<sp/>example,<sp/>to<sp/>train<sp/>a<sp/>model<sp/>on<sp/>the<sp/>dataset<sp/>`x`<sp/>and<sp/>save<sp/>the<sp/>output<sp/>model<sp/>to</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>`model`,<sp/>the<sp/>following<sp/>command<sp/>can<sp/>be<sp/>used:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>julia&gt;<sp/>model<sp/>=<sp/>program(input=x)</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Go<sp/>binding<sp/>output<sp/>(snippet):</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>For<sp/>example,<sp/>to<sp/>train<sp/>a<sp/>model<sp/>on<sp/>the<sp/>dataset<sp/>&quot;x&quot;<sp/>and<sp/>save<sp/>the<sp/>output<sp/>model<sp/>to</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&quot;model&quot;,<sp/>the<sp/>following<sp/>command<sp/>can<sp/>be<sp/>used:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Initialize<sp/>optional<sp/>parameters<sp/>for<sp/>Program().</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>param<sp/>:=<sp/>mlpack.ProgramOptions()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>param.Input<sp/>=<sp/>x</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>model<sp/>:=<sp/>mlpack.Program(param)</highlight></codeline>
</programlisting></para>
<para><programlisting><codeline><highlight class="normal">Input<sp/>C++<sp/>(full<sp/>program,<sp/>&apos;random_numbers_main.cpp&apos;):</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Program<sp/>Name.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>BINDING_NAME(&quot;Random<sp/>Numbers&quot;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Short<sp/>description.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>BINDING_SHORT_DESC(&quot;An<sp/>implementation<sp/>of<sp/>Random<sp/>Numbers&quot;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Long<sp/>description.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>BINDING_LONG_DESC(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>&quot;This<sp/>program<sp/>generates<sp/>random<sp/>numbers<sp/>with<sp/>a<sp/>&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>&quot;variety<sp/>of<sp/>nonsensical<sp/>techniques<sp/>and<sp/>example<sp/>parameters.<sp/><sp/>The<sp/>input<sp/>&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>&quot;dataset,<sp/>which<sp/>will<sp/>be<sp/>ignored,<sp/>can<sp/>be<sp/>specified<sp/>with<sp/>the<sp/>&quot;<sp/>+</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>PRINT_PARAM_STRING(&quot;input&quot;)<sp/>+<sp/>&quot;<sp/>parameter.<sp/><sp/>If<sp/>you<sp/>would<sp/>like<sp/>to<sp/>subtract&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>&quot;<sp/>values<sp/>from<sp/>each<sp/>number,<sp/>specify<sp/>the<sp/>&quot;<sp/>+</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>PRINT_PARAM_STRING(&quot;subtract&quot;)<sp/>+<sp/>&quot;<sp/>parameter.<sp/><sp/>The<sp/>number<sp/>of<sp/>random<sp/>&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>&quot;numbers<sp/>to<sp/>generate<sp/>is<sp/>specified<sp/>with<sp/>the<sp/>&quot;<sp/>+</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>PRINT_PARAM_STRING(&quot;num_values&quot;)<sp/>+<sp/>&quot;<sp/>parameter.&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>&quot;\n\n&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>&quot;The<sp/>output<sp/>random<sp/>numbers<sp/>can<sp/>be<sp/>saved<sp/>with<sp/>the<sp/>&quot;<sp/>+</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>PRINT_PARAM_STRING(&quot;output&quot;)<sp/>+<sp/>&quot;<sp/>output<sp/>parameter.<sp/><sp/>In<sp/>addition,<sp/>a<sp/>&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>&quot;randomly<sp/>generated<sp/>linear<sp/>regression<sp/>model<sp/>can<sp/>be<sp/>saved<sp/>with<sp/>the<sp/>&quot;<sp/>+</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>PRINT_PARAM_STRING(&quot;output_model&quot;)<sp/>+<sp/>&quot;<sp/>output<sp/>parameter.&quot;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Example.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>BINDING_EXAMPLE(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>&quot;For<sp/>example,<sp/>to<sp/>generate<sp/>100<sp/>random<sp/>numbers<sp/>with<sp/>3<sp/>subtracted<sp/>from<sp/>them<sp/>&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>&quot;and<sp/>save<sp/>the<sp/>output<sp/>to<sp/>&quot;<sp/>+<sp/>PRINT_DATASET(&quot;rand&quot;)<sp/>+<sp/>&quot;<sp/>and<sp/>the<sp/>random<sp/>&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>&quot;model<sp/>to<sp/>&quot;<sp/>+<sp/>PRINT_MODEL(&quot;rand_lr&quot;)<sp/>+<sp/>&quot;,<sp/>use<sp/>the<sp/>following<sp/>&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>&quot;command:&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>&quot;\n\n&quot;<sp/>+</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>PRINT_CALL(&quot;random_numbers&quot;,<sp/>&quot;num_values&quot;,<sp/>100,<sp/>&quot;subtract&quot;,<sp/>3,<sp/>&quot;output&quot;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&quot;rand&quot;,<sp/>&quot;output_model&quot;,<sp/>&quot;rand_lr&quot;));</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Command<sp/>line<sp/>output:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Random<sp/>Numbers</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>This<sp/>program<sp/>generates<sp/>random<sp/>numbers<sp/>with<sp/>a<sp/>variety<sp/>of<sp/>nonsensical</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>techniques<sp/>and<sp/>example<sp/>parameters.<sp/><sp/>The<sp/>input<sp/>dataset,<sp/>which<sp/>will<sp/>be</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ignored,<sp/>can<sp/>be<sp/>specified<sp/>with<sp/>the<sp/>&apos;--input_file&apos;<sp/>parameter.<sp/><sp/>If<sp/>you<sp/>would</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>like<sp/>to<sp/>subtract<sp/>values<sp/>from<sp/>each<sp/>number,<sp/>specify<sp/>the<sp/>&apos;--subtract&apos;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>parameter.<sp/><sp/>The<sp/>number<sp/>of<sp/>random<sp/>numbers<sp/>to<sp/>generate<sp/>is<sp/>specified<sp/>with<sp/>the</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&apos;--num_values&apos;<sp/>parameter.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>The<sp/>output<sp/>random<sp/>numbers<sp/>can<sp/>be<sp/>saved<sp/>with<sp/>the<sp/>&apos;--output_file&apos;<sp/>output</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>parameter.<sp/><sp/>In<sp/>addition,<sp/>a<sp/>randomly<sp/>generated<sp/>linear<sp/>regression<sp/>model<sp/>can<sp/>be</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>saved<sp/>with<sp/>the<sp/>&apos;--output_model_file&apos;<sp/>output<sp/>parameter.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>For<sp/>example,<sp/>to<sp/>generate<sp/>100<sp/>random<sp/>numbers<sp/>with<sp/>3<sp/>subtracted<sp/>from<sp/>them<sp/>and</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>save<sp/>the<sp/>output<sp/>to<sp/>&apos;rand.csv&apos;<sp/>and<sp/>the<sp/>random<sp/>model<sp/>to<sp/>&apos;rand_lr.bin&apos;,<sp/>use<sp/>the</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>following<sp/>command:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>$<sp/>random_numbers<sp/>--num_values<sp/>100<sp/>--subtract<sp/>3<sp/>--output_file<sp/>rand.csv</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>--output_model_file<sp/>rand_lr.bin</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Python<sp/>binding<sp/>output:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Random<sp/>Numbers</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>This<sp/>program<sp/>generates<sp/>random<sp/>numbers<sp/>with<sp/>a<sp/>variety<sp/>of<sp/>nonsensical</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>techniques<sp/>and<sp/>example<sp/>parameters.<sp/><sp/>The<sp/>input<sp/>dataset,<sp/>which<sp/>will<sp/>be</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ignored,<sp/>can<sp/>be<sp/>specified<sp/>with<sp/>the<sp/>&apos;input&apos;<sp/>parameter.<sp/><sp/>If<sp/>you<sp/>would<sp/>like<sp/>to</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>subtract<sp/>values<sp/>from<sp/>each<sp/>number,<sp/>specify<sp/>the<sp/>&apos;subtract&apos;<sp/>parameter.<sp/><sp/>The</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>number<sp/>of<sp/>random<sp/>numbers<sp/>to<sp/>generate<sp/>is<sp/>specified<sp/>with<sp/>the<sp/>&apos;num_values&apos;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>parameter.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>The<sp/>output<sp/>random<sp/>numbers<sp/>can<sp/>be<sp/>saved<sp/>with<sp/>the<sp/>&apos;output&apos;<sp/>output<sp/>parameter.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>In<sp/>addition,<sp/>a<sp/>randomly<sp/>generated<sp/>linear<sp/>regression<sp/>model<sp/>can<sp/>be<sp/>saved<sp/>with</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>the<sp/>&apos;output_model&apos;<sp/>output<sp/>parameter.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>For<sp/>example,<sp/>to<sp/>generate<sp/>100<sp/>random<sp/>numbers<sp/>with<sp/>3<sp/>subtracted<sp/>from<sp/>them<sp/>and</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>save<sp/>the<sp/>output<sp/>to<sp/>&apos;rand&apos;<sp/>and<sp/>the<sp/>random<sp/>model<sp/>to<sp/>&apos;rand_lr&apos;,<sp/>use<sp/>the</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>following<sp/>command:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&gt;&gt;&gt;<sp/>output<sp/>=<sp/>random_numbers(num_values=100,<sp/>subtract=3)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&gt;&gt;&gt;<sp/>rand<sp/>=<sp/>output[&apos;output&apos;]</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&gt;&gt;&gt;<sp/>rand_lr<sp/>=<sp/>output[&apos;output_model&apos;]</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Julia<sp/>binding<sp/>output:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Random<sp/>Numbers</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>This<sp/>program<sp/>generates<sp/>random<sp/>numbers<sp/>with<sp/>a<sp/>variety<sp/>of<sp/>nonsensical</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>techniques<sp/>and<sp/>example<sp/>parameters.<sp/><sp/>The<sp/>input<sp/>dataset,<sp/>which<sp/>will<sp/>be</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ignored,<sp/>can<sp/>be<sp/>specified<sp/>with<sp/>the<sp/>`input`<sp/>parameter.<sp/><sp/>If<sp/>you<sp/>would<sp/>like<sp/>to</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>subtract<sp/>values<sp/>from<sp/>each<sp/>number,<sp/>specify<sp/>the<sp/>`subtract`<sp/>parameter.<sp/><sp/>The</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>number<sp/>of<sp/>random<sp/>numbers<sp/>to<sp/>generate<sp/>is<sp/>specified<sp/>with<sp/>the<sp/>`num_values`</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>parameter.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>The<sp/>output<sp/>random<sp/>numbers<sp/>can<sp/>be<sp/>saved<sp/>with<sp/>the<sp/>`output`<sp/>output<sp/>parameter.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>In<sp/>addition,<sp/>a<sp/>randomly<sp/>generated<sp/>linear<sp/>regression<sp/>model<sp/>can<sp/>be<sp/>saved<sp/>with</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>the<sp/>`output_model`<sp/>output<sp/>parameter.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>For<sp/>example,<sp/>to<sp/>generate<sp/>100<sp/>random<sp/>numbers<sp/>with<sp/>3<sp/>subtracted<sp/>from<sp/>them<sp/>and</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>save<sp/>the<sp/>output<sp/>to<sp/>`rand`<sp/>and<sp/>the<sp/>random<sp/>model<sp/>to<sp/>`rand_lr`,<sp/>use<sp/>the</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>following<sp/>command:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>```julia</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>julia&gt;<sp/>rand,<sp/>rand_lr<sp/>=<sp/>random_numbers(num_values=100,<sp/>subtract=3)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>```</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">Go<sp/>binding<sp/>output:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Random<sp/>Numbers</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>This<sp/>program<sp/>generates<sp/>random<sp/>numbers<sp/>with<sp/>a<sp/>variety<sp/>of<sp/>nonsensical</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>techniques<sp/>and<sp/>example<sp/>parameters.<sp/><sp/>The<sp/>input<sp/>dataset,<sp/>which<sp/>will<sp/>be</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ignored,<sp/>can<sp/>be<sp/>specified<sp/>with<sp/>the<sp/>&quot;Input&quot;<sp/>parameter.<sp/><sp/>If<sp/>you<sp/>would<sp/>like<sp/>to</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>subtract<sp/>values<sp/>from<sp/>each<sp/>number,<sp/>specify<sp/>the<sp/>&quot;Subtract&quot;<sp/>parameter.<sp/><sp/>The</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>number<sp/>of<sp/>random<sp/>numbers<sp/>to<sp/>generate<sp/>is<sp/>specified<sp/>with<sp/>the<sp/>&quot;NumValues&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>parameter.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>The<sp/>output<sp/>random<sp/>numbers<sp/>can<sp/>be<sp/>saved<sp/>with<sp/>the<sp/>&quot;output&quot;<sp/>output<sp/>parameter.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>In<sp/>addition,<sp/>a<sp/>randomly<sp/>generated<sp/>linear<sp/>regression<sp/>model<sp/>can<sp/>be<sp/>saved<sp/>with</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>the<sp/>&quot;outputModel&quot;<sp/>output<sp/>parameter.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>For<sp/>example,<sp/>to<sp/>generate<sp/>100<sp/>random<sp/>numbers<sp/>with<sp/>3<sp/>subtracted<sp/>from<sp/>them<sp/>and</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>save<sp/>the<sp/>output<sp/>to<sp/>&quot;rand&quot;<sp/>and<sp/>the<sp/>random<sp/>model<sp/>to<sp/>&quot;randLr&quot;,<sp/>use<sp/>the</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>following<sp/>command:</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Initialize<sp/>optional<sp/>parameters<sp/>for<sp/>RandomNumbers().</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>param<sp/>:=<sp/>mlpack.RandomNumbersOptions()</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>param.NumValues<sp/>=<sp/>100</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>param.Subtract=3</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>rand,<sp/>randLr<sp/>:=<sp/>mlpack.RandomNumbers(param)</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="bindings_1bindings_general_define_params">
<title>Defining parameters for a program</title>
<para>There exist several macros that can be used after a <computeroutput><ref refid="param_8hpp_1a7f7cbd16d4fecab7136b5ca1cbcbb0a7" kindref="member">BINDING_LONG_DESC()</ref></computeroutput> and <computeroutput><ref refid="param_8hpp_1a9ffe1d6d254b3e50a5611f77ee381838" kindref="member">BINDING_EXAMPLE()</ref></computeroutput> definition to define the parameters that can be specified for a given mlpack program. These macros all have the same general definition: the name of the macro specifies the type of the parameter, whether or not the parameter is required, and whether the parameter is an input or output parameter. Then as arguments to the macros, the name, description, and sometimes the single-character alias and the default value of the parameter.</para>
<para>To give a flavor of how these definitions look, the definition</para>
<para><programlisting><codeline><highlight class="normal">PARAM_STRING_IN(&quot;algorithm&quot;,<sp/>&quot;The<sp/>algorithm<sp/>to<sp/>use:<sp/>&apos;svd&apos;<sp/>or<sp/>&apos;blah&apos;.&quot;,<sp/>&quot;a&quot;);</highlight></codeline>
</programlisting></para>
<para>will define a string input parameter <computeroutput>algorithm</computeroutput> (referenced as <computeroutput>&apos;--algorithm&apos;</computeroutput> from the command-line or <computeroutput>&apos;algorithm&apos;</computeroutput> from Python) with the description <computeroutput>The algorithm to use: &apos;svd&apos; or &apos;blah&apos;.</computeroutput> The single-character alias <computeroutput>&apos;-a&apos;</computeroutput> can be used from a command-line program (but means nothing in Python).</para>
<para>There are numerous different macros that can be used:</para>
<para><itemizedlist>
<listitem><para><computeroutput><ref refid="param_8hpp_1a59a38dfe16c56a278bd89817216a3739" kindref="member">PARAM_FLAG()</ref></computeroutput> - boolean flag parameter</para>
</listitem><listitem><para><computeroutput><ref refid="param_8hpp_1a627025f18abd2735345f03fd733ccd9b" kindref="member">PARAM_INT_IN()</ref></computeroutput> - integer input parameter</para>
</listitem><listitem><para><computeroutput><ref refid="param_8hpp_1a50b8bfabec3f0b64fb6e15837da50aa0" kindref="member">PARAM_INT_OUT()</ref></computeroutput> - integer output parameter</para>
</listitem><listitem><para><computeroutput><ref refid="param_8hpp_1a14e7059294c684b01128819daea241d4" kindref="member">PARAM_DOUBLE_IN()</ref></computeroutput> - double input parameter</para>
</listitem><listitem><para><computeroutput><ref refid="param_8hpp_1aa39a5fa65308f2d5581c01cfae5f9203" kindref="member">PARAM_DOUBLE_OUT()</ref></computeroutput> - double output parameter</para>
</listitem><listitem><para><computeroutput><ref refid="param_8hpp_1a9514ae93b51ba592bc3299da8326bb80" kindref="member">PARAM_STRING_IN()</ref></computeroutput> - string input parameter</para>
</listitem><listitem><para><computeroutput><ref refid="param_8hpp_1a94d8f8edc103da0e05f04fce245e8a93" kindref="member">PARAM_STRING_OUT()</ref></computeroutput> - string output parameter</para>
</listitem><listitem><para><computeroutput><ref refid="param_8hpp_1a49e6517671e6c8173dd3570de950363b" kindref="member">PARAM_MATRIX_IN()</ref></computeroutput> - double-valued matrix (<computeroutput>arma::mat</computeroutput>) input parameter</para>
</listitem><listitem><para><computeroutput><ref refid="param_8hpp_1a20f436f371a7613b532ae3a4c0416b30" kindref="member">PARAM_MATRIX_OUT()</ref></computeroutput> - double-valued matrix (<computeroutput>arma::mat</computeroutput>) output parameter</para>
</listitem><listitem><para><computeroutput><ref refid="param_8hpp_1a0db58e2b5c75754d200638093b9cc40f" kindref="member">PARAM_UMATRIX_IN()</ref></computeroutput> - size_t-valued matrix (<computeroutput>arma::Mat&lt;size_t&gt;</computeroutput>) input parameter</para>
</listitem><listitem><para><computeroutput><ref refid="param_8hpp_1a145abfa58262c15f01139092ececc571" kindref="member">PARAM_UMATRIX_OUT()</ref></computeroutput> - size_t-valued matrix (<computeroutput>arma::Mat&lt;size_t&gt;</computeroutput>) output parameter</para>
</listitem><listitem><para><computeroutput><ref refid="param_8hpp_1a237697d0b35e7e6484e8ce52c0ed00c9" kindref="member">PARAM_TMATRIX_IN()</ref></computeroutput> - transposed double-valued matrix (<computeroutput>arma::mat</computeroutput>) input parameter</para>
</listitem><listitem><para><computeroutput><ref refid="param_8hpp_1a76754d246b86d1b159270e4794c25019" kindref="member">PARAM_TMATRIX_OUT()</ref></computeroutput> - transposed double-valued matrix (<computeroutput>arma::mat</computeroutput>) output parameter</para>
</listitem><listitem><para><computeroutput><ref refid="param_8hpp_1a444c996b7e4b9dadaa5e43a7d7798f71" kindref="member">PARAM_MATRIX_AND_INFO_IN()</ref></computeroutput> - matrix with categoricals input parameter (<computeroutput>std::tuple&lt;data::DatasetInfo, arma::mat</computeroutput>)</para>
</listitem><listitem><para><computeroutput><ref refid="param_8hpp_1a36713e2f7157727157af4a92f1c2ad5d" kindref="member">PARAM_COL_IN()</ref></computeroutput> - double-valued column vector (<computeroutput>arma::vec</computeroutput>) input parameter</para>
</listitem><listitem><para><computeroutput><ref refid="param_8hpp_1a07120f558c6c681b2a27a719a7c39bd2" kindref="member">PARAM_COL_OUT()</ref></computeroutput> - double-valued column vector (<computeroutput>arma::vec</computeroutput>) output parameter</para>
</listitem><listitem><para><computeroutput><ref refid="param_8hpp_1a55c356a0f2cc3df7122b3f033033538e" kindref="member">PARAM_UCOL_IN()</ref></computeroutput> - size_t-valued column vector (<computeroutput>arma::Col&lt;size_t&gt;</computeroutput>) input parameter</para>
</listitem><listitem><para><computeroutput><ref refid="param_8hpp_1ac8b7f343ae79cb1ec43a0d2eb791090d" kindref="member">PARAM_UCOL_OUT()</ref></computeroutput> - size_t-valued column vector (<computeroutput>arma::Col&lt;size_t&gt;</computeroutput>) output parameter</para>
</listitem><listitem><para><computeroutput><ref refid="param_8hpp_1a503427b6b8cca3f0948487006e7f11b4" kindref="member">PARAM_ROW_IN()</ref></computeroutput> - double-valued row vector (<computeroutput>arma::rowvec</computeroutput>) input parameter</para>
</listitem><listitem><para><computeroutput><ref refid="param_8hpp_1a9beb54447b7992ecff903397abb60f73" kindref="member">PARAM_ROW_OUT()</ref></computeroutput> - double-valued row vector (<computeroutput>arma::rowvec</computeroutput>) output parameter</para>
</listitem><listitem><para><computeroutput><ref refid="param_8hpp_1a8431e7deab47987cfdb2ae3f242c72bc" kindref="member">PARAM_VECTOR_IN()</ref></computeroutput> - <computeroutput>std::vector</computeroutput> input parameter</para>
</listitem><listitem><para><computeroutput><ref refid="param_8hpp_1ac24919def62bd93f462cc3ff9d555cbc" kindref="member">PARAM_VECTOR_OUT()</ref></computeroutput> - <computeroutput>std::vector</computeroutput> output parameter</para>
</listitem><listitem><para><computeroutput><ref refid="param_8hpp_1a663f71826f69f70d119b5f577d20721e" kindref="member">PARAM_MODEL_IN()</ref></computeroutput> - serializable model input parameter</para>
</listitem><listitem><para><computeroutput><ref refid="param_8hpp_1a303372e5feffaee9bd0a4bb50f3011b1" kindref="member">PARAM_MODEL_OUT()</ref></computeroutput> - serializable model output parameter</para>
</listitem></itemizedlist>
</para>
<para>And for input parameters, the parameter may also be required:</para>
<para><itemizedlist>
<listitem><para><computeroutput><ref refid="param_8hpp_1a59102e55c5d69d23909a75bd6093f816" kindref="member">PARAM_INT_IN_REQ()</ref></computeroutput> </para>
</listitem><listitem><para><computeroutput><ref refid="param_8hpp_1a1236858e19f2e8be7da663d4aecfac9f" kindref="member">PARAM_DOUBLE_IN_REQ()</ref></computeroutput> </para>
</listitem><listitem><para><computeroutput><ref refid="param_8hpp_1a39f209691f1ca8c649a40cb22cea5408" kindref="member">PARAM_STRING_IN_REQ()</ref></computeroutput> </para>
</listitem><listitem><para><computeroutput><ref refid="param_8hpp_1a20dc72054c6568f040bdc8a5512acacb" kindref="member">PARAM_MATRIX_IN_REQ()</ref></computeroutput> </para>
</listitem><listitem><para><computeroutput><ref refid="param_8hpp_1aaf334355d68e6667f4e50e071eee4d63" kindref="member">PARAM_UMATRIX_IN_REQ()</ref></computeroutput> </para>
</listitem><listitem><para><computeroutput><ref refid="param_8hpp_1a580cb0e5b1c587a4bc5b7211aa2c414b" kindref="member">PARAM_TMATRIX_IN_REQ()</ref></computeroutput> </para>
</listitem><listitem><para><computeroutput><ref refid="param_8hpp_1a83c3be131e322e0a661c8ddf9c3c7df6" kindref="member">PARAM_VECTOR_IN_REQ()</ref></computeroutput> </para>
</listitem><listitem><para><computeroutput><ref refid="param_8hpp_1a42961ca5512a6e6ab58cdcd15e374fca" kindref="member">PARAM_MODEL_IN_REQ()</ref></computeroutput> </para>
</listitem></itemizedlist>
</para>
<para>Click the links for each macro to read further documentation. Note also that each possible combination of <computeroutput>IN</computeroutput>, <computeroutput>OUT</computeroutput>, and <computeroutput>REQ</computeroutput> is not available<mdash/>output options cannot be required, and some combinations simply have not been added because they have not been needed.</para>
<para>The <computeroutput><ref refid="param_8hpp_1a663f71826f69f70d119b5f577d20721e" kindref="member">PARAM_MODEL_IN()</ref></computeroutput> and <computeroutput><ref refid="param_8hpp_1a303372e5feffaee9bd0a4bb50f3011b1" kindref="member">PARAM_MODEL_OUT()</ref></computeroutput> macros are used to serialize mlpack models. These could be used, for instance, to allow the user to save a trained model (like a linear regression model) or load an input model. The first parameter to the <computeroutput><ref refid="param_8hpp_1a663f71826f69f70d119b5f577d20721e" kindref="member">PARAM_MODEL_IN()</ref></computeroutput> or <computeroutput><ref refid="param_8hpp_1a303372e5feffaee9bd0a4bb50f3011b1" kindref="member">PARAM_MODEL_OUT()</ref></computeroutput> macro should be the C++ type of the model to be serialized; this type <bold>must</bold> have a function <computeroutput>template&lt;typename Archive&gt; void serialize(Archive&amp;)</computeroutput> (i.e. the type must be serializable via cereal). For example, to allow a user to specify an input model of type <computeroutput>LinearRegression</computeroutput>, the follow definition could be used:</para>
<para><programlisting><codeline><highlight class="normal">PARAM_MODEL_IN(LinearRegression,<sp/>&quot;input_model&quot;,<sp/>&quot;The<sp/>input<sp/>model<sp/>to<sp/>be<sp/>used.&quot;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&quot;i&quot;);</highlight></codeline>
</programlisting></para>
<para>Then, the user will be able to specify their model from the command-line as <computeroutput>--input_model_file</computeroutput> and from Python using the <computeroutput>input_model</computeroutput> option to the generated binding.</para>
<para>From the command line, matrix-type and model-type options (both input and output) are loaded from or saved to the specified file. This means that <computeroutput>_file</computeroutput> is appended to the name of the parameter; so if the parameter name is <computeroutput>data</computeroutput> and it is of a matrix or model type, then the name that the user will specify on the command line will be <computeroutput>--data_file</computeroutput>. This displayed parameter name change <bold>only</bold> occurs with matrix and model type parameters for command-line programs.</para>
<para>The <computeroutput>PARAM_MATRIX_AND_INFO()</computeroutput> macro defines a categorical matrix parameter (more specifically, a matrix type that can support categorical columns). From the C++ program side, this means that the parameter type is <computeroutput>std::tuple&lt;data::DatasetInfo, arma::mat&gt;</computeroutput>. From the user side, for a command-line program, this means that the user will pass the filename of a dataset that can have categorical features, such as an ARFF dataset. For a Python program, the user may pass a Pandas matrix with categorical columns. When the program is run, the input that the user gives will be processed and the <computeroutput>data::DatasetInfo</computeroutput> object will be filled with the dimension types and the <computeroutput>arma::mat</computeroutput> object will be filled with the data itself.</para>
<para>To give some examples, the parameter definitions from the example &quot;random_numbers&quot; program in the previous section are shown below.</para>
<para><programlisting><codeline><highlight class="normal">PARAM_MATRIX_IN(&quot;input&quot;,<sp/>&quot;The<sp/>input<sp/>matrix<sp/>that<sp/>will<sp/>be<sp/>ignored.&quot;,<sp/>&quot;i&quot;);</highlight></codeline>
<codeline><highlight class="normal">PARAM_DOUBLE_IN(&quot;subtract&quot;,<sp/>&quot;The<sp/>value<sp/>to<sp/>subtract<sp/>from<sp/>each<sp/>parameter.&quot;,<sp/>&quot;s&quot;,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>0.0);<sp/>//<sp/>Default<sp/>value<sp/>of<sp/>0.0.</highlight></codeline>
<codeline><highlight class="normal">PARAM_INT_IN(&quot;num_samples&quot;,<sp/>&quot;The<sp/>number<sp/>of<sp/>samples<sp/>to<sp/>generate.&quot;,<sp/>&quot;n&quot;,<sp/>100);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">PARAM_MATRIX_OUT(&quot;output&quot;,<sp/>&quot;The<sp/>output<sp/>matrix<sp/>of<sp/>random<sp/>samples.&quot;,<sp/>&quot;o&quot;);</highlight></codeline>
<codeline><highlight class="normal">PARAM_MODEL_OUT(LinearRegression,<sp/>&quot;output_model&quot;,<sp/>&quot;The<sp/>randomly<sp/>generated<sp/>&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>&quot;linear<sp/>regression<sp/>output<sp/>model.&quot;,<sp/>&quot;M&quot;);</highlight></codeline>
</programlisting></para>
<para>Note that even the parameter documentation strings must be a little be agnostic to the binding type, because the command-line interface is so different than the Python interface to the user.</para>
</sect2>
<sect2 id="bindings_1bindings_general_functions">
<title>Using IO in an mlpackMain() function</title>
<para>mlpack&apos;s <computeroutput>IO</computeroutput> module provides a unified abstract interface for getting input from and providing output to users without needing to consider the language (command-line, Python, MATLAB, etc.) that the user is running the program from. This means that after the <computeroutput><ref refid="param_8hpp_1a7f7cbd16d4fecab7136b5ca1cbcbb0a7" kindref="member">BINDING_LONG_DESC()</ref></computeroutput> and <computeroutput><ref refid="param_8hpp_1a9ffe1d6d254b3e50a5611f77ee381838" kindref="member">BINDING_EXAMPLE()</ref></computeroutput> macros and the <computeroutput>PARAM_*</computeroutput>() macros have been defined, a language-agnostic <computeroutput>mlpackMain()</computeroutput> function can be written. This function then can perform the actual computation that the entire program is meant to.</para>
<para>Inside of an <computeroutput>mlpackMain()</computeroutput> function, the <computeroutput><ref refid="classmlpack_1_1IO" kindref="compound">mlpack::IO</ref></computeroutput> module can be used to access input parameters and set output parameters. There are two main functions for this, plus a utility printing function:</para>
<para><itemizedlist>
<listitem><para><computeroutput><ref refid="namespacemlpack_1_1bindings_1_1cli_1a9eee50cbae50b3464c59b88ab7b88e44" kindref="member">IO::GetParam&lt;T&gt;()</ref></computeroutput> - get a reference to a parameter</para>
</listitem><listitem><para><computeroutput>IO::HasParam()</computeroutput> - returns true if the user specified the parameter</para>
</listitem><listitem><para><computeroutput><ref refid="namespacemlpack_1_1bindings_1_1cli_1aaf7d940ea6f4c5984891552aad0a003a" kindref="member">IO::GetPrintableParam&lt;T&gt;()</ref></computeroutput> - returns a string representing the value of the parameter</para>
</listitem></itemizedlist>
</para>
<para>So, to print &quot;hello&quot; if the user specified the <computeroutput>print_hello</computeroutput> parameter, the following code could be used:</para>
<para><programlisting><codeline><highlight class="normal">using<sp/>namespace<sp/>mlpack;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">if<sp/>(IO::HasParam(&quot;print_hello&quot;))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>&quot;Hello!&quot;<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal">else</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::cout<sp/>&lt;&lt;<sp/>&quot;No<sp/>greetings<sp/>for<sp/>you!&quot;<sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
</programlisting></para>
<para>To access a string that a user passed in to the <computeroutput>string</computeroutput> parameter, the following code could be used:</para>
<para><programlisting><codeline><highlight class="normal">using<sp/>namespace<sp/>mlpack;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">const<sp/>std::string&amp;<sp/>str<sp/>=<sp/>IO::GetParam&lt;std::string&gt;(&quot;string&quot;);</highlight></codeline>
</programlisting></para>
<para>Matrix types are accessed in the same way:</para>
<para><programlisting><codeline><highlight class="normal">using<sp/>namespace<sp/>mlpack;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">arma::mat&amp;<sp/>matrix<sp/>=<sp/>IO::GetParam&lt;arma::mat&gt;(&quot;matrix&quot;);</highlight></codeline>
</programlisting></para>
<para>Similarly, model types can be accessed. If a <computeroutput>LinearRegression</computeroutput> model was specified by the user as the parameter <computeroutput>model</computeroutput>, the following code can access the model:</para>
<para><programlisting><codeline><highlight class="normal">using<sp/>namespace<sp/>mlpack;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">LinearRegression&amp;<sp/>lr<sp/>=<sp/>IO::GetParam&lt;LinearRegression&gt;(&quot;model&quot;);</highlight></codeline>
</programlisting></para>
<para>Matrices with categoricals are a little trickier to access since the C++ parameter type is <computeroutput>std::tuple&lt;data::DatasetInfo, arma::mat&gt;</computeroutput>. The example below creates references to both the <computeroutput>DatasetInfo</computeroutput> and matrix objects, assuming the user has passed a matrix with categoricals as the <computeroutput>matrix</computeroutput> parameter.</para>
<para><programlisting><codeline><highlight class="normal">using<sp/>namespace<sp/>mlpack;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">typename<sp/>std::tuple&lt;data::DatasetInfo,<sp/>arma::mat&gt;<sp/>TupleType;</highlight></codeline>
<codeline><highlight class="normal">data::DatasetInfo&amp;<sp/>di<sp/>=<sp/>std::get&lt;0&gt;(IO::GetParam&lt;TupleType&gt;(&quot;matrix&quot;));</highlight></codeline>
<codeline><highlight class="normal">arma::mat&amp;<sp/>matrix<sp/>=<sp/>std::get&lt;1&gt;(IO::GetParam&lt;TupleType&gt;(&quot;matrix&quot;));</highlight></codeline>
</programlisting></para>
<para>These two functions can be used to write an entire program. The third function, <computeroutput><ref refid="namespacemlpack_1_1bindings_1_1cli_1aaf7d940ea6f4c5984891552aad0a003a" kindref="member">GetPrintableParam()</ref></computeroutput>, can be used to help provide useful output in a program. Typically, this function should be used if you want to provide some kind of error message about a matrix or model parameter, but want to avoid printing the matrix itself. For instance, printing a matrix parameter with <computeroutput><ref refid="namespacemlpack_1_1bindings_1_1cli_1aaf7d940ea6f4c5984891552aad0a003a" kindref="member">GetPrintableParam()</ref></computeroutput> will print the filename for a command-line binding or the size of a matrix for a Python binding. <computeroutput><ref refid="namespacemlpack_1_1bindings_1_1cli_1aaf7d940ea6f4c5984891552aad0a003a" kindref="member">GetPrintableParam()</ref></computeroutput> for a model parameter will print the filename for the model for a command-line binding or a simple string representing the type of the model for a Python binding.</para>
<para>Putting all of these ideas together, here is the <computeroutput>mlpackMain()</computeroutput> function that could be created for the &quot;random_numbers&quot; program from earlier sections.</para>
<para><programlisting><codeline><highlight class="normal">#include<sp/>&lt;mlpack/core/util/mlpack_main.hpp&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">//<sp/>BINDING_NAME(),<sp/>BINDING_SHORT_DESC(),<sp/>BINDING_LONG_DESC()<sp/>,<sp/>BINDING_EXAMPLE(),</highlight></codeline>
<codeline><highlight class="normal">//<sp/>BINDING_SEE_ALSO()<sp/>and<sp/>PARAM_*()<sp/>definitions<sp/>should<sp/>go<sp/>here:</highlight></codeline>
<codeline><highlight class="normal">//<sp/>...</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">using<sp/>namespace<sp/>mlpack;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">void<sp/>mlpackMain()</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>If<sp/>the<sp/>user<sp/>passed<sp/>an<sp/>input<sp/>matrix,<sp/>tell<sp/>them<sp/>that<sp/>we&apos;ll<sp/>be<sp/>ignoring<sp/>it.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(IO::HasParam(&quot;input&quot;))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Print<sp/>the<sp/>filename<sp/>the<sp/>user<sp/>passed,<sp/>if<sp/>a<sp/>command-line<sp/>binding,<sp/>or<sp/>the</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>size<sp/>of<sp/>the<sp/>matrix<sp/>passed,<sp/>if<sp/>a<sp/>Python<sp/>binding.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>Log::Warn<sp/>&lt;&lt;<sp/>&quot;The<sp/>input<sp/>matrix<sp/>&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>IO::GetPrintableParam&lt;arma::mat&gt;(&quot;input&quot;)<sp/>&lt;&lt;<sp/>&quot;<sp/>is<sp/>ignored!&quot;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&lt;&lt;<sp/>std::endl;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Get<sp/>the<sp/>number<sp/>of<sp/>samples<sp/>and<sp/>also<sp/>the<sp/>value<sp/>we<sp/>should<sp/>subtract.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>size_t<sp/>numSamples<sp/>=<sp/>(size_t)<sp/>IO::GetParam&lt;int&gt;(&quot;num_samples&quot;);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>const<sp/>double<sp/>subtractValue<sp/>=<sp/>IO::GetParam&lt;double&gt;(&quot;subtract&quot;);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Create<sp/>the<sp/>random<sp/>matrix<sp/>(1-dimensional).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>arma::mat<sp/>output(1,<sp/>numSamples,<sp/>arma::fill::randu);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>output<sp/>-=<sp/>subtractValue;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Save<sp/>the<sp/>output<sp/>matrix<sp/>if<sp/>the<sp/>user<sp/>wants.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(IO::HasParam(&quot;output&quot;))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>IO::GetParam&lt;arma::mat&gt;(&quot;output&quot;)<sp/>=<sp/>std::move(output);<sp/>//<sp/>Avoid<sp/>copy.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Did<sp/>the<sp/>user<sp/>request<sp/>a<sp/>random<sp/>linear<sp/>regression<sp/>model?</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(IO::HasParam(&quot;output_model&quot;))</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>LinearRegression<sp/>lr;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>lr.Parameters().randu(10);<sp/>//<sp/>10-dimensional<sp/>(arbitrary).</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>lr.Lambda()<sp/>=<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>lr.Intercept()<sp/>=<sp/>false;<sp/>//<sp/>No<sp/>intercept<sp/>term.</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>IO::GetParam&lt;LinearRegression&gt;(&quot;output_model&quot;)<sp/>=<sp/>std::move(lr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
</sect2>
<sect2 id="bindings_1bindings_general_more">
<title>More documentation on using IO</title>
<para>More documentation for the IO module can either be found on the <ref refid="classmlpack_1_1IO" kindref="compound">mlpack::IO</ref> documentation page, or by reading the existing mlpack bindings. These can be found in the <computeroutput>src/mlpack/methods/</computeroutput> folders, by finding the <computeroutput>_main.cpp</computeroutput> files. For instance, <computeroutput>src/mlpack/methods/neighbor_search/knn_main.cpp</computeroutput> is the k-nearest-neighbor search program definition.</para>
</sect2>
</sect1>
<sect1 id="bindings_1bindings_structure">
<title>Structure of IO module and associated macros</title>
<para>This section describes the internal functionality of the IO module and the associated macros. If you are only interested in writing mlpack programs, this section is probably not worth reading.</para>
<para>There are eight main components involved with mlpack bindings:</para>
<para><itemizedlist>
<listitem><para>the IO module, a singleton class that stores parameter information</para>
</listitem><listitem><para>the mlpackMain() function that defines the functionality of the binding</para>
</listitem><listitem><para>the <ref refid="param_8hpp_1a3610abda0a69dc19a08c50e713f615b7" kindref="member">BINDING_NAME()</ref> macro that defines the binding name</para>
</listitem><listitem><para>the <ref refid="param_8hpp_1a013f7f337d6139c7f6de3a4f0fa7b019" kindref="member">BINDING_SHORT_DESC()</ref> macro that defines the short description</para>
</listitem><listitem><para>the <ref refid="param_8hpp_1a7f7cbd16d4fecab7136b5ca1cbcbb0a7" kindref="member">BINDING_LONG_DESC()</ref> macro that defines the long description</para>
</listitem><listitem><para>(optional) the <ref refid="param_8hpp_1a9ffe1d6d254b3e50a5611f77ee381838" kindref="member">BINDING_EXAMPLE()</ref> macro that defines example usages</para>
</listitem><listitem><para>(optional) the <ref refid="param_8hpp_1add4a79815b7f3972699cc414bfc9fe57" kindref="member">BINDING_SEE_ALSO()</ref> macro that defines &quot;see also&quot; links</para>
</listitem><listitem><para>the PARAM_*() macros that define parameters for the binding</para>
</listitem></itemizedlist>
</para>
<para>The <ref refid="classmlpack_1_1IO" kindref="compound">mlpack::IO</ref> module is a singleton class that stores, at runtime, the binding name, the documentation, and the parameter information and values. In order to do this, each parameter and the program documentation must make themselves known to the IO singleton. This is accomplished by having the <computeroutput><ref refid="param_8hpp_1a3610abda0a69dc19a08c50e713f615b7" kindref="member">BINDING_NAME()</ref></computeroutput>, <computeroutput><ref refid="param_8hpp_1a013f7f337d6139c7f6de3a4f0fa7b019" kindref="member">BINDING_SHORT_DESC()</ref></computeroutput>, <computeroutput><ref refid="param_8hpp_1a7f7cbd16d4fecab7136b5ca1cbcbb0a7" kindref="member">BINDING_LONG_DESC()</ref></computeroutput>, <computeroutput><ref refid="param_8hpp_1a9ffe1d6d254b3e50a5611f77ee381838" kindref="member">BINDING_EXAMPLE()</ref></computeroutput>, <computeroutput><ref refid="param_8hpp_1add4a79815b7f3972699cc414bfc9fe57" kindref="member">BINDING_SEE_ALSO()</ref></computeroutput> and <computeroutput>PARAM_*</computeroutput>() macros declare global variables that, in their constructors, register themselves with the IO singleton.</para>
<para>The <computeroutput><ref refid="param_8hpp_1a3610abda0a69dc19a08c50e713f615b7" kindref="member">BINDING_NAME()</ref></computeroutput> macro declares an object of type <ref refid="classmlpack_1_1util_1_1ProgramName" kindref="compound">mlpack::util::ProgramName</ref>. The <computeroutput><ref refid="param_8hpp_1a013f7f337d6139c7f6de3a4f0fa7b019" kindref="member">BINDING_SHORT_DESC()</ref></computeroutput> macro declares an object of type <ref refid="classmlpack_1_1util_1_1ShortDescription" kindref="compound">mlpack::util::ShortDescription</ref>. The <computeroutput><ref refid="param_8hpp_1a7f7cbd16d4fecab7136b5ca1cbcbb0a7" kindref="member">BINDING_LONG_DESC()</ref></computeroutput> macro declares an object of type <ref refid="classmlpack_1_1util_1_1LongDescription" kindref="compound">mlpack::util::LongDescription</ref>. The <computeroutput><ref refid="param_8hpp_1a9ffe1d6d254b3e50a5611f77ee381838" kindref="member">BINDING_EXAMPLE()</ref></computeroutput> macro declares an object of type <ref refid="classmlpack_1_1util_1_1Example" kindref="compound">mlpack::util::Example</ref>. The <computeroutput><ref refid="param_8hpp_1add4a79815b7f3972699cc414bfc9fe57" kindref="member">BINDING_SEE_ALSO()</ref></computeroutput> macro declares an object of type <ref refid="classmlpack_1_1util_1_1SeeAlso" kindref="compound">mlpack::util::SeeAlso</ref>. The <computeroutput>ProgramName</computeroutput> class constructor calls IO::RegisterProgramName() in order to register the given program name. The <computeroutput>ShortDescription</computeroutput> class constructor calls IO::RegisterShortDescription() in order to register the given short description. The <computeroutput>LongDescription</computeroutput> class constructor calls IO::RegisterLongDescription() in order to register the given long description. The <computeroutput>Example</computeroutput> class constructor calls IO::RegisterExample() in order to register the given example. The <computeroutput>SeeAlso</computeroutput> class constructor calls IO::RegisterSeeAlso() in order to register the given see-also link.</para>
<para>The <computeroutput>PARAM_*</computeroutput>() macros declare an object that will, in its constructor, call IO::Add() to register that parameter with the IO singleton. The specific type of that object will depend on the binding type being used.</para>
<para>The IO::Add() function takes an <ref refid="structmlpack_1_1util_1_1ParamData" kindref="compound">mlpack::util::ParamData</ref> object as its input. This <computeroutput>ParamData</computeroutput> object has a number of fields that must be set to properly describe the parameter. Each of the fields is documented and probably self-explanatory, but three fields deserve further explanation:</para>
<para><itemizedlist>
<listitem><para>the <computeroutput>std::string tname</computeroutput> member is used to encode the true type of the parameter<mdash/>which is not known by the IO singleton at runtime. This should be set to <computeroutput><ref refid="param__data_8hpp_1ac909d914008cce49fa42ddd10b9b36c5" kindref="member">TYPENAME(T)</ref></computeroutput> where <computeroutput>T</computeroutput> is the type of the parameter.</para>
</listitem><listitem><para>the <computeroutput>boost::any value</computeroutput> member is used to hold the actual value of the parameter. Typically this will simply be the parameter held by a <computeroutput>boost::any</computeroutput> object, but for some types it may be more complex. For instance, for a command-line matrix option, the <computeroutput>value</computeroutput> parameter will actually hold a tuple containing both the filename and the matrix itself.</para>
</listitem><listitem><para>the <computeroutput>std::string cppType</computeroutput> should be a string containing the type as seen in C++ code. Typically this can be encoded by stringifying a <computeroutput>PARAM_*</computeroutput>() macro argument.</para>
</listitem></itemizedlist>
</para>
<para>Thus, the global object defined by the <computeroutput>PARAM_*</computeroutput>() macro must turn its arguments into a fully specified <computeroutput>ParamData</computeroutput> object and then call IO::Add() with it.</para>
<para>With different binding types, different behavior is often required for the <computeroutput><ref refid="namespacemlpack_1_1bindings_1_1cli_1a9eee50cbae50b3464c59b88ab7b88e44" kindref="member">GetParam&lt;T&gt;()</ref></computeroutput>, <computeroutput>HasParam()</computeroutput>, and <computeroutput><ref refid="namespacemlpack_1_1bindings_1_1cli_1aaf7d940ea6f4c5984891552aad0a003a" kindref="member">GetPrintableParam&lt;T&gt;()</ref></computeroutput> functions. In order to handle this, the IO singleton also holds a function pointer map, so that a given type of option can call specific functionality for a certain task. This function map is accessible as <computeroutput>IO::functionMap</computeroutput> and is not meant to be used by users, but instead by people writing binding types.</para>
<para>Each function in the map must have signature</para>
<para><programlisting><codeline><highlight class="normal">void<sp/>MapFunction(const<sp/>util::ParamData&amp;<sp/>d,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>void*<sp/>input,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>void*<sp/>output);</highlight></codeline>
</programlisting></para>
<para>The use of void pointers allows any type to be specified as input or output to the function without changing the signature for the map. The IO function map is of type</para>
<para><programlisting><codeline><highlight class="normal">std::map&lt;std::string,<sp/>std::map&lt;std::string,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/>(*)(const<sp/>util::ParamData&amp;,<sp/>const<sp/>void*,<sp/>void*)&gt;&gt;</highlight></codeline>
</programlisting></para>
<para>and the first map key is the typename (<computeroutput>tname</computeroutput>) of the parameter, and the second map key is the string name of the function. For instance, calling</para>
<para><programlisting><codeline><highlight class="normal">const<sp/>util::ParamData&amp;<sp/>d<sp/>=<sp/>IO::Parameters()[&quot;param&quot;];</highlight></codeline>
<codeline><highlight class="normal">IO::GetSingleton().functionMap[d.tname][&quot;GetParam&quot;](d,<sp/>input,<sp/>output);</highlight></codeline>
</programlisting></para>
<para>will call the <computeroutput><ref refid="namespacemlpack_1_1bindings_1_1cli_1a9eee50cbae50b3464c59b88ab7b88e44" kindref="member">GetParam()</ref></computeroutput> function for the type of the <computeroutput>&quot;param&quot;</computeroutput> parameter. Examples are probably easiest to understand how this functionality works; see the <ref refid="namespacemlpack_1_1bindings_1_1cli_1a9eee50cbae50b3464c59b88ab7b88e44" kindref="member">IO::GetParam&lt;T&gt;()</ref> source to see how this might be used.</para>
<para>The IO singleton expects the following functions to be defined in the function map for each type:</para>
<para><itemizedlist>
<listitem><para><computeroutput>GetParam</computeroutput> <ndash/> return a pointer to the parameter in <computeroutput>output</computeroutput>.</para>
</listitem><listitem><para><computeroutput>GetPrintableParam</computeroutput> <ndash/> return a pointer to a string description of the parameter in <computeroutput>output</computeroutput>.</para>
</listitem></itemizedlist>
</para>
<para>If these functions are properly defined, then the IO module will work correctly. Other functions may also be defined; these may be used by other parts of the binding infrastructure for different languages.</para>
</sect1>
<sect1 id="bindings_1bindings_cli">
<title>Command-line program bindings</title>
<para>This section describes the internal functionality of the command-line program binding generator. If you are only interested in writing mlpack programs, this section probably is not worth reading. This section is worth reading only if you want to know the specifics of how the <computeroutput>mlpackMain()</computeroutput> function and macros get turned into a fully working command-line program.</para>
<para>The code for the command-line bindings is found in <computeroutput>src/mlpack/bindings/cli</computeroutput>.</para>
<sect2 id="bindings_1bindings_cli_mlpack_main">
<title>mlpackMain() definition</title>
<para>Any command-line program must be compiled with the <computeroutput>BINDING_TYPE</computeroutput> macro set to the value <computeroutput>BINDING_TYPE_CLI</computeroutput>. This is handled by the CMake macro <computeroutput><ref refid="methods_2nmf_2CMakeLists_8txt_1a05cd3fbacefda64d4c50d29c9ba6770b" kindref="member">add_cli_executable()</ref></computeroutput>.</para>
<para>When <computeroutput>BINDING_TYPE</computeroutput> is set to <computeroutput>BINDING_TYPE_CLI</computeroutput>, the following is set in <computeroutput><ref refid="mlpack__main_8hpp" kindref="compound">src/mlpack/core/util/mlpack_main.hpp</ref></computeroutput>, which must be included by every mlpack binding:</para>
<para><itemizedlist>
<listitem><para>The options defined by <computeroutput>PARAM_*</computeroutput>() macros are of type <ref refid="classmlpack_1_1bindings_1_1cli_1_1CLIOption" kindref="compound">mlpack::bindings::cli::CLIOption</ref>.</para>
</listitem><listitem><para>The parameter and value printing macros for <computeroutput><ref refid="param_8hpp_1a7f7cbd16d4fecab7136b5ca1cbcbb0a7" kindref="member">BINDING_LONG_DESC()</ref></computeroutput> and <ref refid="param_8hpp_1a9ffe1d6d254b3e50a5611f77ee381838" kindref="member">BINDING_EXAMPLE()</ref> are set: The <computeroutput>PRINT_PARAM_STRING()</computeroutput> macro is defined as <ref refid="namespacemlpack_1_1bindings_1_1cli_1ac64f8a790e82ba58a13eda3227ce14b5" kindref="member">mlpack::bindings::cli::ParamString()</ref>. The <computeroutput>PRINT_DATASET()</computeroutput> macro is defined as <ref refid="namespacemlpack_1_1bindings_1_1cli_1aae7c332a39af5d11ff2ccfe36918a9e8" kindref="member">mlpack::bindings::cli::PrintDataset()</ref>. The <computeroutput>PRINT_MODEL()</computeroutput> macro is defined as <ref refid="namespacemlpack_1_1bindings_1_1cli_1a399b457336a1e6dc98fa62162d78c97f" kindref="member">mlpack::bindings::cli::PrintModel()</ref>. The <computeroutput>PRINT_CALL()</computeroutput> macro is defined as <ref refid="namespacemlpack_1_1bindings_1_1cli_1a88610ef05073988cd29e1ac4a37f5481" kindref="member">mlpack::bindings::cli::ProgramCall()</ref>.</para>
</listitem><listitem><para>The function <computeroutput>int main()</computeroutput> is defined as:</para>
</listitem></itemizedlist>
</para>
<para><programlisting><codeline><highlight class="normal">int<sp/>main(int<sp/>argc,<sp/>char**<sp/>argv)</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Parse<sp/>the<sp/>command-line<sp/>options;<sp/>put<sp/>them<sp/>into<sp/>IO.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>mlpack::bindings::cli::ParseCommandLine(argc,<sp/>argv);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>mlpackMain();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>Print<sp/>output<sp/>options,<sp/>print<sp/>verbose<sp/>information,<sp/>save<sp/>model<sp/>parameters,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>clean<sp/>up,<sp/>and<sp/>so<sp/>forth.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>mlpack::bindings::cli::EndProgram();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>Thus any mlpack command-line binding first processes the command-line arguments with <ref refid="namespacemlpack_1_1bindings_1_1cli_1a9f4d336f3d999569328497d0b8f37b35" kindref="member">mlpack::bindings::cli::ParseCommandLine()</ref>, then runs the binding with <computeroutput>mlpackMain()</computeroutput>, then cleans up with <ref refid="namespacemlpack_1_1bindings_1_1cli_1a0f5881c4001a8176d0ad6387b30c8b8a" kindref="member">mlpack::bindings::cli::EndProgram()</ref>.</para>
<para>The <computeroutput><ref refid="namespacemlpack_1_1bindings_1_1cli_1a9f4d336f3d999569328497d0b8f37b35" kindref="member">ParseCommandLine()</ref></computeroutput> function reads the input parameters and sets the values in IO. For matrix-type and model-type parameters, this reads the filenames from the command-line, but does not load the matrix or model. Instead the matrix or model is loaded the first time it is accessed with <computeroutput><ref refid="namespacemlpack_1_1bindings_1_1cli_1a9eee50cbae50b3464c59b88ab7b88e44" kindref="member">GetParam&lt;T&gt;()</ref></computeroutput>.</para>
<para>The <computeroutput>--help</computeroutput> parameter is handled by the <ref refid="namespacemlpack_1_1bindings_1_1cli_1a8ab11ab73071ec0432e656e9d6a922ea" kindref="member">mlpack::bindings::cli::PrintHelp()</ref> function.</para>
<para>At the end of program execution, the <ref refid="namespacemlpack_1_1bindings_1_1cli_1a0f5881c4001a8176d0ad6387b30c8b8a" kindref="member">mlpack::bindings::cli::EndProgram()</ref> function is called. This writes any output matrix or model parameters to disk, and prints the program parameters and timers if <computeroutput>--verbose</computeroutput> was given.</para>
</sect2>
<sect2 id="bindings_1bindings_cli_matrix">
<title>Matrix and model parameter handling</title>
<para>For command line bindings, the matrix, model, and matrix with categorical type parameters all require special handling, since it is not possible to pass a matrix of any reasonable size or a model on the command line directly. Therefore for a matrix or model parameter, the user specifies the file containing that matrix or model parameter. If the parameter is an input parameter, then the file is loaded when <computeroutput><ref refid="namespacemlpack_1_1bindings_1_1cli_1a9eee50cbae50b3464c59b88ab7b88e44" kindref="member">GetParam&lt;T&gt;()</ref></computeroutput> is called. If the parameter is an output parameter, then the matrix or model is saved to the file when <computeroutput><ref refid="namespacemlpack_1_1bindings_1_1cli_1a0f5881c4001a8176d0ad6387b30c8b8a" kindref="member">EndProgram()</ref></computeroutput> is called.</para>
<para>The actual implementation of this is that the <computeroutput>boost::any value</computeroutput> member of the <computeroutput>ParamData</computeroutput> struct does not hold the model or the matrix, but instead a <computeroutput>std::tuple</computeroutput> containing both the matrix or the model, and the filename associated with that matrix or model.</para>
<para>This means that functions like <computeroutput><ref refid="namespacemlpack_1_1bindings_1_1cli_1a9eee50cbae50b3464c59b88ab7b88e44" kindref="member">GetParam&lt;T&gt;()</ref></computeroutput> and <computeroutput><ref refid="namespacemlpack_1_1bindings_1_1cli_1aaf7d940ea6f4c5984891552aad0a003a" kindref="member">GetPrintableParam&lt;T&gt;()</ref></computeroutput> (and all of the other associated functions in the IO function map) must have special handling for matrix or model types. See those implementatipns for more details<mdash/>the special handling is enforced via SFINAE.</para>
</sect2>
<sect2 id="bindings_1bindings_cli_parsing">
<title>Parsing the command line</title>
<para>The <computeroutput><ref refid="namespacemlpack_1_1bindings_1_1cli_1a9f4d336f3d999569328497d0b8f37b35" kindref="member">ParseCommandLine()</ref></computeroutput> function uses <computeroutput>CLI11</computeroutput> to read the values from the command line into the <computeroutput>ParamData</computeroutput> structs held by the IO singleton.</para>
<para>In order to set up <computeroutput>CLI11</computeroutput><mdash/>and to keep its headers from needing to be included by the rest of the library<mdash/>the code loops over each parameter known by the IO singleton and calls the <computeroutput>&quot;AddToPO&quot;</computeroutput> function from the function map. This in turn calls the necessary functions to register a given parameter with <computeroutput>CLI11</computeroutput>, and once all parameters have been registered, the facilities provided by <computeroutput>CLI11</computeroutput> are used to parse the command line input properly.</para>
</sect2>
</sect1>
<sect1 id="bindings_1bindings_python">
<title>Python bindings</title>
<para>This section describes the internal functionality of the mlpack Python binding generator. If you are only interested in writing new bindings or building the bindings, this section is probably not worth reading. But if you are interested in the internal working of the Python binding generator, then this section is for you.</para>
<para>The Python bindings are significantly more complex than the command line bindings because we cannot just compile directly to a finished product. Instead we need a multi-stage compilation:</para>
<para><itemizedlist>
<listitem><para>We must generate a setup.py file that can be used to compile the bindings.</para>
</listitem><listitem><para>We must generate the .pyx (Cython) bindings for each program.</para>
</listitem><listitem><para>Then we must build each .pyx into a .so that is loadable from Python.</para>
</listitem><listitem><para>We must also test the Python bindings.</para>
</listitem></itemizedlist>
</para>
<para>This is done with a combination of C++ code to generate the .pyx bindings, CMake to run the actual compilation and generate the setup.py file, some utility Python functions, and tests written in both Python and C++. This code is primarily contained in <computeroutput>src/mlpack/bindings/python/</computeroutput>.</para>
<sect2 id="bindings_1bindings_python_matrix">
<title>Passing matrices to/from Python</title>
<para>The standard Python matrix library is numpy, so mlpack bindings should accept numpy matrices as input. Fortunately, numpy Cython bindings already exist, which make it easy to convert from a numpy object to an Armadillo object without copying any data. This code can be found in <computeroutput>src/mlpack/bindings/python/mlpack/arma_numpy.pyx</computeroutput>, and is used by the Python <computeroutput><ref refid="namespacemlpack_1_1bindings_1_1cli_1a9eee50cbae50b3464c59b88ab7b88e44" kindref="member">GetParam&lt;T&gt;()</ref></computeroutput> functionality.</para>
<para>mlpack also supports categorical matrices; in Python, the typical way of representing matrices with categorical features is with Pandas. Therefore, mlpack also accepts Pandas matrices, and if any of the Pandas matrix dimensions are categorical, these are properly encoded. The function <computeroutput>to_matrix_with_info()</computeroutput> from <computeroutput>mlpack/bindings/python/mlpack/matrix_utils.py</computeroutput> is used to perform this conversion.</para>
</sect2>
<sect2 id="bindings_1bindings_python_model">
<title>Passing model parameter to/from Python</title>
<para>We use (or abuse) Cython functionality in order to give the user a model object that they can use in their Python code. However, we do not want to (or have the infrastructure to) write bindings for every method that a serializable model class might support; therefore, we only desire to return a memory pointer to the model to the user.</para>
<para>In this way, a user that receives a model from an output parameter can then reuse the model as an input parameter to another binding (or the same binding).</para>
<para>To return a function pointer we have to define a Cython class in the following way (this example is taken from the perceptron binding):</para>
<para><programlisting><codeline><highlight class="normal">cdef<sp/>extern<sp/>from<sp/>&quot;&lt;/home/ryan/src/mlpack-rc/src/mlpack/methods/perceptron/perceptron_main.cpp&gt;&quot;<sp/>nogil:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cdef<sp/>int<sp/>mlpackMain()<sp/>nogil<sp/>except<sp/>+RuntimeError</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>cdef<sp/>cppclass<sp/>PerceptronModel:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>PerceptronModel()<sp/>nogil</highlight></codeline>
<codeline></codeline>
<codeline></codeline>
<codeline><highlight class="normal">cdef<sp/>class<sp/>PerceptronModelType:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cdef<sp/>PerceptronModel*<sp/>modelptr</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>def<sp/>__cinit__(self):</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>self.modelptr<sp/>=<sp/>new<sp/>PerceptronModel()</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>def<sp/>__dealloc__(self):</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>del<sp/>self.modelptr</highlight></codeline>
</programlisting></para>
<para>This class definition is automatically generated when the .pyx file is automatically generated.</para>
</sect2>
<sect2 id="bindings_1bindings_python_setup_py">
<title>CMake generation of setup.py</title>
<para>A boilerplate setup.py file can be found in <computeroutput>src/mlpack/bindings/python/setup.py.in</computeroutput>. This will be configured by CMake to produce the final <computeroutput>setup.py</computeroutput> file, but in order to do this, a list of the .pyx files to be compiled must be gathered.</para>
<para>Therefore, the <computeroutput>add_python_binding()</computeroutput> macro is defined in <computeroutput><ref refid="bindings_2python_2CMakeLists_8txt" kindref="compound">src/mlpack/bindings/python/CMakeLists.txt</ref></computeroutput>. This adds the given binding to the <computeroutput>MLPACK_PYXS</computeroutput> variable, which is then inserted into <computeroutput>setup.py</computeroutput> as part of the <computeroutput>configure_file()</computeroutput> step in <computeroutput><ref refid="CMakeLists_8txt" kindref="compound">src/mlpack/CMakeLists.txt</ref></computeroutput>.</para>
</sect2>
<sect2 id="bindings_1bindings_python_generate_pyx">
<title>Generation of .pyx files</title>
<para>A binding named <computeroutput>program</computeroutput> is built into a program called <computeroutput>generate_pyx_program</computeroutput> (this a CMake target, so you can build these individually if you like). The file <computeroutput>src/mlpack/bindings/python/generate_pyx.cpp.in</computeroutput> is configured by CMake to set the name of the program and the <computeroutput>*_main</computeroutput>.cpp file to include correctly, then the <computeroutput><ref refid="namespacemlpack_1_1bindings_1_1python_1a6cd6a94b0d12a167d1f1e26ae35e4cb7" kindref="member">mlpack::bindings::python::PrintPYX()</ref></computeroutput> function is called by the program. The <computeroutput><ref refid="namespacemlpack_1_1bindings_1_1python_1a6cd6a94b0d12a167d1f1e26ae35e4cb7" kindref="member">PrintPYX()</ref></computeroutput> function uses the parameters that have been set in the IO singleton by the <computeroutput><ref refid="param_8hpp_1a3610abda0a69dc19a08c50e713f615b7" kindref="member">BINDING_NAME()</ref></computeroutput>, <computeroutput><ref refid="param_8hpp_1a013f7f337d6139c7f6de3a4f0fa7b019" kindref="member">BINDING_SHORT_DESC()</ref></computeroutput>, <computeroutput><ref refid="param_8hpp_1a7f7cbd16d4fecab7136b5ca1cbcbb0a7" kindref="member">BINDING_LONG_DESC()</ref></computeroutput>, <computeroutput><ref refid="param_8hpp_1a9ffe1d6d254b3e50a5611f77ee381838" kindref="member">BINDING_EXAMPLE()</ref></computeroutput>, <computeroutput><ref refid="param_8hpp_1add4a79815b7f3972699cc414bfc9fe57" kindref="member">BINDING_SEE_ALSO()</ref></computeroutput> and <computeroutput>PARAM_*</computeroutput>() macros in order to actually print a fully-working .pyx file that can be compiled. The file has several sections:</para>
<para><itemizedlist>
<listitem><para>Python imports (numpy/pandas/cython/etc.)</para>
</listitem><listitem><para>Cython imports of C++ utility functions and Armadillo functionality</para>
</listitem><listitem><para>Cython imports of any necessary serializable model types</para>
</listitem><listitem><para>Definitions of classes for serializable model types</para>
</listitem><listitem><para>The binding function definition</para>
</listitem><listitem><para>Documentation: input and output parameters</para>
</listitem><listitem><para>The call to mlpackMain()</para>
</listitem><listitem><para>Handling of output functionality</para>
</listitem><listitem><para>Return of output parameters</para>
</listitem></itemizedlist>
</para>
<para>Any output parameters for Python bindings are returned in a dict containing named elements.</para>
</sect2>
<sect2 id="bindings_1bindings_python_build_pyx">
<title>Building the .pyx files</title>
<para>After building the <computeroutput>generate_pyx_program</computeroutput> target, the <computeroutput>build_pyx_program</computeroutput> target is built as a dependency of the <computeroutput>python</computeroutput> target. This simply takes the generated .pyx file and uses Python setuptools to compile this to a Python binding.</para>
</sect2>
<sect2 id="bindings_1bindings_python_testing">
<title>Testing the Python bindings</title>
<para>We cannot do our tests only from the Boost Unit Test Framework in C++ because we need to see that we are able to load parameters properly from Python and return output correctly.</para>
<para>The tests are in <computeroutput>src/mlpack/bindings/python/tests/</computeroutput> and test both the actual bindings and also the auxiliary Python code included in <computeroutput>src/mlpack/bindings/python/mlpack/</computeroutput>.</para>
</sect2>
</sect1>
<sect1 id="bindings_1bindings_new">
<title>Adding new binding types</title>
<para>Adding a new binding type to mlpack is fairly straightforward once the general structure of the IO singleton and the function map that IO uses is understood. For each different language that bindings are desired for, the route to a solution will be particularly different<mdash/>so it is hard to provide any general guidance for how to make new bindings that will be applicable to each language.</para>
<para>In general, the first thing to handle will be how matrices are passed back and forth between the target language. Typically this might mean getting the memory address of an input matrix and wrapping an <computeroutput>arma::mat</computeroutput> object around that memory address. This can be handled in the <computeroutput><ref refid="namespacemlpack_1_1bindings_1_1cli_1a9eee50cbae50b3464c59b88ab7b88e44" kindref="member">GetParam()</ref></computeroutput> function that is part of the IO singleton function map; see <computeroutput>get_param.hpp</computeroutput> for both the IO and Python bindings for an example (in <computeroutput>src/mlpack/bindings/cli/</computeroutput> and <computeroutput>src/mlpack/bindings/python/</computeroutput>).</para>
<para>Serialization of models is also a tricky consideration; in some languages you will be able to pass a pointer to the model itself. This is generally best<mdash/>users should not expect to be able to manipulate the model in the target language, but they should expect that they can pass a model back and forth without paying a runtime penalty. So, for example, serializing a model using a <computeroutput>boost::text_oarchive</computeroutput> and then returning the string that represents the model is not acceptable, because that string can be extremely large and the time it takes to decode the model can be very large.</para>
<para>The strategy of generating a binding definition for the target language, like what is done with Python, can be a useful strategy that should be considered. If this is the route that is desired, a large amount of CMake boilerplate may be necessary. The Python CMake configuration can be referred to as an example, but probably a large amount of adaptation to other languages will be necessary.</para>
<para>Lastly, when adding a new language, be sure to make sure it works with the Markdown documentation generator. In order to make this happen, you will need to modify all of the <computeroutput>add_markdown_docs()</computeroutput> calls in the different <computeroutput>CMakeLists.txt</computeroutput> files to contain the name of the language you have written a binding for. You will also need to modify every function in <computeroutput>src/mlpack/bindings/markdown/print_doc_functions_impl.hpp</computeroutput> to correctly call out to the corresponding function for the language that you have written bindings for. </para>
</sect1>
    </detaileddescription>
    <location file="/home/aakash/mlpack/doc/guide/bindings.hpp"/>
  </compounddef>
</doxygen>
