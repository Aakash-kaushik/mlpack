\doxysection{Tf\+Idf\+Encoding\+Policy Class Reference}
\label{classmlpack_1_1data_1_1TfIdfEncodingPolicy}\index{TfIdfEncodingPolicy@{TfIdfEncodingPolicy}}


Definition of the \doxyref{Tf\+Idf\+Encoding\+Policy}{p.}{classmlpack_1_1data_1_1TfIdfEncodingPolicy} class.  


\doxysubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
enum class \textbf{ Tf\+Types} \{ \newline
\textbf{ BINARY}
, \newline
\textbf{ RAW\+\_\+\+COUNT}
, \newline
\textbf{ TERM\+\_\+\+FREQUENCY}
, \newline
\textbf{ SUBLINEAR\+\_\+\+TF}
 \}
\begin{DoxyCompactList}\small\item\em Enum class used to identify the type of the term frequency statistics. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\textbf{ Tf\+Idf\+Encoding\+Policy} (const \textbf{ Tf\+Types} tf\+Type=\textbf{ Tf\+Types\+::\+RAW\+\_\+\+COUNT}, const bool smooth\+Idf=true)
\begin{DoxyCompactList}\small\item\em Construct this using the term frequency type and the inverse document frequency type. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Mat\+Type $>$ }\\void \textbf{ Encode} (Mat\+Type \&output, const size\+\_\+t value, const size\+\_\+t line, const size\+\_\+t)
\begin{DoxyCompactList}\small\item\em The function performs the Tf\+Idf encoding algorithm i.\+e. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Elem\+Type $>$ }\\void \textbf{ Encode} (std\+::vector$<$ std\+::vector$<$ Elem\+Type $>$$>$ \&output, const size\+\_\+t value, const size\+\_\+t line, const size\+\_\+t)
\begin{DoxyCompactList}\small\item\em The function performs the Tf\+Idf encoding algorithm i.\+e. \end{DoxyCompactList}\item 
std\+::vector$<$ size\+\_\+t $>$ \& \textbf{ Lines\+Sizes} ()
\begin{DoxyCompactList}\small\item\em Modify the lines sizes. \end{DoxyCompactList}\item 
const std\+::vector$<$ size\+\_\+t $>$ \& \textbf{ Lines\+Sizes} () const
\begin{DoxyCompactList}\small\item\em Return the lines sizes. \end{DoxyCompactList}\item 
std\+::unordered\+\_\+map$<$ size\+\_\+t, size\+\_\+t $>$ \& \textbf{ Num\+Containing\+Strings} ()
\begin{DoxyCompactList}\small\item\em Modify the number of containing strings depending on the given token. \end{DoxyCompactList}\item 
const std\+::unordered\+\_\+map$<$ size\+\_\+t, size\+\_\+t $>$ \& \textbf{ Num\+Containing\+Strings} () const
\begin{DoxyCompactList}\small\item\em Get the number of containing strings depending on the given token. \end{DoxyCompactList}\item 
void \textbf{ Preprocess\+Token} (const size\+\_\+t line, const size\+\_\+t, const size\+\_\+t value)
\item 
void \textbf{ Reset} ()
\begin{DoxyCompactList}\small\item\em Clear the necessary internal variables. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Archive $>$ }\\void \textbf{ serialize} (Archive \&ar, const uint32\+\_\+t)
\begin{DoxyCompactList}\small\item\em Serialize the class to the given archive. \end{DoxyCompactList}\item 
bool \& \textbf{ Smooth\+Idf} ()
\begin{DoxyCompactList}\small\item\em Modify the idf algorithm type (whether it\textquotesingle{}s smooth or not). \end{DoxyCompactList}\item 
bool \textbf{ Smooth\+Idf} () const
\begin{DoxyCompactList}\small\item\em Determine the idf algorithm type (whether it\textquotesingle{}s smooth or not). \end{DoxyCompactList}\item 
\textbf{ Tf\+Types} \& \textbf{ Tf\+Type} ()
\begin{DoxyCompactList}\small\item\em Modify the term frequency type. \end{DoxyCompactList}\item 
\textbf{ Tf\+Types} \textbf{ Tf\+Type} () const
\begin{DoxyCompactList}\small\item\em Return the term frequency type. \end{DoxyCompactList}\item 
std\+::vector$<$ std\+::unordered\+\_\+map$<$ size\+\_\+t, size\+\_\+t $>$ $>$ \& \textbf{ Tokens\+Frequences} ()
\begin{DoxyCompactList}\small\item\em Modify token frequencies. \end{DoxyCompactList}\item 
const std\+::vector$<$ std\+::unordered\+\_\+map$<$ size\+\_\+t, size\+\_\+t $>$ $>$ \& \textbf{ Tokens\+Frequences} () const
\begin{DoxyCompactList}\small\item\em Return token frequencies. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename Mat\+Type $>$ }\\static void \textbf{ Init\+Matrix} (Mat\+Type \&output, const size\+\_\+t dataset\+Size, const size\+\_\+t, const size\+\_\+t dictionary\+Size)
\begin{DoxyCompactList}\small\item\em The function initializes the output matrix. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Elem\+Type $>$ }\\static void \textbf{ Init\+Matrix} (std\+::vector$<$ std\+::vector$<$ Elem\+Type $>$$>$ \&output, const size\+\_\+t dataset\+Size, const size\+\_\+t, const size\+\_\+t dictionary\+Size)
\begin{DoxyCompactList}\small\item\em The function initializes the output matrix. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Definition of the \doxyref{Tf\+Idf\+Encoding\+Policy}{p.}{classmlpack_1_1data_1_1TfIdfEncodingPolicy} class. 

\doxyref{Tf\+Idf\+Encoding\+Policy}{p.}{classmlpack_1_1data_1_1TfIdfEncodingPolicy} is used as a helper class for \doxyref{String\+Encoding}{p.}{classmlpack_1_1data_1_1StringEncoding}.

Tf-\/idf is a weighting scheme that takes into account the importance of encoded tokens. The tf-\/idf statistics is equal to term frequency (tf) multiplied by inverse document frequency (idf). The encoder assigns the corresponding tf-\/idf value to each token. The order in which the tokens are labeled is defined by the dictionary used by the \doxyref{String\+Encoding}{p.}{classmlpack_1_1data_1_1StringEncoding} class. The encoder writes data either in the column-\/major order or in the row-\/major order depending on the output data type. 

Definition at line 35 of file tf\+\_\+idf\+\_\+encoding\+\_\+policy.\+hpp.



\doxysubsection{Member Enumeration Documentation}
\mbox{\label{classmlpack_1_1data_1_1TfIdfEncodingPolicy_ab8d85d42d950e086c7c311e29a68d497}} 
\index{TfIdfEncodingPolicy@{TfIdfEncodingPolicy}!TfTypes@{TfTypes}}
\index{TfTypes@{TfTypes}!TfIdfEncodingPolicy@{TfIdfEncodingPolicy}}
\doxysubsubsection{TfTypes}
{\footnotesize\ttfamily enum \textbf{ Tf\+Types}\hspace{0.3cm}{\ttfamily [strong]}}



Enum class used to identify the type of the term frequency statistics. 

The present implementation supports the following types\+: BINARY Term frequency equals 1 if the row contains the encoded token and 0 otherwise. RAW\+\_\+\+COUNT Term frequency equals the number of times when the encoded token occurs in the row. TERM\+\_\+\+FREQUENCY Term frequency equals the number of times when the encoded token occurs in the row divided by the total number of tokens in the row. SUBLINEAR\+\_\+\+TF Term frequency equals $ 1 + log(rawCount), $ where raw\+Count is equal to the number of times when the encoded token occurs in the row. \begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{BINARY@{BINARY}!TfIdfEncodingPolicy@{TfIdfEncodingPolicy}}\index{TfIdfEncodingPolicy@{TfIdfEncodingPolicy}!BINARY@{BINARY}}}\mbox{\label{classmlpack_1_1data_1_1TfIdfEncodingPolicy_ab8d85d42d950e086c7c311e29a68d497a98ad0e8750ae10ad556ed7a62affb452}} 
BINARY&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{RAW\_COUNT@{RAW\_COUNT}!TfIdfEncodingPolicy@{TfIdfEncodingPolicy}}\index{TfIdfEncodingPolicy@{TfIdfEncodingPolicy}!RAW\_COUNT@{RAW\_COUNT}}}\mbox{\label{classmlpack_1_1data_1_1TfIdfEncodingPolicy_ab8d85d42d950e086c7c311e29a68d497aaa5db4381426a88461ad4ebe782d04fc}} 
RAW\+\_\+\+COUNT&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{TERM\_FREQUENCY@{TERM\_FREQUENCY}!TfIdfEncodingPolicy@{TfIdfEncodingPolicy}}\index{TfIdfEncodingPolicy@{TfIdfEncodingPolicy}!TERM\_FREQUENCY@{TERM\_FREQUENCY}}}\mbox{\label{classmlpack_1_1data_1_1TfIdfEncodingPolicy_ab8d85d42d950e086c7c311e29a68d497ae4a6b916c2b2d80dbdb92d83b0500d64}} 
TERM\+\_\+\+FREQUENCY&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{SUBLINEAR\_TF@{SUBLINEAR\_TF}!TfIdfEncodingPolicy@{TfIdfEncodingPolicy}}\index{TfIdfEncodingPolicy@{TfIdfEncodingPolicy}!SUBLINEAR\_TF@{SUBLINEAR\_TF}}}\mbox{\label{classmlpack_1_1data_1_1TfIdfEncodingPolicy_ab8d85d42d950e086c7c311e29a68d497add81d4ff18ee485ff5cd1dbb7284c47c}} 
SUBLINEAR\+\_\+\+TF&\\
\hline

\end{DoxyEnumFields}


Definition at line 53 of file tf\+\_\+idf\+\_\+encoding\+\_\+policy.\+hpp.



\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\label{classmlpack_1_1data_1_1TfIdfEncodingPolicy_af15adf81c95183f8da9af1a0c86f86c6}} 
\index{TfIdfEncodingPolicy@{TfIdfEncodingPolicy}!TfIdfEncodingPolicy@{TfIdfEncodingPolicy}}
\index{TfIdfEncodingPolicy@{TfIdfEncodingPolicy}!TfIdfEncodingPolicy@{TfIdfEncodingPolicy}}
\doxysubsubsection{TfIdfEncodingPolicy()}
{\footnotesize\ttfamily \textbf{ Tf\+Idf\+Encoding\+Policy} (\begin{DoxyParamCaption}\item[{const \textbf{ Tf\+Types}}]{tf\+Type = {\ttfamily \textbf{ Tf\+Types\+::\+RAW\+\_\+\+COUNT}},  }\item[{const bool}]{smooth\+Idf = {\ttfamily true} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Construct this using the term frequency type and the inverse document frequency type. 


\begin{DoxyParams}{Parameters}
{\em tf\+Type} & Type of the term frequency statistics. \\
\hline
{\em smooth\+Idf} & Used to indicate whether to use smooth idf or not. If idf is smooth it\textquotesingle{}s calculated by the following formula\+: $ idf(T) = \log \frac{1 + N}{1 + df(T)} + 1, $ where $ N $ is the total number of strings in the document, $ T $ is the current encoded token, $ df(T) $ equals the number of strings which contain the token. If idf isn\textquotesingle{}t smooth then the following rule applies\+: $ idf(T) = \log \frac{N}{df(T)} + 1. $ \\
\hline
\end{DoxyParams}


Definition at line 75 of file tf\+\_\+idf\+\_\+encoding\+\_\+policy.\+hpp.



\doxysubsection{Member Function Documentation}
\mbox{\label{classmlpack_1_1data_1_1TfIdfEncodingPolicy_a03bdaf094410d559836b5359538a0969}} 
\index{TfIdfEncodingPolicy@{TfIdfEncodingPolicy}!Encode@{Encode}}
\index{Encode@{Encode}!TfIdfEncodingPolicy@{TfIdfEncodingPolicy}}
\doxysubsubsection{Encode()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void Encode (\begin{DoxyParamCaption}\item[{Mat\+Type \&}]{output,  }\item[{const size\+\_\+t}]{value,  }\item[{const size\+\_\+t}]{line,  }\item[{const}]{size\+\_\+t }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



The function performs the Tf\+Idf encoding algorithm i.\+e. 

it writes the encoded token to the output. The encoder writes data in the column-\/major order.


\begin{DoxyTemplParams}{Template Parameters}
{\em Mat\+Type} & The output matrix type.\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em output} & Output matrix to store the encoded results (sp\+\_\+mat or mat). \\
\hline
{\em value} & The encoded token. \\
\hline
{\em line} & The line number at which the encoding is performed. \\
\hline
{\em $\ast$} & (index) The token index in the line. \\
\hline
\end{DoxyParams}


Definition at line 148 of file tf\+\_\+idf\+\_\+encoding\+\_\+policy.\+hpp.

\mbox{\label{classmlpack_1_1data_1_1TfIdfEncodingPolicy_ac9397eba09af69a9324e459bfda52706}} 
\index{TfIdfEncodingPolicy@{TfIdfEncodingPolicy}!Encode@{Encode}}
\index{Encode@{Encode}!TfIdfEncodingPolicy@{TfIdfEncodingPolicy}}
\doxysubsubsection{Encode()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void Encode (\begin{DoxyParamCaption}\item[{std\+::vector$<$ std\+::vector$<$ Elem\+Type $>$$>$ \&}]{output,  }\item[{const size\+\_\+t}]{value,  }\item[{const size\+\_\+t}]{line,  }\item[{const}]{size\+\_\+t }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



The function performs the Tf\+Idf encoding algorithm i.\+e. 

it writes the encoded token to the output. The encoder writes data in the row-\/major order.

Overloaded function to accept vector$<$vector$<$\+Elem\+Type$>$$>$ as the output type.


\begin{DoxyTemplParams}{Template Parameters}
{\em Elem\+Type} & Type of the output values.\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em output} & Output matrix to store the encoded results. \\
\hline
{\em value} & The encoded token. \\
\hline
{\em line} & The line number at which the encoding is performed. \\
\hline
{\em $\ast$} & (index) The token index in the line. \\
\hline
\end{DoxyParams}


Definition at line 180 of file tf\+\_\+idf\+\_\+encoding\+\_\+policy.\+hpp.

\mbox{\label{classmlpack_1_1data_1_1TfIdfEncodingPolicy_a4e2c846435f9d535401110a83555d2ca}} 
\index{TfIdfEncodingPolicy@{TfIdfEncodingPolicy}!InitMatrix@{InitMatrix}}
\index{InitMatrix@{InitMatrix}!TfIdfEncodingPolicy@{TfIdfEncodingPolicy}}
\doxysubsubsection{InitMatrix()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static void Init\+Matrix (\begin{DoxyParamCaption}\item[{Mat\+Type \&}]{output,  }\item[{const size\+\_\+t}]{dataset\+Size,  }\item[{const}]{size\+\_\+t,  }\item[{const size\+\_\+t}]{dictionary\+Size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}



The function initializes the output matrix. 

The encoder writes data in the row-\/major order.


\begin{DoxyTemplParams}{Template Parameters}
{\em Mat\+Type} & The output matrix type.\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em output} & Output matrix to store the encoded results (sp\+\_\+mat or mat). \\
\hline
{\em dataset\+Size} & The number of strings in the input dataset. \\
\hline
{\em $\ast$} & (max\+Num\+Tokens) The maximum number of tokens in the strings of the input dataset (not used). \\
\hline
{\em dictionary\+Size} & The size of the dictionary. \\
\hline
\end{DoxyParams}


Definition at line 104 of file tf\+\_\+idf\+\_\+encoding\+\_\+policy.\+hpp.

\mbox{\label{classmlpack_1_1data_1_1TfIdfEncodingPolicy_a44833b2c5967e5805ddfd5e0abbbd981}} 
\index{TfIdfEncodingPolicy@{TfIdfEncodingPolicy}!InitMatrix@{InitMatrix}}
\index{InitMatrix@{InitMatrix}!TfIdfEncodingPolicy@{TfIdfEncodingPolicy}}
\doxysubsubsection{InitMatrix()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static void Init\+Matrix (\begin{DoxyParamCaption}\item[{std\+::vector$<$ std\+::vector$<$ Elem\+Type $>$$>$ \&}]{output,  }\item[{const size\+\_\+t}]{dataset\+Size,  }\item[{const}]{size\+\_\+t,  }\item[{const size\+\_\+t}]{dictionary\+Size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}



The function initializes the output matrix. 

The encoder writes data in the row-\/major order.

Overloaded function to save the result in vector$<$vector$<$\+Elem\+Type$>$$>$.


\begin{DoxyTemplParams}{Template Parameters}
{\em Elem\+Type} & Type of the output values.\\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}{Parameters}
{\em output} & Output matrix to store the encoded results. \\
\hline
{\em dataset\+Size} & The number of strings in the input dataset. \\
\hline
{\em $\ast$} & (max\+Num\+Tokens) The maximum number of tokens in the strings of the input dataset (not used). \\
\hline
{\em dictionary\+Size} & The size of the dictionary. \\
\hline
\end{DoxyParams}


Definition at line 127 of file tf\+\_\+idf\+\_\+encoding\+\_\+policy.\+hpp.

\mbox{\label{classmlpack_1_1data_1_1TfIdfEncodingPolicy_a0d1ae8522e5b79e9d6948c525978bf21}} 
\index{TfIdfEncodingPolicy@{TfIdfEncodingPolicy}!LinesSizes@{LinesSizes}}
\index{LinesSizes@{LinesSizes}!TfIdfEncodingPolicy@{TfIdfEncodingPolicy}}
\doxysubsubsection{LinesSizes()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily std\+::vector$<$size\+\_\+t$>$\& Lines\+Sizes (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Modify the lines sizes. 



Definition at line 244 of file tf\+\_\+idf\+\_\+encoding\+\_\+policy.\+hpp.

\mbox{\label{classmlpack_1_1data_1_1TfIdfEncodingPolicy_a9eb9be1df25db8022278d09cc6184e52}} 
\index{TfIdfEncodingPolicy@{TfIdfEncodingPolicy}!LinesSizes@{LinesSizes}}
\index{LinesSizes@{LinesSizes}!TfIdfEncodingPolicy@{TfIdfEncodingPolicy}}
\doxysubsubsection{LinesSizes()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily const std\+::vector$<$size\+\_\+t$>$\& Lines\+Sizes (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Return the lines sizes. 



Definition at line 242 of file tf\+\_\+idf\+\_\+encoding\+\_\+policy.\+hpp.

\mbox{\label{classmlpack_1_1data_1_1TfIdfEncodingPolicy_ad17a5b987cd720225c6eb891b5185748}} 
\index{TfIdfEncodingPolicy@{TfIdfEncodingPolicy}!NumContainingStrings@{NumContainingStrings}}
\index{NumContainingStrings@{NumContainingStrings}!TfIdfEncodingPolicy@{TfIdfEncodingPolicy}}
\doxysubsubsection{NumContainingStrings()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily std\+::unordered\+\_\+map$<$size\+\_\+t, size\+\_\+t$>$\& Num\+Containing\+Strings (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Modify the number of containing strings depending on the given token. 



Definition at line 236 of file tf\+\_\+idf\+\_\+encoding\+\_\+policy.\+hpp.

\mbox{\label{classmlpack_1_1data_1_1TfIdfEncodingPolicy_a6a30fb7ebe89eff5005693c1494faa9b}} 
\index{TfIdfEncodingPolicy@{TfIdfEncodingPolicy}!NumContainingStrings@{NumContainingStrings}}
\index{NumContainingStrings@{NumContainingStrings}!TfIdfEncodingPolicy@{TfIdfEncodingPolicy}}
\doxysubsubsection{NumContainingStrings()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily const std\+::unordered\+\_\+map$<$size\+\_\+t, size\+\_\+t$>$\& Num\+Containing\+Strings (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Get the number of containing strings depending on the given token. 



Definition at line 230 of file tf\+\_\+idf\+\_\+encoding\+\_\+policy.\+hpp.

\mbox{\label{classmlpack_1_1data_1_1TfIdfEncodingPolicy_a306d7db4143a8fc05c5a9ff550362414}} 
\index{TfIdfEncodingPolicy@{TfIdfEncodingPolicy}!PreprocessToken@{PreprocessToken}}
\index{PreprocessToken@{PreprocessToken}!TfIdfEncodingPolicy@{TfIdfEncodingPolicy}}
\doxysubsubsection{PreprocessToken()}
{\footnotesize\ttfamily void Preprocess\+Token (\begin{DoxyParamCaption}\item[{const size\+\_\+t}]{line,  }\item[{const}]{size\+\_\+t,  }\item[{const size\+\_\+t}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Definition at line 202 of file tf\+\_\+idf\+\_\+encoding\+\_\+policy.\+hpp.

\mbox{\label{classmlpack_1_1data_1_1TfIdfEncodingPolicy_a372de693ad40b3f42839c8ec6ac845f4}} 
\index{TfIdfEncodingPolicy@{TfIdfEncodingPolicy}!Reset@{Reset}}
\index{Reset@{Reset}!TfIdfEncodingPolicy@{TfIdfEncodingPolicy}}
\doxysubsubsection{Reset()}
{\footnotesize\ttfamily void Reset (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Clear the necessary internal variables. 



Definition at line 84 of file tf\+\_\+idf\+\_\+encoding\+\_\+policy.\+hpp.

\mbox{\label{classmlpack_1_1data_1_1TfIdfEncodingPolicy_a65cba07328997659bec80b9879b15a51}} 
\index{TfIdfEncodingPolicy@{TfIdfEncodingPolicy}!serialize@{serialize}}
\index{serialize@{serialize}!TfIdfEncodingPolicy@{TfIdfEncodingPolicy}}
\doxysubsubsection{serialize()}
{\footnotesize\ttfamily void serialize (\begin{DoxyParamCaption}\item[{Archive \&}]{ar,  }\item[{const uint32\+\_\+t}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Serialize the class to the given archive. 



Definition at line 260 of file tf\+\_\+idf\+\_\+encoding\+\_\+policy.\+hpp.

\mbox{\label{classmlpack_1_1data_1_1TfIdfEncodingPolicy_a5f69d3b7af4afaacc72d5f6ad6f2f35f}} 
\index{TfIdfEncodingPolicy@{TfIdfEncodingPolicy}!SmoothIdf@{SmoothIdf}}
\index{SmoothIdf@{SmoothIdf}!TfIdfEncodingPolicy@{TfIdfEncodingPolicy}}
\doxysubsubsection{SmoothIdf()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily bool\& Smooth\+Idf (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Modify the idf algorithm type (whether it\textquotesingle{}s smooth or not). 



Definition at line 254 of file tf\+\_\+idf\+\_\+encoding\+\_\+policy.\+hpp.

\mbox{\label{classmlpack_1_1data_1_1TfIdfEncodingPolicy_a888a84e90e38265bf460bacf545ee85c}} 
\index{TfIdfEncodingPolicy@{TfIdfEncodingPolicy}!SmoothIdf@{SmoothIdf}}
\index{SmoothIdf@{SmoothIdf}!TfIdfEncodingPolicy@{TfIdfEncodingPolicy}}
\doxysubsubsection{SmoothIdf()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily bool Smooth\+Idf (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Determine the idf algorithm type (whether it\textquotesingle{}s smooth or not). 



Definition at line 252 of file tf\+\_\+idf\+\_\+encoding\+\_\+policy.\+hpp.

\mbox{\label{classmlpack_1_1data_1_1TfIdfEncodingPolicy_acd741559ad8ff165f251dd4e1cf8ac61}} 
\index{TfIdfEncodingPolicy@{TfIdfEncodingPolicy}!TfType@{TfType}}
\index{TfType@{TfType}!TfIdfEncodingPolicy@{TfIdfEncodingPolicy}}
\doxysubsubsection{TfType()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \textbf{ Tf\+Types}\& Tf\+Type (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Modify the term frequency type. 



Definition at line 249 of file tf\+\_\+idf\+\_\+encoding\+\_\+policy.\+hpp.

\mbox{\label{classmlpack_1_1data_1_1TfIdfEncodingPolicy_a9ae26149291cb921852ffe5abbf4ca15}} 
\index{TfIdfEncodingPolicy@{TfIdfEncodingPolicy}!TfType@{TfType}}
\index{TfType@{TfType}!TfIdfEncodingPolicy@{TfIdfEncodingPolicy}}
\doxysubsubsection{TfType()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \textbf{ Tf\+Types} Tf\+Type (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Return the term frequency type. 



Definition at line 247 of file tf\+\_\+idf\+\_\+encoding\+\_\+policy.\+hpp.

\mbox{\label{classmlpack_1_1data_1_1TfIdfEncodingPolicy_a31e3c3de7dbe3012c83a012bf765a335}} 
\index{TfIdfEncodingPolicy@{TfIdfEncodingPolicy}!TokensFrequences@{TokensFrequences}}
\index{TokensFrequences@{TokensFrequences}!TfIdfEncodingPolicy@{TfIdfEncodingPolicy}}
\doxysubsubsection{TokensFrequences()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily std\+::vector$<$std\+::unordered\+\_\+map$<$size\+\_\+t, size\+\_\+t$>$ $>$\& Tokens\+Frequences (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Modify token frequencies. 



Definition at line 224 of file tf\+\_\+idf\+\_\+encoding\+\_\+policy.\+hpp.

\mbox{\label{classmlpack_1_1data_1_1TfIdfEncodingPolicy_afc6375981a9925ca23df9671fa473fd0}} 
\index{TfIdfEncodingPolicy@{TfIdfEncodingPolicy}!TokensFrequences@{TokensFrequences}}
\index{TokensFrequences@{TokensFrequences}!TfIdfEncodingPolicy@{TfIdfEncodingPolicy}}
\doxysubsubsection{TokensFrequences()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily const std\+::vector$<$std\+::unordered\+\_\+map$<$size\+\_\+t, size\+\_\+t$>$ $>$\& Tokens\+Frequences (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Return token frequencies. 



Definition at line 222 of file tf\+\_\+idf\+\_\+encoding\+\_\+policy.\+hpp.



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/home/aakash/mlpack/src/mlpack/core/data/string\+\_\+encoding\+\_\+policies/\textbf{ tf\+\_\+idf\+\_\+encoding\+\_\+policy.\+hpp}\end{DoxyCompactItemize}
