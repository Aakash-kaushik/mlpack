\doxysection{mlpack\+::kmeans Namespace Reference}
\label{namespacemlpack_1_1kmeans}\index{mlpack::kmeans@{mlpack::kmeans}}


K-\/\+Means clustering.  


\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \textbf{ Allow\+Empty\+Clusters}
\begin{DoxyCompactList}\small\item\em Policy which allows K-\/\+Means to create empty clusters without any error being reported. \end{DoxyCompactList}\item 
class \textbf{ Dual\+Tree\+KMeans}
\begin{DoxyCompactList}\small\item\em An algorithm for an exact Lloyd iteration which simply uses dual-\/tree nearest-\/neighbor search to find the nearest centroid for each point in the dataset. \end{DoxyCompactList}\item 
class \textbf{ Dual\+Tree\+KMeans\+Rules}
\item 
class \textbf{ Dual\+Tree\+KMeans\+Statistic}
\item 
class \textbf{ Elkan\+KMeans}
\item 
class \textbf{ Hamerly\+KMeans}
\item 
class \textbf{ Kill\+Empty\+Clusters}
\begin{DoxyCompactList}\small\item\em Policy which allows K-\/\+Means to \char`\"{}kill\char`\"{} empty clusters without any error being reported. \end{DoxyCompactList}\item 
class \textbf{ KMeans}
\begin{DoxyCompactList}\small\item\em This class implements K-\/\+Means clustering, using a variety of possible implementations of Lloyd\textquotesingle{}s algorithm. \end{DoxyCompactList}\item 
class \textbf{ Max\+Variance\+New\+Cluster}
\begin{DoxyCompactList}\small\item\em When an empty cluster is detected, this class takes the point furthest from the centroid of the cluster with maximum variance as a new cluster. \end{DoxyCompactList}\item 
class \textbf{ Naive\+KMeans}
\begin{DoxyCompactList}\small\item\em This is an implementation of a single iteration of Lloyd\textquotesingle{}s algorithm for k-\/means. \end{DoxyCompactList}\item 
class \textbf{ Pelleg\+Moore\+KMeans}
\begin{DoxyCompactList}\small\item\em An implementation of Pelleg-\/\+Moore\textquotesingle{}s \textquotesingle{}blacklist\textquotesingle{} algorithm for k-\/means clustering. \end{DoxyCompactList}\item 
class \textbf{ Pelleg\+Moore\+KMeans\+Rules}
\begin{DoxyCompactList}\small\item\em The rules class for the single-\/tree Pelleg-\/\+Moore kd-\/tree traversal for k-\/means clustering. \end{DoxyCompactList}\item 
class \textbf{ Pelleg\+Moore\+KMeans\+Statistic}
\begin{DoxyCompactList}\small\item\em A statistic for trees which holds the blacklist for Pelleg-\/\+Moore k-\/means clustering (which represents the clusters that cannot possibly own any points in a node). \end{DoxyCompactList}\item 
class \textbf{ Random\+Partition}
\begin{DoxyCompactList}\small\item\em A very simple partitioner which partitions the data randomly into the number of desired clusters. \end{DoxyCompactList}\item 
class \textbf{ Refined\+Start}
\begin{DoxyCompactList}\small\item\em A refined approach for choosing initial points for k-\/means clustering. \end{DoxyCompactList}\item 
class \textbf{ Sample\+Initialization}
\end{DoxyCompactItemize}
\doxysubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename Metric\+Type , typename Mat\+Type $>$ }\\using \textbf{ Cover\+Tree\+Dual\+Tree\+KMeans} = \textbf{ Dual\+Tree\+KMeans}$<$ Metric\+Type, Mat\+Type, \textbf{ tree\+::\+Standard\+Cover\+Tree} $>$
\begin{DoxyCompactList}\small\item\em A template typedef for the \doxyref{Dual\+Tree\+KMeans}{p.}{classmlpack_1_1kmeans_1_1DualTreeKMeans} algorithm with the cover tree type. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Metric\+Type , typename Mat\+Type $>$ }\\using \textbf{ Default\+Dual\+Tree\+KMeans} = \textbf{ Dual\+Tree\+KMeans}$<$ Metric\+Type, Mat\+Type $>$
\begin{DoxyCompactList}\small\item\em A template typedef for the \doxyref{Dual\+Tree\+KMeans}{p.}{classmlpack_1_1kmeans_1_1DualTreeKMeans} algorithm with the default tree type (a kd-\/tree). \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$typename Tree\+Type $>$ }\\void \textbf{ Hide\+Child} (Tree\+Type \&node, const size\+\_\+t child, const typename \textbf{ std\+::enable\+\_\+if\+\_\+t}$<$ !\textbf{ tree\+::\+Tree\+Traits}$<$ Tree\+Type $>$\+::Binary\+Tree $>$ $\ast$junk=0)
\begin{DoxyCompactList}\small\item\em Utility function for hiding children. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Tree\+Type $>$ }\\void \textbf{ Hide\+Child} (Tree\+Type \&node, const size\+\_\+t child, const typename \textbf{ std\+::enable\+\_\+if\+\_\+t}$<$ \textbf{ tree\+::\+Tree\+Traits}$<$ Tree\+Type $>$\+::Binary\+Tree $>$ $\ast$junk=0)
\begin{DoxyCompactList}\small\item\em Utility function for hiding children. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Tree\+Type $>$ }\\void \textbf{ Restore\+Children} (Tree\+Type \&node, const typename \textbf{ std\+::enable\+\_\+if\+\_\+t}$<$ \textbf{ tree\+::\+Tree\+Traits}$<$ Tree\+Type $>$\+::Binary\+Tree $>$ $\ast$junk=0)
\begin{DoxyCompactList}\small\item\em Utility function for restoring children to a binary tree. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Tree\+Type $>$ }\\void \textbf{ Restore\+Children} (Tree\+Type \&node, const typename \textbf{ std\+::enable\+\_\+if\+\_\+t}$<$!\textbf{ tree\+::\+Tree\+Traits}$<$ Tree\+Type $>$\+::Binary\+Tree $>$ $\ast$junk=0)
\begin{DoxyCompactList}\small\item\em Utility function for restoring children to a non-\/binary tree. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
K-\/\+Means clustering. 

\doxysubsection{Typedef Documentation}
\mbox{\label{namespacemlpack_1_1kmeans_a050f8eba1b8d0c72e990a9ee3b7ed775}} 
\index{mlpack::kmeans@{mlpack::kmeans}!CoverTreeDualTreeKMeans@{CoverTreeDualTreeKMeans}}
\index{CoverTreeDualTreeKMeans@{CoverTreeDualTreeKMeans}!mlpack::kmeans@{mlpack::kmeans}}
\doxysubsubsection{CoverTreeDualTreeKMeans}
{\footnotesize\ttfamily using \textbf{ Cover\+Tree\+Dual\+Tree\+KMeans} =  \textbf{ Dual\+Tree\+KMeans}$<$Metric\+Type, Mat\+Type, \textbf{ tree\+::\+Standard\+Cover\+Tree}$>$}



A template typedef for the \doxyref{Dual\+Tree\+KMeans}{p.}{classmlpack_1_1kmeans_1_1DualTreeKMeans} algorithm with the cover tree type. 



Definition at line 169 of file dual\+\_\+tree\+\_\+kmeans.\+hpp.

\mbox{\label{namespacemlpack_1_1kmeans_a3d8c82eb428be782996066d70afc122b}} 
\index{mlpack::kmeans@{mlpack::kmeans}!DefaultDualTreeKMeans@{DefaultDualTreeKMeans}}
\index{DefaultDualTreeKMeans@{DefaultDualTreeKMeans}!mlpack::kmeans@{mlpack::kmeans}}
\doxysubsubsection{DefaultDualTreeKMeans}
{\footnotesize\ttfamily using \textbf{ Default\+Dual\+Tree\+KMeans} =  \textbf{ Dual\+Tree\+KMeans}$<$Metric\+Type, Mat\+Type$>$}



A template typedef for the \doxyref{Dual\+Tree\+KMeans}{p.}{classmlpack_1_1kmeans_1_1DualTreeKMeans} algorithm with the default tree type (a kd-\/tree). 



Definition at line 164 of file dual\+\_\+tree\+\_\+kmeans.\+hpp.



\doxysubsection{Function Documentation}
\mbox{\label{namespacemlpack_1_1kmeans_ae824715a9723b95291ede5396d7ec48a}} 
\index{mlpack::kmeans@{mlpack::kmeans}!HideChild@{HideChild}}
\index{HideChild@{HideChild}!mlpack::kmeans@{mlpack::kmeans}}
\doxysubsubsection{HideChild()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void mlpack\+::kmeans\+::\+Hide\+Child (\begin{DoxyParamCaption}\item[{Tree\+Type \&}]{node,  }\item[{const size\+\_\+t}]{child,  }\item[{const typename \textbf{ std\+::enable\+\_\+if\+\_\+t}$<$ !\textbf{ tree\+::\+Tree\+Traits}$<$ Tree\+Type $>$\+::Binary\+Tree $>$ $\ast$}]{junk = {\ttfamily 0} }\end{DoxyParamCaption})}



Utility function for hiding children. 

This actually does something, and is called if the tree is not a binary tree. \mbox{\label{namespacemlpack_1_1kmeans_ad50ab0e1083d84c7f78a79f2bdaec558}} 
\index{mlpack::kmeans@{mlpack::kmeans}!HideChild@{HideChild}}
\index{HideChild@{HideChild}!mlpack::kmeans@{mlpack::kmeans}}
\doxysubsubsection{HideChild()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void mlpack\+::kmeans\+::\+Hide\+Child (\begin{DoxyParamCaption}\item[{Tree\+Type \&}]{node,  }\item[{const size\+\_\+t}]{child,  }\item[{const typename \textbf{ std\+::enable\+\_\+if\+\_\+t}$<$ \textbf{ tree\+::\+Tree\+Traits}$<$ Tree\+Type $>$\+::Binary\+Tree $>$ $\ast$}]{junk = {\ttfamily 0} }\end{DoxyParamCaption})}



Utility function for hiding children. 

This is called when the tree is a binary tree, and does nothing, because we don\textquotesingle{}t hide binary children in this way. \mbox{\label{namespacemlpack_1_1kmeans_aef92bb2544a815fc97f3c79070e5d3c0}} 
\index{mlpack::kmeans@{mlpack::kmeans}!RestoreChildren@{RestoreChildren}}
\index{RestoreChildren@{RestoreChildren}!mlpack::kmeans@{mlpack::kmeans}}
\doxysubsubsection{RestoreChildren()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void mlpack\+::kmeans\+::\+Restore\+Children (\begin{DoxyParamCaption}\item[{Tree\+Type \&}]{node,  }\item[{const typename \textbf{ std\+::enable\+\_\+if\+\_\+t}$<$ \textbf{ tree\+::\+Tree\+Traits}$<$ Tree\+Type $>$\+::Binary\+Tree $>$ $\ast$}]{junk = {\ttfamily 0} }\end{DoxyParamCaption})}



Utility function for restoring children to a binary tree. 

\mbox{\label{namespacemlpack_1_1kmeans_ab8a2dc63dd61b947e7b90e03d31d64c0}} 
\index{mlpack::kmeans@{mlpack::kmeans}!RestoreChildren@{RestoreChildren}}
\index{RestoreChildren@{RestoreChildren}!mlpack::kmeans@{mlpack::kmeans}}
\doxysubsubsection{RestoreChildren()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void mlpack\+::kmeans\+::\+Restore\+Children (\begin{DoxyParamCaption}\item[{Tree\+Type \&}]{node,  }\item[{const typename \textbf{ std\+::enable\+\_\+if\+\_\+t}$<$!\textbf{ tree\+::\+Tree\+Traits}$<$ Tree\+Type $>$\+::Binary\+Tree $>$ $\ast$}]{junk = {\ttfamily 0} }\end{DoxyParamCaption})}



Utility function for restoring children to a non-\/binary tree. 

