\doxysection{mlpack\+::neighbor Namespace Reference}
\label{namespacemlpack_1_1neighbor}\index{mlpack::neighbor@{mlpack::neighbor}}
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \textbf{ Drusilla\+Select}
\item 
class \textbf{ Furthest\+NS}
\begin{DoxyCompactList}\small\item\em This class implements the necessary methods for the Sort\+Policy template parameter of the \doxyref{Neighbor\+Search}{p.}{classmlpack_1_1neighbor_1_1NeighborSearch} class. \end{DoxyCompactList}\item 
class \textbf{ Leaf\+Size\+NSWrapper}
\begin{DoxyCompactList}\small\item\em \doxyref{Leaf\+Size\+NSWrapper}{p.}{classmlpack_1_1neighbor_1_1LeafSizeNSWrapper} wraps any \doxyref{Neighbor\+Search}{p.}{classmlpack_1_1neighbor_1_1NeighborSearch} types that take a leaf size for tree construction. \end{DoxyCompactList}\item 
class \textbf{ Leaf\+Size\+RAWrapper}
\begin{DoxyCompactList}\small\item\em \doxyref{Leaf\+Size\+RAWrapper}{p.}{classmlpack_1_1neighbor_1_1LeafSizeRAWrapper} wraps any \doxyref{RASearch}{p.}{classmlpack_1_1neighbor_1_1RASearch} type that needs to be able to take the leaf size into account when building trees. \end{DoxyCompactList}\item 
class \textbf{ LSHSearch}
\begin{DoxyCompactList}\small\item\em The \doxyref{LSHSearch}{p.}{classmlpack_1_1neighbor_1_1LSHSearch} class; this class builds a hash on the reference set and uses this hash to compute the distance-\/approximate nearest-\/neighbors of the given queries. \end{DoxyCompactList}\item 
class \textbf{ Nearest\+NS}
\begin{DoxyCompactList}\small\item\em This class implements the necessary methods for the Sort\+Policy template parameter of the \doxyref{Neighbor\+Search}{p.}{classmlpack_1_1neighbor_1_1NeighborSearch} class. \end{DoxyCompactList}\item 
class \textbf{ Neighbor\+Search}
\begin{DoxyCompactList}\small\item\em The \doxyref{Neighbor\+Search}{p.}{classmlpack_1_1neighbor_1_1NeighborSearch} class is a template class for performing distance-\/based neighbor searches. \end{DoxyCompactList}\item 
class \textbf{ Neighbor\+Search\+Rules}
\begin{DoxyCompactList}\small\item\em The \doxyref{Neighbor\+Search\+Rules}{p.}{classmlpack_1_1neighbor_1_1NeighborSearchRules} class is a template helper class used by \doxyref{Neighbor\+Search}{p.}{classmlpack_1_1neighbor_1_1NeighborSearch} class when performing distance-\/based neighbor searches. \end{DoxyCompactList}\item 
class \textbf{ Neighbor\+Search\+Stat}
\begin{DoxyCompactList}\small\item\em Extra data for each node in the tree. \end{DoxyCompactList}\item 
class \textbf{ NSModel}
\begin{DoxyCompactList}\small\item\em The \doxyref{NSModel}{p.}{classmlpack_1_1neighbor_1_1NSModel} class provides an easy way to serialize a model, abstracts away the different types of trees, and also reflects the \doxyref{Neighbor\+Search}{p.}{classmlpack_1_1neighbor_1_1NeighborSearch} API. \end{DoxyCompactList}\item 
class \textbf{ NSWrapper}
\begin{DoxyCompactList}\small\item\em \doxyref{NSWrapper}{p.}{classmlpack_1_1neighbor_1_1NSWrapper} is a wrapper class for most \doxyref{Neighbor\+Search}{p.}{classmlpack_1_1neighbor_1_1NeighborSearch} types. \end{DoxyCompactList}\item 
class \textbf{ NSWrapper\+Base}
\begin{DoxyCompactList}\small\item\em \doxyref{NSWrapper\+Base}{p.}{classmlpack_1_1neighbor_1_1NSWrapperBase} is a base wrapper class for holding all \doxyref{Neighbor\+Search}{p.}{classmlpack_1_1neighbor_1_1NeighborSearch} types supported by \doxyref{NSModel}{p.}{classmlpack_1_1neighbor_1_1NSModel}. \end{DoxyCompactList}\item 
class \textbf{ QDAFN}
\item 
class \textbf{ RAModel}
\begin{DoxyCompactList}\small\item\em The \doxyref{RAModel}{p.}{classmlpack_1_1neighbor_1_1RAModel} class provides an abstraction for the \doxyref{RASearch}{p.}{classmlpack_1_1neighbor_1_1RASearch} class, abstracting away the Tree\+Type parameter and allowing it to be specified at runtime in this class. \end{DoxyCompactList}\item 
class \textbf{ RAQuery\+Stat}
\begin{DoxyCompactList}\small\item\em Extra data for each node in the tree. \end{DoxyCompactList}\item 
class \textbf{ RASearch}
\begin{DoxyCompactList}\small\item\em The \doxyref{RASearch}{p.}{classmlpack_1_1neighbor_1_1RASearch} class\+: This class provides a generic manner to perform rank-\/approximate search via random-\/sampling. \end{DoxyCompactList}\item 
class \textbf{ RASearch\+Rules}
\begin{DoxyCompactList}\small\item\em The \doxyref{RASearch\+Rules}{p.}{classmlpack_1_1neighbor_1_1RASearchRules} class is a template helper class used by \doxyref{RASearch}{p.}{classmlpack_1_1neighbor_1_1RASearch} class when performing rank-\/approximate search via random-\/sampling. \end{DoxyCompactList}\item 
class \textbf{ RAUtil}
\item 
class \textbf{ RAWrapper}
\begin{DoxyCompactList}\small\item\em \doxyref{RAWrapper}{p.}{classmlpack_1_1neighbor_1_1RAWrapper} is a wrapper class for most \doxyref{RASearch}{p.}{classmlpack_1_1neighbor_1_1RASearch} types. \end{DoxyCompactList}\item 
class \textbf{ RAWrapper\+Base}
\begin{DoxyCompactList}\small\item\em \doxyref{RAWrapper\+Base}{p.}{classmlpack_1_1neighbor_1_1RAWrapperBase} is a base wrapper class for holding all \doxyref{RASearch}{p.}{classmlpack_1_1neighbor_1_1RASearch} types supported by \doxyref{RAModel}{p.}{classmlpack_1_1neighbor_1_1RAModel}. \end{DoxyCompactList}\item 
class \textbf{ Spill\+NSWrapper}
\begin{DoxyCompactList}\small\item\em The \doxyref{Spill\+NSWrapper}{p.}{classmlpack_1_1neighbor_1_1SpillNSWrapper} class wraps the \doxyref{Neighbor\+Search}{p.}{classmlpack_1_1neighbor_1_1NeighborSearch} class when the spill tree is used. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$template$<$ typename Tree\+Metric\+Type, typename Tree\+Stat\+Type, typename Tree\+Mat\+Type $>$ class Tree\+Type = tree\+::\+SPTree$>$ }\\using \textbf{ Defeatist\+KNN} = \textbf{ Neighbor\+Search}$<$ \textbf{ Nearest\+Neighbor\+Sort}, \textbf{ metric\+::\+Euclidean\+Distance}, arma\+::mat, Tree\+Type, Tree\+Type$<$ \textbf{ metric\+::\+Euclidean\+Distance}, \textbf{ Neighbor\+Search\+Stat}$<$ \textbf{ Nearest\+Neighbor\+Sort} $>$, arma\+::mat $>$\+::template Defeatist\+Dual\+Tree\+Traverser, Tree\+Type$<$ \textbf{ metric\+::\+Euclidean\+Distance}, \textbf{ Neighbor\+Search\+Stat}$<$ \textbf{ Nearest\+Neighbor\+Sort} $>$, arma\+::mat $>$\+::template Defeatist\+Single\+Tree\+Traverser $>$
\begin{DoxyCompactList}\small\item\em The Defeatist\+KNN class is the k-\/nearest-\/neighbors method considering defeatist search. \end{DoxyCompactList}\item 
using \textbf{ Furthest\+Neighbor\+Sort} = \textbf{ Furthest\+NS}
\item 
typedef \textbf{ Neighbor\+Search}$<$ \textbf{ Furthest\+Neighbor\+Sort}, \textbf{ metric\+::\+Euclidean\+Distance} $>$ \textbf{ KFN}
\begin{DoxyCompactList}\small\item\em The KFN class is the k-\/furthest-\/neighbors method. \end{DoxyCompactList}\item 
typedef \textbf{ Neighbor\+Search}$<$ \textbf{ Nearest\+Neighbor\+Sort}, \textbf{ metric\+::\+Euclidean\+Distance} $>$ \textbf{ KNN}
\begin{DoxyCompactList}\small\item\em The KNN class is the k-\/nearest-\/neighbors method. \end{DoxyCompactList}\item 
typedef \textbf{ RASearch}$<$ \textbf{ Furthest\+Neighbor\+Sort} $>$ \textbf{ KRAFN}
\begin{DoxyCompactList}\small\item\em The KRAFN class is the k-\/rank-\/approximate-\/farthest-\/neighbors method. \end{DoxyCompactList}\item 
typedef \textbf{ RASearch} \textbf{ KRANN}
\begin{DoxyCompactList}\small\item\em The KRANN class is the k-\/rank-\/approximate-\/nearest-\/neighbors method. \end{DoxyCompactList}\item 
using \textbf{ Nearest\+Neighbor\+Sort} = \textbf{ Nearest\+NS}
\item 
typedef \textbf{ Defeatist\+KNN}$<$ \textbf{ tree\+::\+SPTree} $>$ \textbf{ Spill\+KNN}
\begin{DoxyCompactList}\small\item\em The Spill\+KNN class is the k-\/nearest-\/neighbors method considering defeatist search on SPTree. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum \textbf{ Neighbor\+Search\+Mode} \{ \newline
\textbf{ NAIVE\+\_\+\+MODE}
, \newline
\textbf{ SINGLE\+\_\+\+TREE\+\_\+\+MODE}
, \newline
\textbf{ DUAL\+\_\+\+TREE\+\_\+\+MODE}
, \newline
\textbf{ GREEDY\+\_\+\+SINGLE\+\_\+\+TREE\+\_\+\+MODE}
 \}
\begin{DoxyCompactList}\small\item\em Neighbor\+Search\+Mode represents the different neighbor search modes available. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \textbf{ Unmap} (const arma\+::\+Mat$<$ size\+\_\+t $>$ \&neighbors, const arma\+::mat \&distances, const std\+::vector$<$ size\+\_\+t $>$ \&reference\+Map, arma\+::\+Mat$<$ size\+\_\+t $>$ \&neighbors\+Out, arma\+::mat \&distances\+Out, const bool square\+Root=false)
\begin{DoxyCompactList}\small\item\em Assuming that the datasets have been mapped using reference\+Map (such as during kd-\/tree construction), unmap the columns of the distances and neighbors matrices into neighbors\+Out and distances\+Out, and also unmap the entries in each row of neighbors. \end{DoxyCompactList}\item 
void \textbf{ Unmap} (const arma\+::\+Mat$<$ size\+\_\+t $>$ \&neighbors, const arma\+::mat \&distances, const std\+::vector$<$ size\+\_\+t $>$ \&reference\+Map, const std\+::vector$<$ size\+\_\+t $>$ \&query\+Map, arma\+::\+Mat$<$ size\+\_\+t $>$ \&neighbors\+Out, arma\+::mat \&distances\+Out, const bool square\+Root=false)
\begin{DoxyCompactList}\small\item\em Assuming that the datasets have been mapped using the reference\+Map and the query\+Map (such as during kd-\/tree construction), unmap the columns of the distances and neighbors matrices into neighbors\+Out and distances\+Out, and also unmap the entries in each row of neighbors. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Typedef Documentation}
\mbox{\label{namespacemlpack_1_1neighbor_afbd38e2fcbd26067f08c2e5cabbcb232}} 
\index{mlpack::neighbor@{mlpack::neighbor}!DefeatistKNN@{DefeatistKNN}}
\index{DefeatistKNN@{DefeatistKNN}!mlpack::neighbor@{mlpack::neighbor}}
\doxysubsubsection{DefeatistKNN}
{\footnotesize\ttfamily using \textbf{ Defeatist\+KNN} =  \textbf{ Neighbor\+Search}$<$ \textbf{ Nearest\+Neighbor\+Sort}, \textbf{ metric\+::\+Euclidean\+Distance}, arma\+::mat, Tree\+Type, Tree\+Type$<$\textbf{ metric\+::\+Euclidean\+Distance}, \textbf{ Neighbor\+Search\+Stat}$<$\textbf{ Nearest\+Neighbor\+Sort}$>$, arma\+::mat$>$\+::template Defeatist\+Dual\+Tree\+Traverser, Tree\+Type$<$\textbf{ metric\+::\+Euclidean\+Distance}, \textbf{ Neighbor\+Search\+Stat}$<$\textbf{ Nearest\+Neighbor\+Sort}$>$, arma\+::mat$>$\+::template Defeatist\+Single\+Tree\+Traverser$>$}



The Defeatist\+KNN class is the k-\/nearest-\/neighbors method considering defeatist search. 

It returns L2 distances (Euclidean distances) for each of the k nearest neighbors found. 
\begin{DoxyTemplParams}{Template Parameters}
{\em Tree\+Type} & The tree type to use; must adhere to the Tree\+Type API, and implement Defeatist Traversers. \\
\hline
\end{DoxyTemplParams}


Definition at line 50 of file typedef.\+hpp.

\mbox{\label{namespacemlpack_1_1neighbor_a690bbbab38fc719071a5c019acd2f947}} 
\index{mlpack::neighbor@{mlpack::neighbor}!FurthestNeighborSort@{FurthestNeighborSort}}
\index{FurthestNeighborSort@{FurthestNeighborSort}!mlpack::neighbor@{mlpack::neighbor}}
\doxysubsubsection{FurthestNeighborSort}
{\footnotesize\ttfamily using \textbf{ Furthest\+Neighbor\+Sort} =  \textbf{ Furthest\+NS}}



Definition at line 201 of file furthest\+\_\+neighbor\+\_\+sort.\+hpp.

\mbox{\label{namespacemlpack_1_1neighbor_abfddff6c92a37aaa0b80d2193ccd71da}} 
\index{mlpack::neighbor@{mlpack::neighbor}!KFN@{KFN}}
\index{KFN@{KFN}!mlpack::neighbor@{mlpack::neighbor}}
\doxysubsubsection{KFN}
{\footnotesize\ttfamily typedef \textbf{ Neighbor\+Search}$<$\textbf{ Furthest\+Neighbor\+Sort}, \textbf{ metric\+::\+Euclidean\+Distance}$>$ \textbf{ KFN}}



The KFN class is the k-\/furthest-\/neighbors method. 

It returns L2 distances (Euclidean distances) for each of the k furthest neighbors. 

Definition at line 38 of file typedef.\+hpp.

\mbox{\label{namespacemlpack_1_1neighbor_ac8d70069e8acb12c5ba9a8536ae6ace4}} 
\index{mlpack::neighbor@{mlpack::neighbor}!KNN@{KNN}}
\index{KNN@{KNN}!mlpack::neighbor@{mlpack::neighbor}}
\doxysubsubsection{KNN}
{\footnotesize\ttfamily typedef \textbf{ Neighbor\+Search}$<$\textbf{ Nearest\+Neighbor\+Sort}, \textbf{ metric\+::\+Euclidean\+Distance}$>$ \textbf{ KNN}}



The KNN class is the k-\/nearest-\/neighbors method. 

It returns L2 distances (Euclidean distances) for each of the k nearest neighbors. 

Definition at line 32 of file typedef.\+hpp.

\mbox{\label{namespacemlpack_1_1neighbor_ad9d67c2e8bcffa41c9be915d6face6f8}} 
\index{mlpack::neighbor@{mlpack::neighbor}!KRAFN@{KRAFN}}
\index{KRAFN@{KRAFN}!mlpack::neighbor@{mlpack::neighbor}}
\doxysubsubsection{KRAFN}
{\footnotesize\ttfamily typedef \textbf{ RASearch}$<$\textbf{ Furthest\+Neighbor\+Sort}$>$ \textbf{ KRAFN}}



The KRAFN class is the k-\/rank-\/approximate-\/farthest-\/neighbors method. 

It returns L2 distances for each of the k rank-\/approximate farthest-\/neighbors.

The approximation is controlled with two parameters (see allkrann\+\_\+main.\+cpp) which can be specified at search time. So the tree building is done only once while the search can be performed multiple times with different approximation levels. 

Definition at line 47 of file ra\+\_\+typedef.\+hpp.

\mbox{\label{namespacemlpack_1_1neighbor_aa72b1c4d0ff59f61a03c7b263a6a02d8}} 
\index{mlpack::neighbor@{mlpack::neighbor}!KRANN@{KRANN}}
\index{KRANN@{KRANN}!mlpack::neighbor@{mlpack::neighbor}}
\doxysubsubsection{KRANN}
{\footnotesize\ttfamily typedef \textbf{ RASearch} \textbf{ KRANN}}



The KRANN class is the k-\/rank-\/approximate-\/nearest-\/neighbors method. 

It returns L2 distances for each of the k rank-\/approximate nearest-\/neighbors.

The approximation is controlled with two parameters (see allkrann\+\_\+main.\+cpp) which can be specified at search time. So the tree building is done only once while the search can be performed multiple times with different approximation levels. 

Definition at line 36 of file ra\+\_\+typedef.\+hpp.

\mbox{\label{namespacemlpack_1_1neighbor_af3f11fce33c041aa26b1c91107f71b0f}} 
\index{mlpack::neighbor@{mlpack::neighbor}!NearestNeighborSort@{NearestNeighborSort}}
\index{NearestNeighborSort@{NearestNeighborSort}!mlpack::neighbor@{mlpack::neighbor}}
\doxysubsubsection{NearestNeighborSort}
{\footnotesize\ttfamily using \textbf{ Nearest\+Neighbor\+Sort} =  \textbf{ Nearest\+NS}}



Definition at line 200 of file nearest\+\_\+neighbor\+\_\+sort.\+hpp.

\mbox{\label{namespacemlpack_1_1neighbor_a8145bada084a13663f9e7707f91db6ff}} 
\index{mlpack::neighbor@{mlpack::neighbor}!SpillKNN@{SpillKNN}}
\index{SpillKNN@{SpillKNN}!mlpack::neighbor@{mlpack::neighbor}}
\doxysubsubsection{SpillKNN}
{\footnotesize\ttfamily typedef \textbf{ Defeatist\+KNN}$<$\textbf{ tree\+::\+SPTree}$>$ \textbf{ Spill\+KNN}}



The Spill\+KNN class is the k-\/nearest-\/neighbors method considering defeatist search on SPTree. 

It returns L2 distances (Euclidean distances) for each of the k nearest neighbors found. 

Definition at line 67 of file typedef.\+hpp.



\doxysubsection{Enumeration Type Documentation}
\mbox{\label{namespacemlpack_1_1neighbor_a1a65d2ce978562ab36affdc59938ef15}} 
\index{mlpack::neighbor@{mlpack::neighbor}!NeighborSearchMode@{NeighborSearchMode}}
\index{NeighborSearchMode@{NeighborSearchMode}!mlpack::neighbor@{mlpack::neighbor}}
\doxysubsubsection{NeighborSearchMode}
{\footnotesize\ttfamily enum \textbf{ Neighbor\+Search\+Mode}}



Neighbor\+Search\+Mode represents the different neighbor search modes available. 

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{NAIVE\_MODE@{NAIVE\_MODE}!mlpack::neighbor@{mlpack::neighbor}}\index{mlpack::neighbor@{mlpack::neighbor}!NAIVE\_MODE@{NAIVE\_MODE}}}\mbox{\label{namespacemlpack_1_1neighbor_a1a65d2ce978562ab36affdc59938ef15a84b6e9858a8a0186de25e6ac1b95fce9}} 
NAIVE\+\_\+\+MODE&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{SINGLE\_TREE\_MODE@{SINGLE\_TREE\_MODE}!mlpack::neighbor@{mlpack::neighbor}}\index{mlpack::neighbor@{mlpack::neighbor}!SINGLE\_TREE\_MODE@{SINGLE\_TREE\_MODE}}}\mbox{\label{namespacemlpack_1_1neighbor_a1a65d2ce978562ab36affdc59938ef15a4963da1562f5c21be0ed6f3b4e438f12}} 
SINGLE\+\_\+\+TREE\+\_\+\+MODE&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{DUAL\_TREE\_MODE@{DUAL\_TREE\_MODE}!mlpack::neighbor@{mlpack::neighbor}}\index{mlpack::neighbor@{mlpack::neighbor}!DUAL\_TREE\_MODE@{DUAL\_TREE\_MODE}}}\mbox{\label{namespacemlpack_1_1neighbor_a1a65d2ce978562ab36affdc59938ef15a902f8ca27975735ab2151d26152c6d2a}} 
DUAL\+\_\+\+TREE\+\_\+\+MODE&\\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{GREEDY\_SINGLE\_TREE\_MODE@{GREEDY\_SINGLE\_TREE\_MODE}!mlpack::neighbor@{mlpack::neighbor}}\index{mlpack::neighbor@{mlpack::neighbor}!GREEDY\_SINGLE\_TREE\_MODE@{GREEDY\_SINGLE\_TREE\_MODE}}}\mbox{\label{namespacemlpack_1_1neighbor_a1a65d2ce978562ab36affdc59938ef15a21392e2b53181ee5d4d3402fba104846}} 
GREEDY\+\_\+\+SINGLE\+\_\+\+TREE\+\_\+\+MODE&\\
\hline

\end{DoxyEnumFields}


Definition at line 43 of file neighbor\+\_\+search.\+hpp.



\doxysubsection{Function Documentation}
\mbox{\label{namespacemlpack_1_1neighbor_acc225558031fe27e3336544c50dd642d}} 
\index{mlpack::neighbor@{mlpack::neighbor}!Unmap@{Unmap}}
\index{Unmap@{Unmap}!mlpack::neighbor@{mlpack::neighbor}}
\doxysubsubsection{Unmap()\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void mlpack\+::neighbor\+::\+Unmap (\begin{DoxyParamCaption}\item[{const arma\+::\+Mat$<$ size\+\_\+t $>$ \&}]{neighbors,  }\item[{const arma\+::mat \&}]{distances,  }\item[{const std\+::vector$<$ size\+\_\+t $>$ \&}]{reference\+Map,  }\item[{arma\+::\+Mat$<$ size\+\_\+t $>$ \&}]{neighbors\+Out,  }\item[{arma\+::mat \&}]{distances\+Out,  }\item[{const bool}]{square\+Root = {\ttfamily false} }\end{DoxyParamCaption})}



Assuming that the datasets have been mapped using reference\+Map (such as during kd-\/tree construction), unmap the columns of the distances and neighbors matrices into neighbors\+Out and distances\+Out, and also unmap the entries in each row of neighbors. 

This is useful for the single-\/tree case.


\begin{DoxyParams}{Parameters}
{\em neighbors} & Matrix of neighbors resulting from neighbor search. \\
\hline
{\em distances} & Matrix of distances resulting from neighbor search. \\
\hline
{\em reference\+Map} & Mapping of reference set to old points. \\
\hline
{\em neighbors\+Out} & Matrix to store unmapped neighbors into. \\
\hline
{\em distances\+Out} & Matrix to store unmapped distances into. \\
\hline
{\em square\+Root} & If true, take the square root of the distances. \\
\hline
\end{DoxyParams}
\mbox{\label{namespacemlpack_1_1neighbor_a841bafc12b36517208ff283b095dec2f}} 
\index{mlpack::neighbor@{mlpack::neighbor}!Unmap@{Unmap}}
\index{Unmap@{Unmap}!mlpack::neighbor@{mlpack::neighbor}}
\doxysubsubsection{Unmap()\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void mlpack\+::neighbor\+::\+Unmap (\begin{DoxyParamCaption}\item[{const arma\+::\+Mat$<$ size\+\_\+t $>$ \&}]{neighbors,  }\item[{const arma\+::mat \&}]{distances,  }\item[{const std\+::vector$<$ size\+\_\+t $>$ \&}]{reference\+Map,  }\item[{const std\+::vector$<$ size\+\_\+t $>$ \&}]{query\+Map,  }\item[{arma\+::\+Mat$<$ size\+\_\+t $>$ \&}]{neighbors\+Out,  }\item[{arma\+::mat \&}]{distances\+Out,  }\item[{const bool}]{square\+Root = {\ttfamily false} }\end{DoxyParamCaption})}



Assuming that the datasets have been mapped using the reference\+Map and the query\+Map (such as during kd-\/tree construction), unmap the columns of the distances and neighbors matrices into neighbors\+Out and distances\+Out, and also unmap the entries in each row of neighbors. 

This is useful for the dual-\/tree case.


\begin{DoxyParams}{Parameters}
{\em neighbors} & Matrix of neighbors resulting from neighbor search. \\
\hline
{\em distances} & Matrix of distances resulting from neighbor search. \\
\hline
{\em reference\+Map} & Mapping of reference set to old points. \\
\hline
{\em query\+Map} & Mapping of query set to old points. \\
\hline
{\em neighbors\+Out} & Matrix to store unmapped neighbors into. \\
\hline
{\em distances\+Out} & Matrix to store unmapped distances into. \\
\hline
{\em square\+Root} & If true, take the square root of the distances. \\
\hline
\end{DoxyParams}
