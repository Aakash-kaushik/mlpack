.TH "RectangleTree< MetricType, StatisticType, MatType, SplitType, DescentType, AuxiliaryInformationType >" 3 "Sun Jun 20 2021" "Version 3.4.2" "mlpack" \" -*- nroff -*-
.ad l
.nh
.SH NAME
RectangleTree< MetricType, StatisticType, MatType, SplitType, DescentType, AuxiliaryInformationType > \- A rectangle type tree tree, such as an R-tree or X-tree\&.  

.SH SYNOPSIS
.br
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBDualTreeTraverser\fP"
.br
.RI "A dual tree traverser for rectangle type trees\&. "
.ti -1c
.RI "class \fBSingleTreeTraverser\fP"
.br
.RI "A single traverser for rectangle type trees\&. "
.in -1c
.SS "Public Types"

.in +1c
.ti -1c
.RI "typedef AuxiliaryInformationType< \fBRectangleTree\fP > \fBAuxiliaryInformation\fP"
.br
.RI "The auxiliary information type held by the tree\&. "
.ti -1c
.RI "typedef MatType::elem_type \fBElemType\fP"
.br
.RI "The element type held by the matrix type\&. "
.ti -1c
.RI "typedef MatType \fBMat\fP"
.br
.RI "So other classes can use TreeType::Mat\&. "
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "template<typename Archive > \fBRectangleTree\fP (Archive &ar, const typename \fBstd::enable_if_t\fP< \fBcereal::is_loading\fP< Archive >()> *=0)"
.br
.RI "Construct the tree from a cereal archive\&. "
.ti -1c
.RI "\fBRectangleTree\fP (const MatType &data, const size_t maxLeafSize=20, const size_t minLeafSize=8, const size_t maxNumChildren=5, const size_t minNumChildren=2, const size_t firstDataIndex=0)"
.br
.RI "Construct this as the root node of a rectangle type tree using the given dataset\&. "
.ti -1c
.RI "\fBRectangleTree\fP (const \fBRectangleTree\fP &other, const bool deepCopy=true, \fBRectangleTree\fP *newParent=NULL)"
.br
.RI "Create a rectangle tree by copying the other tree\&. "
.ti -1c
.RI "\fBRectangleTree\fP (MatType &&data, const size_t maxLeafSize=20, const size_t minLeafSize=8, const size_t maxNumChildren=5, const size_t minNumChildren=2, const size_t firstDataIndex=0)"
.br
.RI "Construct this as the root node of a rectangle tree type using the given dataset, and taking ownership of the given dataset\&. "
.ti -1c
.RI "\fBRectangleTree\fP (\fBRectangleTree\fP &&other)"
.br
.RI "Create a rectangle tree by moving the other tree\&. "
.ti -1c
.RI "\fBRectangleTree\fP (\fBRectangleTree\fP *parentNode, const size_t numMaxChildren=0)"
.br
.RI "Construct this as an empty node with the specified parent\&. "
.ti -1c
.RI "\fB~RectangleTree\fP ()"
.br
.RI "Deletes this node, deallocating the memory for the children and calling their destructors in turn\&. "
.ti -1c
.RI "AuxiliaryInformationType< \fBRectangleTree\fP > & \fBAuxiliaryInfo\fP ()"
.br
.RI "Modify the split object of this node\&. "
.ti -1c
.RI "const AuxiliaryInformationType< \fBRectangleTree\fP > & \fBAuxiliaryInfo\fP () const"
.br
.RI "Return the auxiliary information object of this node\&. "
.ti -1c
.RI "size_t & \fBBegin\fP ()"
.br
.RI "Modify the index of the beginning point of this subset\&. "
.ti -1c
.RI "size_t \fBBegin\fP () const"
.br
.RI "Return the index of the beginning point of this subset\&. "
.ti -1c
.RI "\fBbound::HRectBound\fP< MetricType > & \fBBound\fP ()"
.br
.RI "Modify the bound object for this node\&. "
.ti -1c
.RI "const \fBbound::HRectBound\fP< MetricType > & \fBBound\fP () const"
.br
.RI "Return the bound object for this node\&. "
.ti -1c
.RI "void \fBCenter\fP (arma::vec &center)"
.br
.RI "Get the centroid of the node and store it in the given vector\&. "
.ti -1c
.RI "\fBRectangleTree\fP & \fBChild\fP (const size_t child)"
.br
.RI "Modify the specified child\&. "
.ti -1c
.RI "\fBRectangleTree\fP & \fBChild\fP (const size_t child) const"
.br
.RI "Get the specified child\&. "
.ti -1c
.RI "void \fBCondenseTree\fP (const arma::vec &point, std::vector< bool > &relevels, const bool usePoint)"
.br
.RI "Condense the bounding rectangles for this node based on the removal of the point specified by the arma::vec&\&. "
.ti -1c
.RI "size_t & \fBCount\fP ()"
.br
.RI "Modify the number of points in this subset\&. "
.ti -1c
.RI "size_t \fBCount\fP () const"
.br
.RI "Return the number of points in this subset\&. "
.ti -1c
.RI "MatType & \fBDataset\fP ()"
.br
.RI "Modify the dataset which the tree is built on\&. Be careful! "
.ti -1c
.RI "const MatType & \fBDataset\fP () const"
.br
.RI "Get the dataset which the tree is built on\&. "
.ti -1c
.RI "bool \fBDeletePoint\fP (const size_t point)"
.br
.RI "Deletes a point from the treeand, updates the bounding rectangle\&. "
.ti -1c
.RI "bool \fBDeletePoint\fP (const size_t point, std::vector< bool > &relevels)"
.br
.RI "Deletes a point from the tree, updates the bounding rectangle, tracking levels\&. "
.ti -1c
.RI "size_t \fBDescendant\fP (const size_t index) const"
.br
.RI "Return the index (with reference to the dataset) of a particular descendant of this node\&. "
.ti -1c
.RI "\fBRectangleTree\fP * \fBExactClone\fP ()"
.br
.RI "Make an exact copy of this node, pointers and everything\&. "
.ti -1c
.RI "\fBRectangleTree\fP * \fBFindByBeginCount\fP (size_t begin, size_t count)"
.br
.RI "Find a node in this tree by its begin and count\&. "
.ti -1c
.RI "const \fBRectangleTree\fP * \fBFindByBeginCount\fP (size_t begin, size_t count) const"
.br
.RI "Find a node in this tree by its begin and count (const)\&. "
.ti -1c
.RI "\fBElemType\fP \fBFurthestDescendantDistance\fP () const"
.br
.RI "Return the furthest possible descendant distance\&. "
.ti -1c
.RI "\fBElemType\fP \fBFurthestPointDistance\fP () const"
.br
.RI "Return the furthest distance to a point held in this node\&. "
.ti -1c
.RI "size_t \fBGetFurthestChild\fP (const \fBRectangleTree\fP &queryNode)"
.br
.RI "Return the index of the furthest child node to the given query node\&. "
.ti -1c
.RI "template<typename VecType > size_t \fBGetFurthestChild\fP (const VecType &point, typename \fBstd::enable_if_t\fP< \fBIsVector\fP< VecType >::value > *=0)"
.br
.RI "Return the index of the furthest child node to the given query point\&. "
.ti -1c
.RI "size_t \fBGetNearestChild\fP (const \fBRectangleTree\fP &queryNode)"
.br
.RI "Return the index of the nearest child node to the given query node\&. "
.ti -1c
.RI "template<typename VecType > size_t \fBGetNearestChild\fP (const VecType &point, typename \fBstd::enable_if_t\fP< \fBIsVector\fP< VecType >::value > *=0)"
.br
.RI "Return the index of the nearest child node to the given query point\&. "
.ti -1c
.RI "void \fBInsertNode\fP (\fBRectangleTree\fP *node, const size_t level, std::vector< bool > &relevels)"
.br
.RI "Inserts a node into the tree, tracking which levels have been inserted into\&. "
.ti -1c
.RI "void \fBInsertPoint\fP (const size_t point)"
.br
.RI "Inserts a point into the tree\&. "
.ti -1c
.RI "void \fBInsertPoint\fP (const size_t point, std::vector< bool > &relevels)"
.br
.RI "Inserts a point into the tree, tracking which levels have been inserted into\&. "
.ti -1c
.RI "bool \fBIsLeaf\fP () const"
.br
.RI "Return whether or not this node is a leaf (true if it has no children)\&. "
.ti -1c
.RI "\fBElemType\fP \fBMaxDistance\fP (const \fBRectangleTree\fP &other) const"
.br
.RI "Return the maximum distance to another node\&. "
.ti -1c
.RI "template<typename VecType > \fBElemType\fP \fBMaxDistance\fP (const VecType &point, typename \fBstd::enable_if_t\fP< \fBIsVector\fP< VecType >::value > *=0) const"
.br
.RI "Return the maximum distance to another point\&. "
.ti -1c
.RI "size_t & \fBMaxLeafSize\fP ()"
.br
.RI "Modify the maximum leaf size\&. "
.ti -1c
.RI "size_t \fBMaxLeafSize\fP () const"
.br
.RI "Return the maximum leaf size\&. "
.ti -1c
.RI "size_t & \fBMaxNumChildren\fP ()"
.br
.RI "Modify the maximum number of children (in a non-leaf node)\&. "
.ti -1c
.RI "size_t \fBMaxNumChildren\fP () const"
.br
.RI "Return the maximum number of children (in a non-leaf node)\&. "
.ti -1c
.RI "MetricType \fBMetric\fP () const"
.br
.RI "Get the metric which the tree uses\&. "
.ti -1c
.RI "\fBElemType\fP \fBMinDistance\fP (const \fBRectangleTree\fP &other) const"
.br
.RI "Return the minimum distance to another node\&. "
.ti -1c
.RI "template<typename VecType > \fBElemType\fP \fBMinDistance\fP (const VecType &point, typename \fBstd::enable_if_t\fP< \fBIsVector\fP< VecType >::value > *=0) const"
.br
.RI "Return the minimum distance to another point\&. "
.ti -1c
.RI "\fBElemType\fP \fBMinimumBoundDistance\fP () const"
.br
.RI "Return the minimum distance from the center to any edge of the bound\&. "
.ti -1c
.RI "size_t & \fBMinLeafSize\fP ()"
.br
.RI "Modify the minimum leaf size\&. "
.ti -1c
.RI "size_t \fBMinLeafSize\fP () const"
.br
.RI "Return the minimum leaf size\&. "
.ti -1c
.RI "size_t & \fBMinNumChildren\fP ()"
.br
.RI "Modify the minimum number of children (in a non-leaf node)\&. "
.ti -1c
.RI "size_t \fBMinNumChildren\fP () const"
.br
.RI "Return the minimum number of children (in a non-leaf node)\&. "
.ti -1c
.RI "void \fBNullifyData\fP ()"
.br
.RI "Nullify the auxiliary information\&. "
.ti -1c
.RI "size_t & \fBNumChildren\fP ()"
.br
.RI "Modify the number of child nodes\&. Be careful\&. "
.ti -1c
.RI "size_t \fBNumChildren\fP () const"
.br
.RI "Return the number of child nodes\&. (One level beneath this one only\&.) "
.ti -1c
.RI "size_t \fBNumDescendants\fP () const"
.br
.RI "Return the number of descendants of this node\&. "
.ti -1c
.RI "size_t \fBNumPoints\fP () const"
.br
.RI "Return the number of points in this node (returns 0 if this node is not a leaf)\&. "
.ti -1c
.RI "\fBRectangleTree\fP & \fBoperator=\fP (const \fBRectangleTree\fP &other)"
.br
.RI "Copy the given rectangle tree\&. "
.ti -1c
.RI "\fBRectangleTree\fP & \fBoperator=\fP (\fBRectangleTree\fP &&other)"
.br
.RI "Take ownership of the given rectangle tree\&. "
.ti -1c
.RI "\fBRectangleTree\fP *& \fBParent\fP ()"
.br
.RI "Modify the parent of this node\&. "
.ti -1c
.RI "\fBRectangleTree\fP * \fBParent\fP () const"
.br
.RI "Gets the parent of this node\&. "
.ti -1c
.RI "\fBElemType\fP & \fBParentDistance\fP ()"
.br
.RI "Modify the distance from the center of this node to the center of the parent node\&. "
.ti -1c
.RI "\fBElemType\fP \fBParentDistance\fP () const"
.br
.RI "Return the distance from the center of this node to the center of the parent node\&. "
.ti -1c
.RI "size_t & \fBPoint\fP (const size_t index)"
.br
.RI "Modify the index of a particular point in this node\&. "
.ti -1c
.RI "size_t \fBPoint\fP (const size_t index) const"
.br
.RI "Return the index (with reference to the dataset) of a particular point in this node\&. "
.ti -1c
.RI "\fBmath::RangeType\fP< \fBElemType\fP > \fBRangeDistance\fP (const \fBRectangleTree\fP &other) const"
.br
.RI "Return the minimum and maximum distance to another node\&. "
.ti -1c
.RI "template<typename VecType > \fBmath::RangeType\fP< \fBElemType\fP > \fBRangeDistance\fP (const VecType &point, typename \fBstd::enable_if_t\fP< \fBIsVector\fP< VecType >::value > *=0) const"
.br
.RI "Return the minimum and maximum distance to another point\&. "
.ti -1c
.RI "bool \fBRemoveNode\fP (const \fBRectangleTree\fP *node, std::vector< bool > &relevels)"
.br
.RI "Removes a node from the tree\&. "
.ti -1c
.RI "template<typename Archive > void \fBserialize\fP (Archive &ar, const uint32_t)"
.br
.RI "Serialize the tree\&. "
.ti -1c
.RI "bool \fBShrinkBoundForBound\fP (const \fBbound::HRectBound\fP< MetricType > &changedBound)"
.br
.RI "Shrink the bound object of this node for the removal of a child node\&. "
.ti -1c
.RI "bool \fBShrinkBoundForPoint\fP (const arma::vec &point)"
.br
.RI "Shrink the bound object of this node for the removal of a point\&. "
.ti -1c
.RI "void \fBSoftDelete\fP ()"
.br
.RI "Delete this node of the tree, but leave the stuff contained in it intact\&. "
.ti -1c
.RI "StatisticType & \fBStat\fP ()"
.br
.RI "Modify the statistic object for this node\&. "
.ti -1c
.RI "const StatisticType & \fBStat\fP () const"
.br
.RI "Return the statistic object for this node\&. "
.ti -1c
.RI "size_t \fBTreeDepth\fP () const"
.br
.RI "Obtains the number of levels below this node in the tree, starting with this\&. "
.ti -1c
.RI "size_t \fBTreeSize\fP () const"
.br
.RI "Obtains the number of nodes in the tree, starting with this\&. "
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "\fBRectangleTree\fP ()"
.br
.RI "A default constructor\&. "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "friend \fBAuxiliaryInformation\fP"
.br
.RI "Give friend access for AuxiliaryInformationType\&. "
.ti -1c
.RI "friend \fBDescentType\fP"
.br
.RI "Give friend access for DescentType\&. "
.ti -1c
.RI "friend \fBSplitType\fP"
.br
.RI "Give friend access for SplitType\&. "
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename MetricType = metric::EuclideanDistance, typename StatisticType = EmptyStatistic, typename MatType = arma::mat, typename SplitType = RTreeSplit, typename DescentType = RTreeDescentHeuristic, template< typename > class AuxiliaryInformationType = NoAuxiliaryInformation>
.br
class mlpack::tree::RectangleTree< MetricType, StatisticType, MatType, SplitType, DescentType, AuxiliaryInformationType >"
A rectangle type tree tree, such as an R-tree or X-tree\&. 

Once the bound and type of dataset is defined, the tree will construct itself\&. Call the constructor with the dataset to build the tree on, and the entire tree will be built\&.
.PP
This tree does allow growth, so you can add and delete nodes from it\&.
.PP
\fBTemplate Parameters\fP
.RS 4
\fIMetricType\fP This \fImust\fP be EuclideanDistance, but the template parameter is required to satisfy the TreeType API\&. 
.br
\fIStatisticType\fP Extra data contained in the node\&. See \fBstatistic\&.hpp\fP for the necessary skeleton interface\&. 
.br
\fIMatType\fP The dataset class\&. 
.br
\fISplitType\fP The type of split to use when inserting points\&. 
.br
\fIDescentType\fP The heuristic to use when descending the tree to insert points\&. 
.br
\fIAuxiliaryInformationType\fP An auxiliary information contained in the node\&. This information depends on the type of the \fBRectangleTree\fP\&. 
.RE
.PP

.PP
Definition at line 54 of file rectangle_tree\&.hpp\&.
.SH "Member Typedef Documentation"
.PP 
.SS "typedef AuxiliaryInformationType<\fBRectangleTree\fP> \fBAuxiliaryInformation\fP"

.PP
The auxiliary information type held by the tree\&. 
.PP
Definition at line 66 of file rectangle_tree\&.hpp\&.
.SS "typedef MatType::elem_type \fBElemType\fP"

.PP
The element type held by the matrix type\&. 
.PP
Definition at line 64 of file rectangle_tree\&.hpp\&.
.SS "typedef MatType \fBMat\fP"

.PP
So other classes can use TreeType::Mat\&. 
.PP
Definition at line 62 of file rectangle_tree\&.hpp\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "\fBRectangleTree\fP (const MatType & data, const size_t maxLeafSize = \fC20\fP, const size_t minLeafSize = \fC8\fP, const size_t maxNumChildren = \fC5\fP, const size_t minNumChildren = \fC2\fP, const size_t firstDataIndex = \fC0\fP)"

.PP
Construct this as the root node of a rectangle type tree using the given dataset\&. This will modify the ordering of the points in the dataset!
.PP
\fBParameters\fP
.RS 4
\fIdata\fP Dataset from which to create the tree\&. This will be modified! 
.br
\fImaxLeafSize\fP Maximum size of each leaf in the tree\&. 
.br
\fIminLeafSize\fP Minimum size of each leaf in the tree\&. 
.br
\fImaxNumChildren\fP The maximum number of child nodes a non-leaf node may have\&. 
.br
\fIminNumChildren\fP The minimum number of child nodes a non-leaf node may have\&. 
.br
\fIfirstDataIndex\fP The index of the first data point\&. UNUSED UNLESS WE ADD SUPPORT FOR HAVING A 'CENTERAL' DATA MATRIX\&. 
.RE
.PP

.SS "\fBRectangleTree\fP (MatType && data, const size_t maxLeafSize = \fC20\fP, const size_t minLeafSize = \fC8\fP, const size_t maxNumChildren = \fC5\fP, const size_t minNumChildren = \fC2\fP, const size_t firstDataIndex = \fC0\fP)"

.PP
Construct this as the root node of a rectangle tree type using the given dataset, and taking ownership of the given dataset\&. 
.PP
\fBParameters\fP
.RS 4
\fIdata\fP Dataset from which to create the tree\&. 
.br
\fImaxLeafSize\fP Maximum size of each leaf in the tree\&. 
.br
\fIminLeafSize\fP Minimum size of each leaf in the tree\&. 
.br
\fImaxNumChildren\fP The maximum number of child nodes a non-leaf node may have\&. 
.br
\fIminNumChildren\fP The minimum number of child nodes a non-leaf node may have\&. 
.br
\fIfirstDataIndex\fP The index of the first data point\&. UNUSED UNLESS WE ADD SUPPORT FOR HAVING A 'CENTERAL' DATA MATRIX\&. 
.RE
.PP

.SS "\fBRectangleTree\fP (\fBRectangleTree\fP< MetricType, StatisticType, MatType, \fBSplitType\fP, \fBDescentType\fP, AuxiliaryInformationType > * parentNode, const size_t numMaxChildren = \fC0\fP)\fC [explicit]\fP"

.PP
Construct this as an empty node with the specified parent\&. Copying the parameters (maxLeafSize, minLeafSize, maxNumChildren, minNumChildren, firstDataIndex) from the parent\&.
.PP
\fBParameters\fP
.RS 4
\fIparentNode\fP The parent of the node that is being constructed\&. 
.br
\fInumMaxChildren\fP The max number of child nodes (used in x-trees)\&. 
.RE
.PP

.SS "\fBRectangleTree\fP (const \fBRectangleTree\fP< MetricType, StatisticType, MatType, \fBSplitType\fP, \fBDescentType\fP, AuxiliaryInformationType > & other, const bool deepCopy = \fCtrue\fP, \fBRectangleTree\fP< MetricType, StatisticType, MatType, \fBSplitType\fP, \fBDescentType\fP, AuxiliaryInformationType > * newParent = \fCNULL\fP)"

.PP
Create a rectangle tree by copying the other tree\&. Be careful! This can take a long time and use a lot of memory\&.
.PP
\fBParameters\fP
.RS 4
\fIother\fP The tree to be copied\&. 
.br
\fIdeepCopy\fP If false, the children are not recursively copied\&. 
.br
\fInewParent\fP Set a new parent as applicable, default NULL\&. 
.RE
.PP

.SS "\fBRectangleTree\fP (\fBRectangleTree\fP< MetricType, StatisticType, MatType, \fBSplitType\fP, \fBDescentType\fP, AuxiliaryInformationType > && other)"

.PP
Create a rectangle tree by moving the other tree\&. 
.PP
\fBParameters\fP
.RS 4
\fIother\fP The tree to be moved\&. 
.RE
.PP

.SS "\fBRectangleTree\fP (Archive & ar, const typename \fBstd::enable_if_t\fP< \fBcereal::is_loading\fP< Archive >()> * = \fC0\fP)"

.PP
Construct the tree from a cereal archive\&. 
.SS "~\fBRectangleTree\fP ()"

.PP
Deletes this node, deallocating the memory for the children and calling their destructors in turn\&. This will invalidate any younters or references to any nodes which are children of this one\&. 
.SS "\fBRectangleTree\fP ()\fC [protected]\fP"

.PP
A default constructor\&. This is meant to only be used with cereal, which is allowed with the friend declaration below\&. This does not return a valid tree! This method must be protected, so that the serialization shim can work with the default constructor\&. 
.SH "Member Function Documentation"
.PP 
.SS "AuxiliaryInformationType<\fBRectangleTree\fP>& AuxiliaryInfo ()\fC [inline]\fP"

.PP
Modify the split object of this node\&. 
.PP
Definition at line 328 of file rectangle_tree\&.hpp\&.
.SS "const AuxiliaryInformationType<\fBRectangleTree\fP>& AuxiliaryInfo () const\fC [inline]\fP"

.PP
Return the auxiliary information object of this node\&. 
.PP
Definition at line 325 of file rectangle_tree\&.hpp\&.
.SS "size_t& Begin ()\fC [inline]\fP"

.PP
Modify the index of the beginning point of this subset\&. 
.PP
Definition at line 545 of file rectangle_tree\&.hpp\&.
.SS "size_t Begin () const\fC [inline]\fP"

.PP
Return the index of the beginning point of this subset\&. 
.PP
Definition at line 543 of file rectangle_tree\&.hpp\&.
.SS "\fBbound::HRectBound\fP<MetricType>& Bound ()\fC [inline]\fP"

.PP
Modify the bound object for this node\&. 
.PP
Definition at line 317 of file rectangle_tree\&.hpp\&.
.SS "const \fBbound::HRectBound\fP<MetricType>& Bound () const\fC [inline]\fP"

.PP
Return the bound object for this node\&. 
.PP
Definition at line 315 of file rectangle_tree\&.hpp\&.
.PP
Referenced by RectangleTree< MetricType, StatisticType, MatType, SplitType, DescentType, AuxiliaryInformationType >::MaxDistance(), RectangleTree< MetricType, StatisticType, MatType, SplitType, DescentType, AuxiliaryInformationType >::MinDistance(), and RectangleTree< MetricType, StatisticType, MatType, SplitType, DescentType, AuxiliaryInformationType >::RangeDistance()\&.
.SS "void Center (arma::vec & center)\fC [inline]\fP"

.PP
Get the centroid of the node and store it in the given vector\&. 
.PP
Definition at line 368 of file rectangle_tree\&.hpp\&.
.PP
References HRectBound< MetricType, ElemType >::Center()\&.
.SS "\fBRectangleTree\fP& Child (const size_t child)\fC [inline]\fP"

.PP
Modify the specified child\&. 
.PP
\fBParameters\fP
.RS 4
\fIchild\fP Index of child to return\&. 
.RE
.PP

.PP
Definition at line 447 of file rectangle_tree\&.hpp\&.
.SS "\fBRectangleTree\fP& Child (const size_t child) const\fC [inline]\fP"

.PP
Get the specified child\&. 
.PP
\fBParameters\fP
.RS 4
\fIchild\fP Index of child to return\&. 
.RE
.PP

.PP
Definition at line 437 of file rectangle_tree\&.hpp\&.
.SS "void CondenseTree (const arma::vec & point, std::vector< bool > & relevels, const bool usePoint)"

.PP
Condense the bounding rectangles for this node based on the removal of the point specified by the arma::vec&\&. This recurses up the tree\&. If a node goes below the minimum fill, this function will fix the tree\&.
.PP
\fBParameters\fP
.RS 4
\fIpoint\fP The arma::vec& of the point that was removed to require this condesation of the tree\&. 
.br
\fIusePoint\fP True if we use the optimized version of the algorithm that is possible when we now what point was deleted\&. False otherwise (eg\&. if we deleted a node instead of a point)\&. 
.br
\fIrelevels\fP The levels that have been reinserted to on this top level insertion\&. 
.RE
.PP

.SS "size_t& Count ()\fC [inline]\fP"

.PP
Modify the number of points in this subset\&. 
.PP
Definition at line 550 of file rectangle_tree\&.hpp\&.
.SS "size_t Count () const\fC [inline]\fP"

.PP
Return the number of points in this subset\&. 
.PP
Definition at line 548 of file rectangle_tree\&.hpp\&.
.SS "MatType& Dataset ()\fC [inline]\fP"

.PP
Modify the dataset which the tree is built on\&. Be careful! 
.PP
Definition at line 362 of file rectangle_tree\&.hpp\&.
.SS "const MatType& Dataset () const\fC [inline]\fP"

.PP
Get the dataset which the tree is built on\&. 
.PP
Definition at line 360 of file rectangle_tree\&.hpp\&.
.SS "bool DeletePoint (const size_t point)"

.PP
Deletes a point from the treeand, updates the bounding rectangle\&. However, the point will be kept in the centeral dataset\&. (The user may remove it from there if he wants, but he must not change the indices of the other points\&.) Returns true if the point is successfully removed and false if it is not\&. (ie\&. the point is not in the tree) 
.SS "bool DeletePoint (const size_t point, std::vector< bool > & relevels)"

.PP
Deletes a point from the tree, updates the bounding rectangle, tracking levels\&. However, the point will be kept in the centeral dataset\&. (The user may remove it from there if he wants, but he must not change the indices of the other points\&.) Returns true if the point is successfully removed and false if it is not\&. (ie\&. the point is not in the tree) 
.SS "size_t Descendant (const size_t index) const"

.PP
Return the index (with reference to the dataset) of a particular descendant of this node\&. The index should be greater than zero but less than the number of descendants\&.
.PP
\fBParameters\fP
.RS 4
\fIindex\fP Index of the descendant\&. 
.RE
.PP

.SS "\fBRectangleTree\fP* ExactClone ()"

.PP
Make an exact copy of this node, pointers and everything\&. 
.SS "\fBRectangleTree\fP* FindByBeginCount (size_t begin, size_t count)"

.PP
Find a node in this tree by its begin and count\&. Every node is uniquely identified by these two numbers\&. This is useful for communicating position over the network, when pointers would be invalid\&.
.PP
\fBParameters\fP
.RS 4
\fIbegin\fP The begin() of the node to find\&. 
.br
\fIcount\fP The count() of the node to find\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The found node, or NULL if not found\&. 
.RE
.PP

.SS "const \fBRectangleTree\fP* FindByBeginCount (size_t begin, size_t count) const"

.PP
Find a node in this tree by its begin and count (const)\&. Every node is uniquely identified by these two numbers\&. This is useful for communicating position over the network, when pointers would be invalid\&.
.PP
\fBParameters\fP
.RS 4
\fIbegin\fP The begin() of the node to find\&. 
.br
\fIcount\fP The count() of the node to find\&. 
.RE
.PP
\fBReturns\fP
.RS 4
The found node, or NULL if not found\&. 
.RE
.PP

.SS "\fBElemType\fP FurthestDescendantDistance () const"

.PP
Return the furthest possible descendant distance\&. This returns the maximum distance from the centroid to the edge of the bound and not the empirical quantity which is the actual furthest descendant distance\&. So the actual furthest descendant distance may be less than what this method returns (but it will never be greater than this)\&. 
.SS "\fBElemType\fP FurthestPointDistance () const"

.PP
Return the furthest distance to a point held in this node\&. If this is not a leaf node, then the distance is 0 because the node holds no points\&. 
.SS "size_t GetFurthestChild (const \fBRectangleTree\fP< MetricType, StatisticType, MatType, \fBSplitType\fP, \fBDescentType\fP, AuxiliaryInformationType > & queryNode)"

.PP
Return the index of the furthest child node to the given query node\&. If it can't decide, it will return \fBNumChildren()\fP (invalid index)\&. 
.SS "size_t GetFurthestChild (const VecType & point, typename \fBstd::enable_if_t\fP< \fBIsVector\fP< VecType >::value > * = \fC0\fP)"

.PP
Return the index of the furthest child node to the given query point\&. If this is a leaf node, it will return \fBNumChildren()\fP (invalid index)\&. 
.SS "size_t GetNearestChild (const \fBRectangleTree\fP< MetricType, StatisticType, MatType, \fBSplitType\fP, \fBDescentType\fP, AuxiliaryInformationType > & queryNode)"

.PP
Return the index of the nearest child node to the given query node\&. If it can't decide, it will return \fBNumChildren()\fP (invalid index)\&. 
.SS "size_t GetNearestChild (const VecType & point, typename \fBstd::enable_if_t\fP< \fBIsVector\fP< VecType >::value > * = \fC0\fP)"

.PP
Return the index of the nearest child node to the given query point\&. If this is a leaf node, it will return \fBNumChildren()\fP (invalid index)\&. 
.SS "void InsertNode (\fBRectangleTree\fP< MetricType, StatisticType, MatType, \fBSplitType\fP, \fBDescentType\fP, AuxiliaryInformationType > * node, const size_t level, std::vector< bool > & relevels)"

.PP
Inserts a node into the tree, tracking which levels have been inserted into\&. The node will be inserted so that the tree remains valid\&.
.PP
\fBParameters\fP
.RS 4
\fInode\fP The node to be inserted\&. 
.br
\fIlevel\fP The depth that should match the node where this node is finally inserted\&. This should be the number returned by calling \fBTreeDepth()\fP from the node that originally contained 'node'\&. 
.br
\fIrelevels\fP The levels that have been reinserted to on this top level insertion\&. 
.RE
.PP

.SS "void InsertPoint (const size_t point)"

.PP
Inserts a point into the tree\&. 
.PP
\fBParameters\fP
.RS 4
\fIpoint\fP The index of a point in the dataset\&. 
.RE
.PP

.SS "void InsertPoint (const size_t point, std::vector< bool > & relevels)"

.PP
Inserts a point into the tree, tracking which levels have been inserted into\&. 
.PP
\fBParameters\fP
.RS 4
\fIpoint\fP The index of a point in the dataset\&. 
.br
\fIrelevels\fP The levels that have been reinserted to on this top level insertion\&. 
.RE
.PP

.SS "bool IsLeaf () const"

.PP
Return whether or not this node is a leaf (true if it has no children)\&. 
.SS "\fBElemType\fP MaxDistance (const \fBRectangleTree\fP< MetricType, StatisticType, MatType, \fBSplitType\fP, \fBDescentType\fP, AuxiliaryInformationType > & other) const\fC [inline]\fP"

.PP
Return the maximum distance to another node\&. 
.PP
Definition at line 493 of file rectangle_tree\&.hpp\&.
.PP
References RectangleTree< MetricType, StatisticType, MatType, SplitType, DescentType, AuxiliaryInformationType >::Bound(), and HRectBound< MetricType, ElemType >::MaxDistance()\&.
.SS "\fBElemType\fP MaxDistance (const VecType & point, typename \fBstd::enable_if_t\fP< \fBIsVector\fP< VecType >::value > * = \fC0\fP) const\fC [inline]\fP"

.PP
Return the maximum distance to another point\&. 
.PP
Definition at line 515 of file rectangle_tree\&.hpp\&.
.PP
References HRectBound< MetricType, ElemType >::MaxDistance()\&.
.SS "size_t& MaxLeafSize ()\fC [inline]\fP"

.PP
Modify the maximum leaf size\&. 
.PP
Definition at line 337 of file rectangle_tree\&.hpp\&.
.SS "size_t MaxLeafSize () const\fC [inline]\fP"

.PP
Return the maximum leaf size\&. 
.PP
Definition at line 335 of file rectangle_tree\&.hpp\&.
.SS "size_t& MaxNumChildren ()\fC [inline]\fP"

.PP
Modify the maximum number of children (in a non-leaf node)\&. 
.PP
Definition at line 347 of file rectangle_tree\&.hpp\&.
.SS "size_t MaxNumChildren () const\fC [inline]\fP"

.PP
Return the maximum number of children (in a non-leaf node)\&. 
.PP
Definition at line 345 of file rectangle_tree\&.hpp\&.
.SS "MetricType Metric () const\fC [inline]\fP"

.PP
Get the metric which the tree uses\&. 
.PP
Definition at line 365 of file rectangle_tree\&.hpp\&.
.SS "\fBElemType\fP MinDistance (const \fBRectangleTree\fP< MetricType, StatisticType, MatType, \fBSplitType\fP, \fBDescentType\fP, AuxiliaryInformationType > & other) const\fC [inline]\fP"

.PP
Return the minimum distance to another node\&. 
.PP
Definition at line 487 of file rectangle_tree\&.hpp\&.
.PP
References RectangleTree< MetricType, StatisticType, MatType, SplitType, DescentType, AuxiliaryInformationType >::Bound(), and HRectBound< MetricType, ElemType >::MinDistance()\&.
.SS "\fBElemType\fP MinDistance (const VecType & point, typename \fBstd::enable_if_t\fP< \fBIsVector\fP< VecType >::value > * = \fC0\fP) const\fC [inline]\fP"

.PP
Return the minimum distance to another point\&. 
.PP
Definition at line 506 of file rectangle_tree\&.hpp\&.
.PP
References HRectBound< MetricType, ElemType >::MinDistance()\&.
.SS "\fBElemType\fP MinimumBoundDistance () const\fC [inline]\fP"

.PP
Return the minimum distance from the center to any edge of the bound\&. Currently, this returns 0, which doesn't break algorithms, but it isn't necessarily correct, either\&. 
.PP
Definition at line 423 of file rectangle_tree\&.hpp\&.
.PP
References HRectBound< MetricType, ElemType >::MinWidth()\&.
.SS "size_t& MinLeafSize ()\fC [inline]\fP"

.PP
Modify the minimum leaf size\&. 
.PP
Definition at line 342 of file rectangle_tree\&.hpp\&.
.SS "size_t MinLeafSize () const\fC [inline]\fP"

.PP
Return the minimum leaf size\&. 
.PP
Definition at line 340 of file rectangle_tree\&.hpp\&.
.SS "size_t& MinNumChildren ()\fC [inline]\fP"

.PP
Modify the minimum number of children (in a non-leaf node)\&. 
.PP
Definition at line 352 of file rectangle_tree\&.hpp\&.
.SS "size_t MinNumChildren () const\fC [inline]\fP"

.PP
Return the minimum number of children (in a non-leaf node)\&. 
.PP
Definition at line 350 of file rectangle_tree\&.hpp\&.
.SS "void NullifyData ()"

.PP
Nullify the auxiliary information\&. Used for memory management\&. Be cafeful\&. 
.SS "size_t& NumChildren ()\fC [inline]\fP"

.PP
Modify the number of child nodes\&. Be careful\&. 
.PP
Definition at line 373 of file rectangle_tree\&.hpp\&.
.SS "size_t NumChildren () const\fC [inline]\fP"

.PP
Return the number of child nodes\&. (One level beneath this one only\&.) 
.PP
Definition at line 371 of file rectangle_tree\&.hpp\&.
.SS "size_t NumDescendants () const"

.PP
Return the number of descendants of this node\&. For a non-leaf in a binary space tree, this is the number of points at the descendant leaves\&. For a leaf, this is the number of points in the leaf\&. 
.SS "size_t NumPoints () const"

.PP
Return the number of points in this node (returns 0 if this node is not a leaf)\&. 
.SS "\fBRectangleTree\fP& operator= (const \fBRectangleTree\fP< MetricType, StatisticType, MatType, \fBSplitType\fP, \fBDescentType\fP, AuxiliaryInformationType > & other)"

.PP
Copy the given rectangle tree\&. 
.PP
\fBParameters\fP
.RS 4
\fIother\fP The tree to be copied\&. 
.RE
.PP

.SS "\fBRectangleTree\fP& operator= (\fBRectangleTree\fP< MetricType, StatisticType, MatType, \fBSplitType\fP, \fBDescentType\fP, AuxiliaryInformationType > && other)"

.PP
Take ownership of the given rectangle tree\&. 
.PP
\fBParameters\fP
.RS 4
\fIother\fP The tree to take ownership of\&. 
.RE
.PP

.SS "\fBRectangleTree\fP*& Parent ()\fC [inline]\fP"

.PP
Modify the parent of this node\&. 
.PP
Definition at line 357 of file rectangle_tree\&.hpp\&.
.SS "\fBRectangleTree\fP* Parent () const\fC [inline]\fP"

.PP
Gets the parent of this node\&. 
.PP
Definition at line 355 of file rectangle_tree\&.hpp\&.
.SS "\fBElemType\fP& ParentDistance ()\fC [inline]\fP"

.PP
Modify the distance from the center of this node to the center of the parent node\&. 
.PP
Definition at line 430 of file rectangle_tree\&.hpp\&.
.SS "\fBElemType\fP ParentDistance () const\fC [inline]\fP"

.PP
Return the distance from the center of this node to the center of the parent node\&. 
.PP
Definition at line 427 of file rectangle_tree\&.hpp\&.
.SS "size_t& Point (const size_t index)\fC [inline]\fP"

.PP
Modify the index of a particular point in this node\&. Be very careful when you do this! You may make the tree invalid\&. 
.PP
Definition at line 484 of file rectangle_tree\&.hpp\&.
.SS "size_t Point (const size_t index) const\fC [inline]\fP"

.PP
Return the index (with reference to the dataset) of a particular point in this node\&. This will happily return invalid indices if the given index is greater than the number of points in this node (obtained with \fBNumPoints()\fP) -- be careful\&.
.PP
\fBParameters\fP
.RS 4
\fIindex\fP Index of point for which a dataset index is wanted\&. 
.RE
.PP

.PP
Definition at line 480 of file rectangle_tree\&.hpp\&.
.SS "\fBmath::RangeType\fP<\fBElemType\fP> RangeDistance (const \fBRectangleTree\fP< MetricType, StatisticType, MatType, \fBSplitType\fP, \fBDescentType\fP, AuxiliaryInformationType > & other) const\fC [inline]\fP"

.PP
Return the minimum and maximum distance to another node\&. 
.PP
Definition at line 499 of file rectangle_tree\&.hpp\&.
.PP
References RectangleTree< MetricType, StatisticType, MatType, SplitType, DescentType, AuxiliaryInformationType >::Bound(), and HRectBound< MetricType, ElemType >::RangeDistance()\&.
.SS "\fBmath::RangeType\fP<\fBElemType\fP> RangeDistance (const VecType & point, typename \fBstd::enable_if_t\fP< \fBIsVector\fP< VecType >::value > * = \fC0\fP) const\fC [inline]\fP"

.PP
Return the minimum and maximum distance to another point\&. 
.PP
Definition at line 524 of file rectangle_tree\&.hpp\&.
.PP
References HRectBound< MetricType, ElemType >::RangeDistance()\&.
.SS "bool RemoveNode (const \fBRectangleTree\fP< MetricType, StatisticType, MatType, \fBSplitType\fP, \fBDescentType\fP, AuxiliaryInformationType > * node, std::vector< bool > & relevels)"

.PP
Removes a node from the tree\&. You are responsible for deleting it if you wish to do so\&. 
.SS "void serialize (Archive & ar, const uint32_t)"

.PP
Serialize the tree\&. 
.SS "bool ShrinkBoundForBound (const \fBbound::HRectBound\fP< MetricType > & changedBound)"

.PP
Shrink the bound object of this node for the removal of a child node\&. 
.PP
\fBParameters\fP
.RS 4
\fIchangedBound\fP The HRectBound<>& of the bound that was removed to reqire this shrinking\&. 
.RE
.PP
\fBReturns\fP
.RS 4
true if the bound needed to be changed, false if it did not\&. 
.RE
.PP

.SS "bool ShrinkBoundForPoint (const arma::vec & point)"

.PP
Shrink the bound object of this node for the removal of a point\&. 
.PP
\fBParameters\fP
.RS 4
\fIpoint\fP The arma::vec& of the point that was removed to require this shrinking\&. 
.RE
.PP
\fBReturns\fP
.RS 4
true if the bound needed to be changed, false if it did not\&. 
.RE
.PP

.SS "void SoftDelete ()"

.PP
Delete this node of the tree, but leave the stuff contained in it intact\&. This is used when splitting a node, where the data in this tree is moved to two other trees\&. 
.SS "StatisticType& Stat ()\fC [inline]\fP"

.PP
Modify the statistic object for this node\&. 
.PP
Definition at line 322 of file rectangle_tree\&.hpp\&.
.SS "const StatisticType& Stat () const\fC [inline]\fP"

.PP
Return the statistic object for this node\&. 
.PP
Definition at line 320 of file rectangle_tree\&.hpp\&.
.SS "size_t TreeDepth () const"

.PP
Obtains the number of levels below this node in the tree, starting with this\&. 
.SS "size_t TreeSize () const"

.PP
Obtains the number of nodes in the tree, starting with this\&. 
.SH "Member Data Documentation"
.PP 
.SS "friend \fBAuxiliaryInformation\fP\fC [protected]\fP"

.PP
Give friend access for AuxiliaryInformationType\&. 
.PP
Definition at line 586 of file rectangle_tree\&.hpp\&.
.SS "friend DescentType\fC [protected]\fP"

.PP
Give friend access for DescentType\&. 
.PP
Definition at line 580 of file rectangle_tree\&.hpp\&.
.SS "friend SplitType\fC [protected]\fP"

.PP
Give friend access for SplitType\&. 
.PP
Definition at line 583 of file rectangle_tree\&.hpp\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for mlpack from the source code\&.
