.TH "/home/aakash/mlpack/src/mlpack/core/util/param.hpp" 3 "Sun Jun 20 2021" "Version 3.4.2" "mlpack" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/home/aakash/mlpack/src/mlpack/core/util/param.hpp
.SH SYNOPSIS
.br
.PP
.SS "Namespaces"

.in +1c
.ti -1c
.RI " \fBmlpack\fP"
.br
.RI "Linear algebra utility functions, generally performed on matrices or vectors\&. "
.ti -1c
.RI " \fBmlpack::data\fP"
.br
.RI "Functions to load and save matrices and models\&. "
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBBINDING_EXAMPLE\fP(EXAMPLE)"
.br
.RI "Specify the example of a binding\&. "
.ti -1c
.RI "#define \fBBINDING_LONG_DESC\fP(LONG_DESC)"
.br
.RI "Specify the long description of a binding\&. "
.ti -1c
.RI "#define \fBBINDING_NAME\fP(NAME)"
.br
.RI "Specify the program name of a binding\&. "
.ti -1c
.RI "#define \fBBINDING_SEE_ALSO\fP(DESCRIPTION,  LINK)"
.br
.RI "Specify the see-also of a binding\&. "
.ti -1c
.RI "#define \fBBINDING_SHORT_DESC\fP(SHORT_DESC)"
.br
.RI "Specify the short description of a binding\&. "
.ti -1c
.RI "#define \fBPARAM\fP(T,  ID,  DESC,  ALIAS,  NAME,  REQ,  IN,  TRANS,  DEF)"
.br
.RI "Define the \fBPARAM()\fP, \fBPARAM_MODEL()\fP macro\&. "
.ti -1c
.RI "#define \fBPARAM_COL\fP(ID,  DESC,  ALIAS,  REQ,  TRANS,  IN)"
.br
.ti -1c
.RI "#define \fBPARAM_COL_IN\fP(ID,  DESC,  ALIAS)       \fBPARAM_COL\fP(ID, DESC, ALIAS, false, true, true)"
.br
.RI "Define a vector input parameter (type arma::vec)\&. "
.ti -1c
.RI "#define \fBPARAM_COL_IN_REQ\fP(ID,  DESC,  ALIAS)       \fBPARAM_COL\fP(ID, DESC, ALIAS, true, true, true)"
.br
.RI "Define a required vector input parameter (type arma::vec)\&. "
.ti -1c
.RI "#define \fBPARAM_COL_OUT\fP(ID,  DESC,  ALIAS)       \fBPARAM_COL\fP(ID, DESC, ALIAS, false, true, false)"
.br
.RI "Define a vector output parameter (type arma::vec)\&. "
.ti -1c
.RI "#define \fBPARAM_DOUBLE_IN\fP(ID,  DESC,  ALIAS,  DEF)       \fBPARAM_IN\fP(double, ID, DESC, ALIAS, DEF, false)"
.br
.RI "Define a double input parameter\&. "
.ti -1c
.RI "#define \fBPARAM_DOUBLE_IN_REQ\fP(ID,  DESC,  ALIAS)       \fBPARAM_IN\fP(double, ID, DESC, ALIAS, 0\&.0, true)"
.br
.RI "Define a required double parameter\&. "
.ti -1c
.RI "#define \fBPARAM_DOUBLE_OUT\fP(ID,  DESC)       \fBPARAM_OUT\fP(double, ID, DESC, '', 0\&.0, false)"
.br
.RI "Define a double output parameter\&. "
.ti -1c
.RI "#define \fBPARAM_FLAG\fP(ID,  DESC,  ALIAS)       \fBPARAM_IN\fP(bool, ID, DESC, ALIAS, false, false);"
.br
.RI "Define a flag parameter\&. "
.ti -1c
.RI "#define \fBPARAM_IN\fP(T,  ID,  DESC,  ALIAS,  DEF,  REQ)       \fBPARAM\fP(T, ID, DESC, ALIAS, #T, REQ, true, false, DEF);"
.br
.RI "Defining useful macros using PARAM macro defined later\&. "
.ti -1c
.RI "#define \fBPARAM_INT_IN\fP(ID,  DESC,  ALIAS,  DEF)       \fBPARAM_IN\fP(int, ID, DESC, ALIAS, DEF, false)"
.br
.RI "Define an integer input parameter\&. "
.ti -1c
.RI "#define \fBPARAM_INT_IN_REQ\fP(ID,  DESC,  ALIAS)       \fBPARAM_IN\fP(int, ID, DESC, ALIAS, 0, true)"
.br
.RI "Define a required integer input parameter\&. "
.ti -1c
.RI "#define \fBPARAM_INT_OUT\fP(ID,  DESC)       \fBPARAM_OUT\fP(int, ID, DESC, '', 0, false)"
.br
.RI "Define an integer output parameter\&. "
.ti -1c
.RI "#define \fBPARAM_MATRIX\fP(ID,  DESC,  ALIAS,  REQ,  TRANS,  IN)"
.br
.ti -1c
.RI "#define \fBPARAM_MATRIX_AND_INFO_IN\fP(ID,  DESC,  ALIAS)"
.br
.ti -1c
.RI "#define \fBPARAM_MATRIX_IN\fP(ID,  DESC,  ALIAS)       \fBPARAM_MATRIX\fP(ID, DESC, ALIAS, false, true, true)"
.br
.RI "Define a matrix input parameter\&. "
.ti -1c
.RI "#define \fBPARAM_MATRIX_IN_REQ\fP(ID,  DESC,  ALIAS)       \fBPARAM_MATRIX\fP(ID, DESC, ALIAS, true, true, true)"
.br
.RI "Define a required matrix input parameter\&. "
.ti -1c
.RI "#define \fBPARAM_MATRIX_OUT\fP(ID,  DESC,  ALIAS)       \fBPARAM_MATRIX\fP(ID, DESC, ALIAS, false, true, false)"
.br
.RI "Define a matrix output parameter\&. "
.ti -1c
.RI "#define \fBPARAM_MODEL\fP(TYPE,  ID,  DESC,  ALIAS,  REQ,  IN)"
.br
.ti -1c
.RI "#define \fBPARAM_MODEL_IN\fP(TYPE,  ID,  DESC,  ALIAS)       \fBPARAM_MODEL\fP(TYPE, ID, DESC, ALIAS, false, true)"
.br
.RI "Define an input model\&. "
.ti -1c
.RI "#define \fBPARAM_MODEL_IN_REQ\fP(TYPE,  ID,  DESC,  ALIAS)       \fBPARAM_MODEL\fP(TYPE, ID, DESC, ALIAS, true, true)"
.br
.RI "Define a required input model\&. "
.ti -1c
.RI "#define \fBPARAM_MODEL_OUT\fP(TYPE,  ID,  DESC,  ALIAS)       \fBPARAM_MODEL\fP(TYPE, ID, DESC, ALIAS, false, false)"
.br
.RI "Define an output model\&. "
.ti -1c
.RI "#define \fBPARAM_OUT\fP(T,  ID,  DESC,  ALIAS,  DEF,  REQ)       \fBPARAM\fP(T, ID, DESC, ALIAS, #T, REQ, false, false, DEF);"
.br
.ti -1c
.RI "#define \fBPARAM_ROW\fP(ID,  DESC,  ALIAS,  REQ,  TRANS,  IN)"
.br
.ti -1c
.RI "#define \fBPARAM_ROW_IN\fP(ID,  DESC,  ALIAS)       \fBPARAM_ROW\fP(ID, DESC, ALIAS, false, true, true)"
.br
.RI "Define a row vector input parameter (type arma::rowvec)\&. "
.ti -1c
.RI "#define \fBPARAM_ROW_OUT\fP(ID,  DESC,  ALIAS)       \fBPARAM_ROW\fP(ID, DESC, ALIAS, false, true, false)"
.br
.RI "Define a row vector output parameter (type arma::rowvec)\&. "
.ti -1c
.RI "#define \fBPARAM_STRING_IN\fP(ID,  DESC,  ALIAS,  DEF)       \fBPARAM_IN\fP(std::string, ID, DESC, ALIAS, DEF, false)"
.br
.RI "Define a string input parameter\&. "
.ti -1c
.RI "#define \fBPARAM_STRING_IN_REQ\fP(ID,  DESC,  ALIAS)       \fBPARAM_IN\fP(std::string, ID, DESC, ALIAS, '', true)"
.br
.RI "Define a required string parameter\&. "
.ti -1c
.RI "#define \fBPARAM_STRING_OUT\fP(ID,  DESC,  ALIAS)       \fBPARAM_OUT\fP(std::string, ID, DESC, ALIAS, '', false)"
.br
.RI "Define a string output parameter\&. "
.ti -1c
.RI "#define \fBPARAM_TMATRIX_IN\fP(ID,  DESC,  ALIAS)       \fBPARAM_MATRIX\fP(ID, DESC, ALIAS, false, false, true)"
.br
.RI "Define a transposed matrix input parameter\&. "
.ti -1c
.RI "#define \fBPARAM_TMATRIX_IN_REQ\fP(ID,  DESC,  ALIAS)       \fBPARAM_MATRIX\fP(ID, DESC, ALIAS, true, false, true)"
.br
.RI "Define a required transposed matrix input parameter\&. "
.ti -1c
.RI "#define \fBPARAM_TMATRIX_OUT\fP(ID,  DESC,  ALIAS)       \fBPARAM_MATRIX\fP(ID, DESC, ALIAS, false, false, false)"
.br
.RI "Define a transposed matrix output parameter\&. "
.ti -1c
.RI "#define \fBPARAM_UCOL\fP(ID,  DESC,  ALIAS,  REQ,  TRANS,  IN)"
.br
.ti -1c
.RI "#define \fBPARAM_UCOL_IN\fP(ID,  DESC,  ALIAS)       \fBPARAM_UCOL\fP(ID, DESC, ALIAS, false, true, true)"
.br
.RI "Define an unsigned vector input parameter (type arma::Col<size_t>)\&. "
.ti -1c
.RI "#define \fBPARAM_UCOL_OUT\fP(ID,  DESC,  ALIAS)       \fBPARAM_UCOL\fP(ID, DESC, ALIAS, false, true, false)"
.br
.RI "Define an unsigned vector output parameter (type arma::Col<size_t>)\&. "
.ti -1c
.RI "#define \fBPARAM_UMATRIX\fP(ID,  DESC,  ALIAS,  REQ,  TRANS,  IN)"
.br
.ti -1c
.RI "#define \fBPARAM_UMATRIX_IN\fP(ID,  DESC,  ALIAS)       \fBPARAM_UMATRIX\fP(ID, DESC, ALIAS, false, true, true)"
.br
.RI "Define an unsigned matrix input parameter (arma::Mat<size_t>)\&. "
.ti -1c
.RI "#define \fBPARAM_UMATRIX_IN_REQ\fP(ID,  DESC,  ALIAS)       \fBPARAM_UMATRIX\fP(ID, DESC, ALIAS, true, true, true)"
.br
.RI "Define a required unsigned matrix input parameter (arma::Mat<size_t>)\&. "
.ti -1c
.RI "#define \fBPARAM_UMATRIX_OUT\fP(ID,  DESC,  ALIAS)       \fBPARAM_UMATRIX\fP(ID, DESC, ALIAS, false, true, false)"
.br
.RI "Define an unsigned matrix output parameter (arma::Mat<size_t>)\&. "
.ti -1c
.RI "#define \fBPARAM_UROW\fP(ID,  DESC,  ALIAS,  REQ,  TRANS,  IN)"
.br
.ti -1c
.RI "#define \fBPARAM_UROW_IN\fP(ID,  DESC,  ALIAS)       \fBPARAM_UROW\fP(ID, DESC, ALIAS, false, true, true)"
.br
.RI "Define an unsigned row vector input parameter (type arma::Row<size_t>)\&. "
.ti -1c
.RI "#define \fBPARAM_UROW_OUT\fP(ID,  DESC,  ALIAS)       \fBPARAM_UROW\fP(ID, DESC, ALIAS, false, true, false)"
.br
.RI "Define an unsigned row vector output parameter (type arma::Row<size_t>)\&. "
.ti -1c
.RI "#define \fBPARAM_VECTOR_IN\fP(T,  ID,  DESC,  ALIAS)       \fBPARAM_IN\fP(std::vector<T>, ID, DESC, ALIAS, std::vector<T>(), false)"
.br
.RI "Define a std::vector input parameter\&. "
.ti -1c
.RI "#define \fBPARAM_VECTOR_IN_REQ\fP(T,  ID,  DESC,  ALIAS)       \fBPARAM_IN\fP(std::vector<T>, ID, DESC, ALIAS, std::vector<T>(), true);"
.br
.RI "Define a required vector parameter\&. "
.ti -1c
.RI "#define \fBPARAM_VECTOR_OUT\fP(T,  ID,  DESC,  ALIAS)       \fBPARAM_OUT\fP(std::vector<T>, ID, DESC, ALIAS, std::vector<T>(), false)"
.br
.RI "Define a vector output parameter\&. "
.ti -1c
.RI "#define \fBTUPLE_TYPE\fP   std::tuple<\fBmlpack::data::DatasetInfo\fP, arma::mat>"
.br
.RI "Define an input DatasetInfo/matrix parameter\&. "
.in -1c
.SH "Detailed Description"
.PP 

.PP
\fBAuthor\fP
.RS 4
Matthew Amidon 
.PP
Ryan Curtin
.RE
.PP
Definition of PARAM_*_IN() and PARAM_*_OUT() macros, as well as the Documentation related macro, which are used to define input and output parameters of command-line programs and bindings to other languages\&.
.PP
mlpack is free software; you may redistribute it and/or modify it under the terms of the 3-clause BSD license\&. You should have received a copy of the 3-clause BSD license along with mlpack\&. If not, see http://www.opensource.org/licenses/BSD-3-Clause for more information\&. 
.PP
Definition in file \fBparam\&.hpp\fP\&.
.SH "Macro Definition Documentation"
.PP 
.SS "#define BINDING_EXAMPLE(EXAMPLE)"
\fBValue:\fP
.PP
.nf
      static \
      mlpack::util::Example \
      JOIN(JOIN(io_programexample_dummy_object_, __LINE__), opt) = \
      mlpack::util::Example( \
      []() { return(std::string(EXAMPLE)); });
.fi
.PP
Specify the example of a binding\&. Mutiple instance of this macro can be present in your program! Therefore, use it in the main\&.cpp (or corresponding binding) in your program\&.
.PP
\fBSee also\fP
.RS 4
\fBmlpack::IO\fP, \fBPARAM_FLAG()\fP, \fBPARAM_INT_IN()\fP, \fBPARAM_DOUBLE_IN()\fP, \fBPARAM_STRING_IN()\fP, \fBPARAM_VECTOR_IN()\fP, \fBPARAM_INT_OUT()\fP, \fBPARAM_DOUBLE_OUT()\fP, \fBPARAM_VECTOR_OUT()\fP, \fBPARAM_INT_IN_REQ()\fP, \fBPARAM_DOUBLE_IN_REQ()\fP, \fBPARAM_STRING_IN_REQ()\fP, \fBPARAM_VECTOR_IN_REQ()\fP, PARAM_INT_OUT_REQ(), PARAM_DOUBLE_OUT_REQ(), PARAM_VECTOR_OUT_REQ(), PARAM_STRING_OUT_REQ()\&.
.RE
.PP
\fBParameters\fP
.RS 4
\fIEXAMPLE\fP Long string describing a simple usage example\&.\&. Newlines should not be used here; this is taken care of by IO (however, you can explicitly specify newlines to denote new paragraphs)\&. You can also use printing macros like PRINT_CALL(), PRINT_DATASET(), and others\&. 
.RE
.PP

.PP
Definition at line 127 of file param\&.hpp\&.
.SS "#define BINDING_LONG_DESC(LONG_DESC)"
\fBValue:\fP
.PP
.nf
    static \
    mlpack::util::LongDescription \
    io_programlong_desc_dummy_object = mlpack::util::LongDescription( \
    []() { return std::string(LONG_DESC); });
.fi
.PP
Specify the long description of a binding\&. Only one instance of this macro present in your program! Therefore, use it in the main\&.cpp (or corresponding binding) in your program\&.
.PP
\fBSee also\fP
.RS 4
\fBmlpack::IO\fP, \fBPARAM_FLAG()\fP, \fBPARAM_INT_IN()\fP, \fBPARAM_DOUBLE_IN()\fP, \fBPARAM_STRING_IN()\fP, \fBPARAM_VECTOR_IN()\fP, \fBPARAM_INT_OUT()\fP, \fBPARAM_DOUBLE_OUT()\fP, \fBPARAM_VECTOR_OUT()\fP, \fBPARAM_INT_IN_REQ()\fP, \fBPARAM_DOUBLE_IN_REQ()\fP, \fBPARAM_STRING_IN_REQ()\fP, \fBPARAM_VECTOR_IN_REQ()\fP, PARAM_INT_OUT_REQ(), PARAM_DOUBLE_OUT_REQ(), PARAM_VECTOR_OUT_REQ(), PARAM_STRING_OUT_REQ()\&.
.RE
.PP
\fBParameters\fP
.RS 4
\fILONG_DESC\fP Long string describing what the program does\&. Newlines should not be used here; this is taken care of by IO (however, you can explicitly specify newlines to denote new paragraphs)\&. You can also use printing macros like PRINT_PARAM_STRING(), PRINT_DATASET(), and others\&. 
.RE
.PP

.PP
Definition at line 98 of file param\&.hpp\&.
.SS "#define BINDING_NAME(NAME)"
\fBValue:\fP
.PP
.nf
    static \
    mlpack::util::ProgramName \
    io_programname_dummy_object = mlpack::util::ProgramName(NAME);
.fi
.PP
Specify the program name of a binding\&. Only one instance of this macro should be present in your program! Therefore, use it in the main\&.cpp (or corresponding binding) in your program\&.
.PP
\fBSee also\fP
.RS 4
\fBmlpack::IO\fP, \fBPARAM_FLAG()\fP, \fBPARAM_INT_IN()\fP, \fBPARAM_DOUBLE_IN()\fP, \fBPARAM_STRING_IN()\fP, \fBPARAM_VECTOR_IN()\fP, \fBPARAM_INT_OUT()\fP, \fBPARAM_DOUBLE_OUT()\fP, \fBPARAM_VECTOR_OUT()\fP, \fBPARAM_INT_IN_REQ()\fP, \fBPARAM_DOUBLE_IN_REQ()\fP, \fBPARAM_STRING_IN_REQ()\fP, \fBPARAM_VECTOR_IN_REQ()\fP, PARAM_INT_OUT_REQ(), PARAM_DOUBLE_OUT_REQ(), PARAM_VECTOR_OUT_REQ(), PARAM_STRING_OUT_REQ()\&.
.RE
.PP
\fBParameters\fP
.RS 4
\fINAME\fP Short string representing the name of the program\&. 
.RE
.PP

.PP
Definition at line 57 of file param\&.hpp\&.
.SS "#define BINDING_SEE_ALSO(DESCRIPTION, LINK)"
\fBValue:\fP
.PP
.nf
      static \
      mlpack::util::SeeAlso \
      JOIN(JOIN(io_programsee_also_dummy_object_, __LINE__), opt) = \
      mlpack::util::SeeAlso(DESCRIPTION, LINK);
.fi
.PP
Specify the see-also of a binding\&. Mutiple instance of this macro can be present in your program! Therefore, use it in the main\&.cpp (or corresponding binding) in your program\&.
.PP
\fBSee also\fP
.RS 4
\fBmlpack::IO\fP, \fBPARAM_FLAG()\fP, \fBPARAM_INT_IN()\fP, \fBPARAM_DOUBLE_IN()\fP, \fBPARAM_STRING_IN()\fP, \fBPARAM_VECTOR_IN()\fP, \fBPARAM_INT_OUT()\fP, \fBPARAM_DOUBLE_OUT()\fP, \fBPARAM_VECTOR_OUT()\fP, \fBPARAM_INT_IN_REQ()\fP, \fBPARAM_DOUBLE_IN_REQ()\fP, \fBPARAM_STRING_IN_REQ()\fP, \fBPARAM_VECTOR_IN_REQ()\fP, PARAM_INT_OUT_REQ(), PARAM_DOUBLE_OUT_REQ(), PARAM_VECTOR_OUT_REQ(), PARAM_STRING_OUT_REQ()\&.
.RE
.PP
Provide a link for a binding's 'see also' documentation section, which is primarily (but not necessarily exclusively) used by the Markdown bindings This link can be specified by calling SEE_ALSO('description', 'link'), where 'description' is the description of the link and 'link' may be one of the following:
.PP
.IP "\(bu" 2
A direct URL, starting with http:// or https://\&.
.IP "\(bu" 2
A page anchor for documentation, referencing another binding by its CMake binding name, i\&.e\&. '#knn'\&.
.IP "\(bu" 2
A link to a Doxygen page, using the mangled Doxygen name after a '@doxygen/', i\&.e\&., '@doxygen/mlpack1_1_adaboost1_1_AdaBoost'\&. 
.PP

.PP
Definition at line 163 of file param\&.hpp\&.
.SS "#define BINDING_SHORT_DESC(SHORT_DESC)"
\fBValue:\fP
.PP
.nf
    static \
    mlpack::util::ShortDescription \
    io_programshort_desc_dummy_object = mlpack::util::ShortDescription( \
    SHORT_DESC);
.fi
.PP
Specify the short description of a binding\&. Only one instance of this macro should be present in your program! Therefore, use it in the main\&.cpp (or corresponding binding) in your program\&.
.PP
\fBSee also\fP
.RS 4
\fBmlpack::IO\fP, \fBPARAM_FLAG()\fP, \fBPARAM_INT_IN()\fP, \fBPARAM_DOUBLE_IN()\fP, \fBPARAM_STRING_IN()\fP, \fBPARAM_VECTOR_IN()\fP, \fBPARAM_INT_OUT()\fP, \fBPARAM_DOUBLE_OUT()\fP, \fBPARAM_VECTOR_OUT()\fP, \fBPARAM_INT_IN_REQ()\fP, \fBPARAM_DOUBLE_IN_REQ()\fP, \fBPARAM_STRING_IN_REQ()\fP, \fBPARAM_VECTOR_IN_REQ()\fP, PARAM_INT_OUT_REQ(), PARAM_DOUBLE_OUT_REQ(), PARAM_VECTOR_OUT_REQ(), PARAM_STRING_OUT_REQ()\&.
.RE
.PP
\fBParameters\fP
.RS 4
\fISHORT_DESC\fP Short two-sentence description of the program; it should describe what the program implements and does, and a quick overview of how it can be used and what it should be used for\&. 
.RE
.PP

.PP
Definition at line 76 of file param\&.hpp\&.
.SS "#define PARAM(T, ID, DESC, ALIAS, NAME, REQ, IN, TRANS, DEF)"
\fBValue:\fP
.PP
.nf
      static mlpack::util::Option<T> \
      JOIN(JOIN(io_option_dummy_object_in_, __LINE__), opt) \
      (DEF, ID, DESC, ALIAS, NAME, REQ, IN, !TRANS, testName);
.fi
.PP
Define the \fBPARAM()\fP, \fBPARAM_MODEL()\fP macro\&. Don't use this function; use the other ones above that call it\&. Note that we are using the \fBLINE\fP macro for naming these actual parameters when \fBCOUNTER\fP does not exist, which is a bit of an ugly hack\&.\&.\&. but this is the preprocessor, after all\&. We don't have much choice other than ugliness\&.
.PP
\fBParameters\fP
.RS 4
\fIT\fP Type of the parameter\&. 
.br
\fIID\fP Name of the parameter\&. 
.br
\fIDESC\fP Description of the parameter (1-2 sentences)\&. Don't use printing macros like PRINT_PARAM_STRING() or PRINT_DATASET() or others here---it will cause problems\&. 
.br
\fIALIAS\fP Alias for this parameter (one letter)\&. 
.br
\fIDEF\fP Default value of the parameter\&. 
.br
\fIREQ\fP Whether or not parameter is required (boolean value)\&. 
.RE
.PP

.PP
Definition at line 1277 of file param\&.hpp\&.
.SS "#define PARAM_COL(ID, DESC, ALIAS, REQ, TRANS, IN)"
\fBValue:\fP
.PP
.nf
    PARAM(arma::vec, ID, DESC, ALIAS, "arma::vec", REQ, IN, TRANS, \
        arma::vec());
.fi
.PP
Definition at line 1228 of file param\&.hpp\&.
.SS "#define PARAM_COL_IN(ID, DESC, ALIAS)       \fBPARAM_COL\fP(ID, DESC, ALIAS, false, true, true)"

.PP
Define a vector input parameter (type arma::vec)\&. From the command line, the user can specify the file that holds the vector, using the name of the vector parameter with '_file' appended (and the same alias)\&. So for instance, if the name of the vector parameter was 'vec', the user could specify that the 'vec' vector was held in vec\&.csv by giving the parameter:
.PP
.PP
.nf
--vec_file vector\&.csv
.fi
.PP
.PP
\fBParameters\fP
.RS 4
\fIID\fP Name of the parameter\&. 
.br
\fIDESC\fP Description of the parameter (1-2 sentences)\&. Don't use printing macros like PRINT_PARAM_STRING() or PRINT_DATASET() or others here---it will cause problems\&. 
.br
\fIALIAS\fP An alias for the parameter (one letter)\&.
.RE
.PP
\fBBug\fP
.RS 4
The \fBCOUNTER\fP variable is used in most cases to guarantee a unique global identifier for options declared using the PARAM_*() macros\&. However, not all compilers have this support--most notably, gcc < 4\&.3\&. In that case, the \fBLINE\fP macro is used as an attempt to get a unique global identifier, but collisions are still possible, and they produce bizarre error messages\&. See https://github.com/mlpack/mlpack/issues/100 for more information\&. 
.RE
.PP

.PP
Definition at line 670 of file param\&.hpp\&.
.SS "#define PARAM_COL_IN_REQ(ID, DESC, ALIAS)       \fBPARAM_COL\fP(ID, DESC, ALIAS, true, true, true)"

.PP
Define a required vector input parameter (type arma::vec)\&. From the command line, the user can specify the file that holds the vector, using the name of the vector parameter with '_file' appended (and the same alias)\&. So for instance, if the name of the vector parameter was 'vec', the user could specify that the 'vec' vector was held in vec\&.csv by giving the parameter:
.PP
.PP
.nf
--vec_file vector\&.csv
.fi
.PP
.PP
\fBParameters\fP
.RS 4
\fIID\fP Name of the parameter\&. 
.br
\fIDESC\fP Description of the parameter (1-2 sentences)\&. Don't use printing macros like PRINT_PARAM_STRING() or PRINT_DATASET() or others here---it will cause problems\&. 
.br
\fIALIAS\fP An alias for the parameter (one letter)\&.
.RE
.PP
\fBBug\fP
.RS 4
The \fBCOUNTER\fP variable is used in most cases to guarantee a unique global identifier for options declared using the PARAM_*() macros\&. However, not all compilers have this support--most notably, gcc < 4\&.3\&. In that case, the \fBLINE\fP macro is used as an attempt to get a unique global identifier, but collisions are still possible, and they produce bizarre error messages\&. See https://github.com/mlpack/mlpack/issues/100 for more information\&. 
.RE
.PP

.PP
Definition at line 698 of file param\&.hpp\&.
.SS "#define PARAM_COL_OUT(ID, DESC, ALIAS)       \fBPARAM_COL\fP(ID, DESC, ALIAS, false, true, false)"

.PP
Define a vector output parameter (type arma::vec)\&. When the program terminates, the vector will be saved to whatever it was set to during the program\&. From the command-line, the user may specify the file in which to save the output vector using a string option that is the name of the matrix parameter with '_file' appended\&. So, for instance, if the name of the output vector parameter was 'vec', the user could specify that the 'vec' vector should be saved in vector\&.csv by giving the parameter:
.PP
.PP
.nf
--vec_file vector\&.csv
.fi
.PP
.PP
The output vector will not be printed on stdout, like the other output option types\&.
.PP
\fBParameters\fP
.RS 4
\fIID\fP Name of the parameter\&. 
.br
\fIDESC\fP Description of the parameter (1-2 sentences)\&. Don't use printing macros like PRINT_PARAM_STRING() or PRINT_DATASET() or others here---it will cause problems\&. 
.br
\fIALIAS\fP An alias for the parameter (one letter)\&.
.RE
.PP
\fBBug\fP
.RS 4
The \fBCOUNTER\fP variable is used in most cases to guarantee a unique global identifier for options declared using the PARAM_*() macros\&. However, not all compilers have this support--most notably, gcc < 4\&.3\&. In that case, the \fBLINE\fP macro is used as an attempt to get a unique global identifier, but collisions are still possible, and they produce bizarre error messages\&. See https://github.com/mlpack/mlpack/issues/100 for more information\&. 
.RE
.PP

.PP
Definition at line 816 of file param\&.hpp\&.
.SS "#define PARAM_DOUBLE_IN(ID, DESC, ALIAS, DEF)       \fBPARAM_IN\fP(double, ID, DESC, ALIAS, DEF, false)"

.PP
Define a double input parameter\&. The parameter can then be specified on the command line with --ID=value\&.
.PP
\fBParameters\fP
.RS 4
\fIID\fP Name of the parameter\&. 
.br
\fIDESC\fP Quick description of the parameter (1-2 sentences)\&. Don't use printing macros like PRINT_PARAM_STRING() or PRINT_DATASET() or others here---it will cause problems\&. 
.br
\fIALIAS\fP An alias for the parameter (one letter)\&. 
.br
\fIDEF\fP Default value of the parameter\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBmlpack::IO\fP, \fBBINDING_NAME()\fP, \fBBINDING_SHORT_DESC()\fP, \fBBINDING_LONG_DESC()\fP, \fBBINDING_EXAMPLE()\fP and \fBBINDING_SEE_ALSO()\fP\&.
.RE
.PP
\fBBug\fP
.RS 4
The \fBCOUNTER\fP variable is used in most cases to guarantee a unique global identifier for options declared using the PARAM_*() macros\&. However, not all compilers have this support--most notably, gcc < 4\&.3\&. In that case, the \fBLINE\fP macro is used as an attempt to get a unique global identifier, but collisions are still possible, and they produce bizarre error messages\&. See https://github.com/mlpack/mlpack/issues/100 for more information\&. 
.RE
.PP

.PP
Definition at line 275 of file param\&.hpp\&.
.SS "#define PARAM_DOUBLE_IN_REQ(ID, DESC, ALIAS)       \fBPARAM_IN\fP(double, ID, DESC, ALIAS, 0\&.0, true)"

.PP
Define a required double parameter\&. The parameter must then be specified on the command line with --ID=value\&.
.PP
\fBParameters\fP
.RS 4
\fIID\fP Name of the parameter\&. 
.br
\fIDESC\fP Quick description of the parameter (1-2 sentences)\&. Don't use printing macros like PRINT_PARAM_STRING() or PRINT_DATASET() or others here---it will cause problems\&. 
.br
\fIALIAS\fP An alias for the parameter (one letter)\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBmlpack::IO\fP, \fBBINDING_NAME()\fP, \fBBINDING_SHORT_DESC()\fP, \fBBINDING_LONG_DESC()\fP, \fBBINDING_EXAMPLE()\fP and \fBBINDING_SEE_ALSO()\fP\&.
.RE
.PP
\fBBug\fP
.RS 4
The \fBCOUNTER\fP variable is used in most cases to guarantee a unique global identifier for options declared using the PARAM_*() macros\&. However, not all compilers have this support--most notably, gcc < 4\&.3\&. In that case, the \fBLINE\fP macro is used as an attempt to get a unique global identifier, but collisions are still possible, and they produce bizarre error messages\&. See https://github.com/mlpack/mlpack/issues/100 for more information\&. 
.RE
.PP

.PP
Definition at line 1156 of file param\&.hpp\&.
.SS "#define PARAM_DOUBLE_OUT(ID, DESC)       \fBPARAM_OUT\fP(double, ID, DESC, '', 0\&.0, false)"

.PP
Define a double output parameter\&. This parameter will be printed on stdout at the end of the program; for instance, if the parameter name is 'number' and the value is 5\&.012, the output on stdout would be of the following form:
.PP
.PP
.nf
number: 5\&.012
.fi
.PP
.PP
If the parameter is not set by the end of the program, a fatal runtime error will be issued\&.
.PP
\fBParameters\fP
.RS 4
\fIID\fP Name of the parameter\&. 
.br
\fIDESC\fP Quick description of the parameter (1-2 sentences)\&. Don't use printing macros like PRINT_PARAM_STRING() or PRINT_DATASET() or others here---it will cause problems\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBmlpack::IO\fP, \fBBINDING_NAME()\fP, \fBBINDING_SHORT_DESC()\fP, \fBBINDING_LONG_DESC()\fP, \fBBINDING_EXAMPLE()\fP and \fBBINDING_SEE_ALSO()\fP\&.
.RE
.PP
\fBBug\fP
.RS 4
The \fBCOUNTER\fP variable is used in most cases to guarantee a unique global identifier for options declared using the PARAM_*() macros\&. However, not all compilers have this support--most notably, gcc < 4\&.3\&. In that case, the \fBLINE\fP macro is used as an attempt to get a unique global identifier, but collisions are still possible, and they produce bizarre error messages\&. See https://github.com/mlpack/mlpack/issues/100 for more information\&. 
.RE
.PP

.PP
Definition at line 306 of file param\&.hpp\&.
.SS "#define PARAM_FLAG(ID, DESC, ALIAS)       \fBPARAM_IN\fP(bool, ID, DESC, ALIAS, false, false);"

.PP
Define a flag parameter\&. 
.PP
\fBParameters\fP
.RS 4
\fIID\fP Name of the parameter\&. 
.br
\fIDESC\fP Quick description of the parameter (1-2 sentences)\&. Don't use printing macros like PRINT_PARAM_STRING() or PRINT_DATASET() or others here---it will cause problems\&. 
.br
\fIALIAS\fP An alias for the parameter (one letter)\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBmlpack::IO\fP, \fBBINDING_NAME()\fP, \fBBINDING_SHORT_DESC()\fP, \fBBINDING_LONG_DESC()\fP, \fBBINDING_EXAMPLE()\fP and \fBBINDING_SEE_ALSO()\fP\&.
.RE
.PP
\fBBug\fP
.RS 4
The \fBCOUNTER\fP variable is used in most cases to guarantee a unique global identifier for options declared using the PARAM_*() macros\&. However, not all compilers have this support--most notably, gcc < 4\&.3\&. In that case, the \fBLINE\fP macro is used as an attempt to get a unique global identifier, but collisions are still possible, and they produce bizarre error messages\&. See https://github.com/mlpack/mlpack/issues/100 for more information\&. 
.RE
.PP

.PP
Definition at line 189 of file param\&.hpp\&.
.SS "#define PARAM_IN(T, ID, DESC, ALIAS, DEF, REQ)       \fBPARAM\fP(T, ID, DESC, ALIAS, #T, REQ, true, false, DEF);"

.PP
Defining useful macros using PARAM macro defined later\&. 
.PP
Definition at line 1214 of file param\&.hpp\&.
.SS "#define PARAM_INT_IN(ID, DESC, ALIAS, DEF)       \fBPARAM_IN\fP(int, ID, DESC, ALIAS, DEF, false)"

.PP
Define an integer input parameter\&. The parameter can then be specified on the command line with --ID=value\&.
.PP
\fBParameters\fP
.RS 4
\fIID\fP Name of the parameter\&. 
.br
\fIDESC\fP Quick description of the parameter (1-2 sentences)\&. Don't use printing macros like PRINT_PARAM_STRING() or PRINT_DATASET() or others here---it will cause problems\&. 
.br
\fIALIAS\fP An alias for the parameter (one letter)\&. 
.br
\fIDEF\fP Default value of the parameter\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBmlpack::IO\fP, \fBBINDING_NAME()\fP, \fBBINDING_SHORT_DESC()\fP, \fBBINDING_LONG_DESC()\fP, \fBBINDING_EXAMPLE()\fP and \fBBINDING_SEE_ALSO()\fP\&.
.RE
.PP
\fBBug\fP
.RS 4
Use a forward declaration of the class\&. The \fBCOUNTER\fP variable is used in most cases to guarantee a unique global identifier for options declared using the PARAM_*() macros\&. However, not all compilers have this support--most notably, gcc < 4\&.3\&. In that case, the \fBLINE\fP macro is used as an attempt to get a unique global identifier, but collisions are still possible, and they produce bizarre error messages\&. See https://github.com/mlpack/mlpack/issues/100 for more information\&.
.RE
.PP

.PP
Definition at line 217 of file param\&.hpp\&.
.SS "#define PARAM_INT_IN_REQ(ID, DESC, ALIAS)       \fBPARAM_IN\fP(int, ID, DESC, ALIAS, 0, true)"

.PP
Define a required integer input parameter\&. The parameter must then be specified on the command line with --ID=value\&.
.PP
\fBParameters\fP
.RS 4
\fIID\fP Name of the parameter\&. 
.br
\fIDESC\fP Quick description of the parameter (1-2 sentences)\&. Don't use printing macros like PRINT_PARAM_STRING() or PRINT_DATASET() or others here---it will cause problems\&. 
.br
\fIALIAS\fP An alias for the parameter (one letter)\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBmlpack::IO\fP, \fBBINDING_NAME()\fP, \fBBINDING_SHORT_DESC()\fP, \fBBINDING_LONG_DESC()\fP, \fBBINDING_EXAMPLE()\fP and \fBBINDING_SEE_ALSO()\fP\&.
.RE
.PP
\fBBug\fP
.RS 4
The \fBCOUNTER\fP variable is used in most cases to guarantee a unique global identifier for options declared using the PARAM_*() macros\&. However, not all compilers have this support--most notably, gcc < 4\&.3\&. In that case, the \fBLINE\fP macro is used as an attempt to get a unique global identifier, but collisions are still possible, and they produce bizarre error messages\&. See https://github.com/mlpack/mlpack/issues/100 for more information\&. 
.RE
.PP

.PP
Definition at line 1131 of file param\&.hpp\&.
.SS "#define PARAM_INT_OUT(ID, DESC)       \fBPARAM_OUT\fP(int, ID, DESC, '', 0, false)"

.PP
Define an integer output parameter\&. This parameter will be printed on stdout at the end of the program; for instance, if the parameter name is 'number' and the value is 5, the output on stdout would be of the following form:
.PP
.PP
.nf
number: 5
.fi
.PP
.PP
If the parameter is not set by the end of the program, a fatal runtime error will be issued\&.
.PP
\fBParameters\fP
.RS 4
\fIID\fP Name of the parameter\&. 
.br
\fIDESC\fP Quick description of the parameter (1-2 sentences)\&. Don't use printing macros like PRINT_PARAM_STRING() or PRINT_DATASET() or others here---it will cause problems\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBmlpack::IO\fP, \fBBINDING_NAME()\fP, \fBBINDING_SHORT_DESC()\fP, \fBBINDING_LONG_DESC()\fP, \fBBINDING_EXAMPLE()\fP and \fBBINDING_SEE_ALSO()\fP\&.
.RE
.PP
\fBBug\fP
.RS 4
The \fBCOUNTER\fP variable is used in most cases to guarantee a unique global identifier for options declared using the PARAM_*() macros\&. However, not all compilers have this support--most notably, gcc < 4\&.3\&. In that case, the \fBLINE\fP macro is used as an attempt to get a unique global identifier, but collisions are still possible, and they produce bizarre error messages\&. See https://github.com/mlpack/mlpack/issues/100 for more information\&. 
.RE
.PP

.PP
Definition at line 248 of file param\&.hpp\&.
.SS "#define PARAM_MATRIX(ID, DESC, ALIAS, REQ, TRANS, IN)"
\fBValue:\fP
.PP
.nf
    PARAM(arma::mat, ID, DESC, ALIAS, "arma::mat", REQ, IN, \
        TRANS, arma::mat());
.fi
.PP
Definition at line 1220 of file param\&.hpp\&.
.SS "#define PARAM_MATRIX_AND_INFO_IN(ID, DESC, ALIAS)"
\fBValue:\fP
.PP
.nf
    PARAM(TUPLE_TYPE, ID, DESC, ALIAS, \
        "std::tuple<mlpack::data::DatasetInfo, arma::mat>", false, true, true, \
        TUPLE_TYPE())
.fi
.PP
Definition at line 1017 of file param\&.hpp\&.
.SS "#define PARAM_MATRIX_IN(ID, DESC, ALIAS)       \fBPARAM_MATRIX\fP(ID, DESC, ALIAS, false, true, true)"

.PP
Define a matrix input parameter\&. From the command line, the user can specify the file that holds the matrix, using the name of the matrix parameter with '_file' appended (and the same alias)\&. So for instance, if the name of the matrix parameter was 'mat', the user could specify that the 'mat' matrix was held in matrix\&.csv by giving the parameter
.PP
.PP
.nf
--mat_file matrix\&.csv
.fi
.PP
.PP
\fBParameters\fP
.RS 4
\fIID\fP Name of the parameter\&. 
.br
\fIDESC\fP Description of the parameter (1-2 sentences)\&. Don't use printing macros like PRINT_PARAM_STRING() or PRINT_DATASET() or others here---it will cause problems\&. 
.br
\fIALIAS\fP An alias for the parameter (one letter)\&.
.RE
.PP
\fBBug\fP
.RS 4
The \fBCOUNTER\fP variable is used in most cases to guarantee a unique global identifier for options declared using the PARAM_*() macros\&. However, not all compilers have this support--most notably, gcc < 4\&.3\&. In that case, the \fBLINE\fP macro is used as an attempt to get a unique global identifier, but collisions are still possible, and they produce bizarre error messages\&. See https://github.com/mlpack/mlpack/issues/100 for more information\&. 
.RE
.PP

.PP
Definition at line 395 of file param\&.hpp\&.
.SS "#define PARAM_MATRIX_IN_REQ(ID, DESC, ALIAS)       \fBPARAM_MATRIX\fP(ID, DESC, ALIAS, true, true, true)"

.PP
Define a required matrix input parameter\&. From the command line, the user can specify the file that holds the matrix, using the name of the matrix parameter with '_file' appended (and the same alias)\&. So for instance, if the name of the matrix parameter was 'mat', the user could specify that the 'mat' matrix was held in matrix\&.csv by giving the parameter
.PP
.PP
.nf
--mat_file matrix\&.csv
.fi
.PP
.PP
\fBParameters\fP
.RS 4
\fIID\fP Name of the parameter\&. 
.br
\fIDESC\fP Description of the parameter (1-2 sentences)\&. Don't use printing macros like PRINT_PARAM_STRING() or PRINT_DATASET() or others here---it will cause problems\&. 
.br
\fIALIAS\fP An alias for the parameter (one letter)\&.
.RE
.PP
\fBBug\fP
.RS 4
The \fBCOUNTER\fP variable is used in most cases to guarantee a unique global identifier for options declared using the PARAM_*() macros\&. However, not all compilers have this support--most notably, gcc < 4\&.3\&. In that case, the \fBLINE\fP macro is used as an attempt to get a unique global identifier, but collisions are still possible, and they produce bizarre error messages\&. See https://github.com/mlpack/mlpack/issues/100 for more information\&. 
.RE
.PP

.PP
Definition at line 423 of file param\&.hpp\&.
.SS "#define PARAM_MATRIX_OUT(ID, DESC, ALIAS)       \fBPARAM_MATRIX\fP(ID, DESC, ALIAS, false, true, false)"

.PP
Define a matrix output parameter\&. When the program terminates, the matrix will be saved to whatever it was set to by IO::GetParam<arma::mat>(ID) during the program\&. From the command-line, the user may specify the file in which to save the output matrix using a string option that is the name of the matrix parameter with '_file' appended\&. So, for instance, if the name of the output matrix parameter was 'mat', the user could speicfy that the 'mat' matrix should be saved in matrix\&.csv by giving the parameter
.PP
.PP
.nf
--mat_file matrix\&.csv
.fi
.PP
.PP
The output matrix will not be printed on stdout, like the other output option types\&.
.PP
\fBParameters\fP
.RS 4
\fIID\fP Name of the parameter\&. 
.br
\fIDESC\fP Description of the parameter (1-2 sentences)\&. Don't use printing macros like PRINT_PARAM_STRING() or PRINT_DATASET() or others here---it will cause problems\&. 
.br
\fIALIAS\fP An alias for the parameter (one letter)\&.
.RE
.PP
\fBBug\fP
.RS 4
The \fBCOUNTER\fP variable is used in most cases to guarantee a unique global identifier for options declared using the PARAM_*() macros\&. However, not all compilers have this support--most notably, gcc < 4\&.3\&. In that case, the \fBLINE\fP macro is used as an attempt to get a unique global identifier, but collisions are still possible, and they produce bizarre error messages\&. See https://github.com/mlpack/mlpack/issues/100 for more information\&. 
.RE
.PP

.PP
Definition at line 456 of file param\&.hpp\&.
.SS "#define PARAM_MODEL(TYPE, ID, DESC, ALIAS, REQ, IN)"
\fBValue:\fP
.PP
.nf
      static mlpack::util::Option<TYPE*> \
      JOIN(JOIN(io_option_dummy_object_model_, __LINE__), opt) \
      (nullptr, ID, DESC, ALIAS, #TYPE, REQ, IN, false, \
      testName);
.fi
.PP
Definition at line 1282 of file param\&.hpp\&.
.SS "#define PARAM_MODEL_IN(TYPE, ID, DESC, ALIAS)       \fBPARAM_MODEL\fP(TYPE, ID, DESC, ALIAS, false, true)"

.PP
Define an input model\&. From the command line, the user can specify the file that holds the model, using the name of the model parameter with '_file' appended (and the same alias)\&. So for instance, if the name of the model parameter was 'model', the user could specify that the 'model' model was held in model\&.bin by giving the parameter
.PP
.PP
.nf
--model_file model\&.bin
.fi
.PP
.PP
Note that the first parameter of this model is the type (the class name) of the model to be loaded\&. This model type must have a serialize() function; a compilation error (a very long and complex one) will result if the model type does not have the following function:
.PP
.PP
.nf
template<typename Archive>
void serialize(Archive& ar, const uint32_t version);
.fi
.PP
.PP
\fBParameters\fP
.RS 4
\fITYPE\fP Type of the model to be loaded\&. 
.br
\fIID\fP Name of the parameter\&. 
.br
\fIDESC\fP Description of the parameter\&. Don't use printing macros like PRINT_PARAM_STRING() or PRINT_DATASET() or others here---it will cause problems\&. 
.br
\fIALIAS\fP An alias for the parameter (one letter)\&. 
.RE
.PP

.PP
Definition at line 1050 of file param\&.hpp\&.
.SS "#define PARAM_MODEL_IN_REQ(TYPE, ID, DESC, ALIAS)       \fBPARAM_MODEL\fP(TYPE, ID, DESC, ALIAS, true, true)"

.PP
Define a required input model\&. From the command line, the user can specify the file that holds the model, using the name of the model parameter with '_file' appended (and the same alias)\&. So for instance, if the name of the model parameter was 'model', the user could specify that the 'model' model was held in model\&.bin by giving the parameter
.PP
.PP
.nf
--model_file model\&.bin
.fi
.PP
.PP
Note that the first parameter of this model is the type (the class name) of the model to be loaded\&. This model type must have a serialize() function; a compilation error (a very long and complex one) will result if the model type does not have the following function:
.PP
.PP
.nf
template<typename Archive>
void serialize(Archive& ar, const uint32_t version);
.fi
.PP
.PP
\fBParameters\fP
.RS 4
\fITYPE\fP Type of the model to be loaded\&. 
.br
\fIID\fP Name of the parameter\&. 
.br
\fIDESC\fP Description of the parameter\&. Don't use printing macros like PRINT_PARAM_STRING() or PRINT_DATASET() or others here---it will cause problems\&. 
.br
\fIALIAS\fP An alias for the parameter (one letter)\&. 
.RE
.PP

.PP
Definition at line 1081 of file param\&.hpp\&.
.SS "#define PARAM_MODEL_OUT(TYPE, ID, DESC, ALIAS)       \fBPARAM_MODEL\fP(TYPE, ID, DESC, ALIAS, false, false)"

.PP
Define an output model\&. From the command line, the user can specify the file that should hold the model, using the name of the model parameter with '_file' appended (and the same alias)\&. So for instance, if the user desires to save the model to model\&.bin and the parameter name is 'model', they could specify
.PP
.PP
.nf
--model_file model\&.bin
.fi
.PP
.PP
The model will be saved at the termination of the program\&. If you use a parameter of this type, you must call IO::Destroy() at the end of your program\&.
.PP
\fBParameters\fP
.RS 4
\fITYPE\fP Type of the model to be saved\&. 
.br
\fIID\fP Name of the parameter\&. 
.br
\fIDESC\fP Description of the parameter\&. Don't use printing macros like PRINT_PARAM_STRING() or PRINT_DATASET() or others here---it will cause problems\&. 
.br
\fIALIAS\fP An alias for the parameter (one letter)\&. 
.RE
.PP

.PP
Definition at line 1106 of file param\&.hpp\&.
.SS "#define PARAM_OUT(T, ID, DESC, ALIAS, DEF, REQ)       \fBPARAM\fP(T, ID, DESC, ALIAS, #T, REQ, false, false, DEF);"

.PP
Definition at line 1217 of file param\&.hpp\&.
.SS "#define PARAM_ROW(ID, DESC, ALIAS, REQ, TRANS, IN)"
\fBValue:\fP
.PP
.nf
    PARAM(arma::rowvec, ID, DESC, ALIAS, "arma::rowvec", REQ, IN, \
    TRANS, arma::rowvec());
.fi
.PP
Definition at line 1236 of file param\&.hpp\&.
.SS "#define PARAM_ROW_IN(ID, DESC, ALIAS)       \fBPARAM_ROW\fP(ID, DESC, ALIAS, false, true, true)"

.PP
Define a row vector input parameter (type arma::rowvec)\&. From the command line, the user can specify the file that holds the vector, using the name of the vector parameter with '_file' appended (and the same alias)\&. So for instance, if the name of the vector parameter was 'vec', the user could specify that the 'vec' vector was held in vec\&.csv by giving the parameter:
.PP
.PP
.nf
--vec_file vector\&.csv
.fi
.PP
.PP
\fBParameters\fP
.RS 4
\fIID\fP Name of the parameter\&. 
.br
\fIDESC\fP Description of the parameter (1-2 sentences)\&. Don't use printing macros like PRINT_PARAM_STRING() or PRINT_DATASET() or others here---it will cause problems\&. 
.br
\fIALIAS\fP An alias for the parameter (one letter)\&.
.RE
.PP
\fBBug\fP
.RS 4
The \fBCOUNTER\fP variable is used in most cases to guarantee a unique global identifier for options declared using the PARAM_*() macros\&. However, not all compilers have this support--most notably, gcc < 4\&.3\&. In that case, the \fBLINE\fP macro is used as an attempt to get a unique global identifier, but collisions are still possible, and they produce bizarre error messages\&. See https://github.com/mlpack/mlpack/issues/100 for more information\&. 
.RE
.PP

.PP
Definition at line 726 of file param\&.hpp\&.
.SS "#define PARAM_ROW_OUT(ID, DESC, ALIAS)       \fBPARAM_ROW\fP(ID, DESC, ALIAS, false, true, false)"

.PP
Define a row vector output parameter (type arma::rowvec)\&. When the program terminates, the vector will be saved to whatever it was set to during the program\&. From the command-line, the user may specify the file in which to save the output vector using a string option that is the name of the matrix parameter with '_file' appended\&. So, for instance, if the name of the output vector parameter was 'vec', the user could specify that the 'vec' vector should be saved in vector\&.csv by giving the parameter:
.PP
.PP
.nf
--vec_file vector\&.csv
.fi
.PP
.PP
The output vector will not be printed on stdout, like the other output option types\&.
.PP
\fBParameters\fP
.RS 4
\fIID\fP Name of the parameter\&. 
.br
\fIDESC\fP Description of the parameter (1-2 sentences)\&. Don't use printing macros like PRINT_PARAM_STRING() or PRINT_DATASET() or others here---it will cause problems\&. 
.br
\fIALIAS\fP An alias for the parameter (one letter)\&.
.RE
.PP
\fBBug\fP
.RS 4
The \fBCOUNTER\fP variable is used in most cases to guarantee a unique global identifier for options declared using the PARAM_*() macros\&. However, not all compilers have this support--most notably, gcc < 4\&.3\&. In that case, the \fBLINE\fP macro is used as an attempt to get a unique global identifier, but collisions are still possible, and they produce bizarre error messages\&. See https://github.com/mlpack/mlpack/issues/100 for more information\&. 
.RE
.PP

.PP
Definition at line 849 of file param\&.hpp\&.
.SS "#define PARAM_STRING_IN(ID, DESC, ALIAS, DEF)       \fBPARAM_IN\fP(std::string, ID, DESC, ALIAS, DEF, false)"

.PP
Define a string input parameter\&. The parameter can then be specified on the command line with --ID=value\&. If ALIAS is equal to DEF_MOD (which is set using the \fBBINDING_LONG_DESC()\fP macro), the parameter can be specified with just --ID=value\&.
.PP
\fBParameters\fP
.RS 4
\fIID\fP Name of the parameter\&. 
.br
\fIDESC\fP Quick description of the parameter (1-2 sentences)\&. Don't use printing macros like PRINT_PARAM_STRING() or PRINT_DATASET() or others here---it will cause problems\&. 
.br
\fIALIAS\fP An alias for the parameter (one letter)\&. 
.br
\fIDEF\fP Default value of the parameter\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBmlpack::IO\fP, \fBBINDING_NAME()\fP, \fBBINDING_SHORT_DESC()\fP, \fBBINDING_LONG_DESC()\fP, \fBBINDING_EXAMPLE()\fP and \fBBINDING_SEE_ALSO()\fP\&.
.RE
.PP
\fBBug\fP
.RS 4
The \fBCOUNTER\fP variable is used in most cases to guarantee a unique global identifier for options declared using the PARAM_*() macros\&. However, not all compilers have this support--most notably, gcc < 4\&.3\&. In that case, the \fBLINE\fP macro is used as an attempt to get a unique global identifier, but collisions are still possible, and they produce bizarre error messages\&. See https://github.com/mlpack/mlpack/issues/100 for more information\&. 
.RE
.PP

.PP
Definition at line 335 of file param\&.hpp\&.
.SS "#define PARAM_STRING_IN_REQ(ID, DESC, ALIAS)       \fBPARAM_IN\fP(std::string, ID, DESC, ALIAS, '', true)"

.PP
Define a required string parameter\&. The parameter must then be specified on the command line with --ID=value\&.
.PP
\fBParameters\fP
.RS 4
\fIID\fP Name of the parameter\&. 
.br
\fIDESC\fP Quick description of the parameter (1-2 sentences)\&. Don't use printing macros like PRINT_PARAM_STRING() or PRINT_DATASET() or others here---it will cause problems\&. 
.br
\fIALIAS\fP An alias for the parameter (one letter)\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBmlpack::IO\fP, \fBBINDING_NAME()\fP, \fBBINDING_SHORT_DESC()\fP, \fBBINDING_LONG_DESC()\fP, \fBBINDING_EXAMPLE()\fP and \fBBINDING_SEE_ALSO()\fP\&.
.RE
.PP
\fBBug\fP
.RS 4
The \fBCOUNTER\fP variable is used in most cases to guarantee a unique global identifier for options declared using the PARAM_*() macros\&. However, not all compilers have this support--most notably, gcc < 4\&.3\&. In that case, the \fBLINE\fP macro is used as an attempt to get a unique global identifier, but collisions are still possible, and they produce bizarre error messages\&. See https://github.com/mlpack/mlpack/issues/100 for more information\&. 
.RE
.PP

.PP
Definition at line 1181 of file param\&.hpp\&.
.SS "#define PARAM_STRING_OUT(ID, DESC, ALIAS)       \fBPARAM_OUT\fP(std::string, ID, DESC, ALIAS, '', false)"

.PP
Define a string output parameter\&. The string will be printed to stdout at the end of the program\&. For instance, if there was a string output parameter called 'something' with value 'hello', at the end of the program the output would be of the following form:
.PP
.PP
.nf
something: "hello"
.fi
.PP
.PP
\fBParameters\fP
.RS 4
\fIID\fP Name of the parameter\&. 
.br
\fIDESC\fP Quick description of the parameter (1-2 sentences)\&. Don't use printing macros like PRINT_PARAM_STRING() or PRINT_DATASET() or others here---it will cause problems\&. 
.br
\fIALIAS\fP An alias for the parameter (one letter)\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBmlpack::IO\fP, \fBBINDING_NAME()\fP, \fBBINDING_SHORT_DESC()\fP, \fBBINDING_LONG_DESC()\fP, \fBBINDING_EXAMPLE()\fP and \fBBINDING_SEE_ALSO()\fP\&.
.RE
.PP
\fBBug\fP
.RS 4
The \fBCOUNTER\fP variable is used in most cases to guarantee a unique global identifier for options declared using the PARAM_*() macros\&. However, not all compilers have this support--most notably, gcc < 4\&.3\&. In that case, the \fBLINE\fP macro is used as an attempt to get a unique global identifier, but collisions are still possible, and they produce bizarre error messages\&. See https://github.com/mlpack/mlpack/issues/100 for more information\&. 
.RE
.PP

.PP
Definition at line 367 of file param\&.hpp\&.
.SS "#define PARAM_TMATRIX_IN(ID, DESC, ALIAS)       \fBPARAM_MATRIX\fP(ID, DESC, ALIAS, false, false, true)"

.PP
Define a transposed matrix input parameter\&. This is useful when data is desired in row-major form instead of the usual column-major form\&. From the command line, the user can specify the file that holds the matrix, using the name of the matrix parameter with '_file' appended (and the same alias)\&. So for instance, if the name of the matrix parameter was 'mat', the user could specify that the 'mat' matrix was held in matrix\&.csv by giving the parameter
.PP
.PP
.nf
--mat_file matrix\&.csv
.fi
.PP
.PP
\fBParameters\fP
.RS 4
\fIID\fP Name of the parameter\&. 
.br
\fIDESC\fP Description of the parameter (1-2 sentences)\&. Don't use printing macros like PRINT_PARAM_STRING() or PRINT_DATASET() or others here---it will cause problems\&. 
.br
\fIALIAS\fP An alias for the parameter (one letter)\&.
.RE
.PP
\fBBug\fP
.RS 4
The \fBCOUNTER\fP variable is used in most cases to guarantee a unique global identifier for options declared using the PARAM_*() macros\&. However, not all compilers have this support--most notably, gcc < 4\&.3\&. In that case, the \fBLINE\fP macro is used as an attempt to get a unique global identifier, but collisions are still possible, and they produce bizarre error messages\&. See https://github.com/mlpack/mlpack/issues/100 for more information\&. 
.RE
.PP

.PP
Definition at line 485 of file param\&.hpp\&.
.SS "#define PARAM_TMATRIX_IN_REQ(ID, DESC, ALIAS)       \fBPARAM_MATRIX\fP(ID, DESC, ALIAS, true, false, true)"

.PP
Define a required transposed matrix input parameter\&. This is useful when data is desired in row-major form instead of the usual column-major form\&. From the command line, the user can specify the file that holds the matrix, using the name of the matrix parameter with '_file' appended (and the same alias)\&. So for instance, if the name of the matrix parameter was 'mat', the user could specify that the 'mat' matrix was held in matrix\&.csv by giving the parameter
.PP
.PP
.nf
--mat_file matrix\&.csv
.fi
.PP
.PP
\fBParameters\fP
.RS 4
\fIID\fP Name of the parameter\&. 
.br
\fIDESC\fP Description of the parameter (1-2 sentences)\&. Don't use printing macros like PRINT_PARAM_STRING() or PRINT_DATASET() or others here---it will cause problems\&. 
.br
\fIALIAS\fP An alias for the parameter (one letter)\&.
.RE
.PP
\fBBug\fP
.RS 4
The \fBCOUNTER\fP variable is used in most cases to guarantee a unique global identifier for options declared using the PARAM_*() macros\&. However, not all compilers have this support--most notably, gcc < 4\&.3\&. In that case, the \fBLINE\fP macro is used as an attempt to get a unique global identifier, but collisions are still possible, and they produce bizarre error messages\&. See https://github.com/mlpack/mlpack/issues/100 for more information\&. 
.RE
.PP

.PP
Definition at line 515 of file param\&.hpp\&.
.SS "#define PARAM_TMATRIX_OUT(ID, DESC, ALIAS)       \fBPARAM_MATRIX\fP(ID, DESC, ALIAS, false, false, false)"

.PP
Define a transposed matrix output parameter\&. This is useful when data is stored in a row-major form instead of the usual column-major form\&. When the program terminates, the matrix will be saved to whatever it was set to by IO::GetParam<arma::mat>(ID) during the program\&. From the command-line, the user may specify the file in which to save the output matrix using a string option that is the name of the matrix parameter with '_file' appended\&. So, for instance, if the name of the output matrix parameter was 'mat', the user could speicfy that the 'mat' matrix should be saved in matrix\&.csv by giving the parameter
.PP
.PP
.nf
--mat_file matrix\&.csv
.fi
.PP
.PP
The output matrix will not be printed on stdout, like the other output option types\&.
.PP
\fBParameters\fP
.RS 4
\fIID\fP Name of the parameter\&. 
.br
\fIDESC\fP Description of the parameter (1-2 sentences)\&. Don't use printing macros like PRINT_PARAM_STRING() or PRINT_DATASET() or others here---it will cause problems\&. 
.br
\fIALIAS\fP An alias for the parameter (one letter)\&.
.RE
.PP
\fBBug\fP
.RS 4
The \fBCOUNTER\fP variable is used in most cases to guarantee a unique global identifier for options declared using the PARAM_*() macros\&. However, not all compilers have this support--most notably, gcc < 4\&.3\&. In that case, the \fBLINE\fP macro is used as an attempt to get a unique global identifier, but collisions are still possible, and they produce bizarre error messages\&. See https://github.com/mlpack/mlpack/issues/100 for more information\&. 
.RE
.PP

.PP
Definition at line 550 of file param\&.hpp\&.
.SS "#define PARAM_UCOL(ID, DESC, ALIAS, REQ, TRANS, IN)"
\fBValue:\fP
.PP
.nf
    PARAM(arma::Col<size_t>, ID, DESC, ALIAS, "arma::Col<size_t>", \
        REQ, IN, TRANS, arma::Col<size_t>());
.fi
.PP
Definition at line 1232 of file param\&.hpp\&.
.SS "#define PARAM_UCOL_IN(ID, DESC, ALIAS)       \fBPARAM_UCOL\fP(ID, DESC, ALIAS, false, true, true)"

.PP
Define an unsigned vector input parameter (type arma::Col<size_t>)\&. From the command line, the user can specify the file that holds the vector, using the name of the vector parameter with '_file' appended (and the same alias)\&. So for instance, if the name of the vector parameter was 'vec', the user could specify that the 'vec' vector was held in vec\&.csv by giving the parameter:
.PP
.PP
.nf
--vec_file vector\&.csv
.fi
.PP
.PP
\fBParameters\fP
.RS 4
\fIID\fP Name of the parameter\&. 
.br
\fIDESC\fP Description of the parameter (1-2 sentences)\&. Don't use printing macros like PRINT_PARAM_STRING() or PRINT_DATASET() or others here---it will cause problems\&. 
.br
\fIALIAS\fP An alias for the parameter (one letter)\&.
.RE
.PP
\fBBug\fP
.RS 4
The \fBCOUNTER\fP variable is used in most cases to guarantee a unique global identifier for options declared using the PARAM_*() macros\&. However, not all compilers have this support--most notably, gcc < 4\&.3\&. In that case, the \fBLINE\fP macro is used as an attempt to get a unique global identifier, but collisions are still possible, and they produce bizarre error messages\&. See https://github.com/mlpack/mlpack/issues/100 for more information\&. 
.RE
.PP

.PP
Definition at line 754 of file param\&.hpp\&.
.SS "#define PARAM_UCOL_OUT(ID, DESC, ALIAS)       \fBPARAM_UCOL\fP(ID, DESC, ALIAS, false, true, false)"

.PP
Define an unsigned vector output parameter (type arma::Col<size_t>)\&. When the program terminates, the vector will be saved to whatever it was set to during the program\&. From the command-line, the user may specify the file in which to save the output vector using a string option that is the name of the matrix parameter with '_file' appended\&. So, for instance, if the name of the output vector parameter was 'vec', the user could specify that the 'vec' vector should be saved in vector\&.csv by giving the parameter:
.PP
.PP
.nf
--vec_file vector\&.csv
.fi
.PP
.PP
The output vector will not be printed on stdout, like the other output option types\&.
.PP
\fBParameters\fP
.RS 4
\fIID\fP Name of the parameter\&. 
.br
\fIDESC\fP Description of the parameter (1-2 sentences)\&. Don't use printing macros like PRINT_PARAM_STRING() or PRINT_DATASET() or others here---it will cause problems\&. 
.br
\fIALIAS\fP An alias for the parameter (one letter)\&.
.RE
.PP
\fBBug\fP
.RS 4
The \fBCOUNTER\fP variable is used in most cases to guarantee a unique global identifier for options declared using the PARAM_*() macros\&. However, not all compilers have this support--most notably, gcc < 4\&.3\&. In that case, the \fBLINE\fP macro is used as an attempt to get a unique global identifier, but collisions are still possible, and they produce bizarre error messages\&. See https://github.com/mlpack/mlpack/issues/100 for more information\&. 
.RE
.PP

.PP
Definition at line 882 of file param\&.hpp\&.
.SS "#define PARAM_UMATRIX(ID, DESC, ALIAS, REQ, TRANS, IN)"
\fBValue:\fP
.PP
.nf
    PARAM(arma::Mat<size_t>, ID, DESC, ALIAS, "arma::Mat<size_t>", \
        REQ, IN, TRANS, arma::Mat<size_t>());
.fi
.PP
Definition at line 1224 of file param\&.hpp\&.
.SS "#define PARAM_UMATRIX_IN(ID, DESC, ALIAS)       \fBPARAM_UMATRIX\fP(ID, DESC, ALIAS, false, true, true)"

.PP
Define an unsigned matrix input parameter (arma::Mat<size_t>)\&. From the command line, the user can specify the file that holds the matrix, using the name of the matrix parameter with '_file' appended (and the same alias)\&. So for instance, if the name of the matrix parameter was 'mat', the user could specify that the 'mat' matrix was held in matrix\&.csv by giving the parameter
.PP
.PP
.nf
--mat_file matrix\&.csv
.fi
.PP
.PP
\fBParameters\fP
.RS 4
\fIID\fP Name of the parameter\&. 
.br
\fIDESC\fP Description of the parameter (1-2 sentences)\&. Don't use printing macros like PRINT_PARAM_STRING() or PRINT_DATASET() or others here---it will cause problems\&. 
.br
\fIALIAS\fP An alias for the parameter (one letter)\&.
.RE
.PP
\fBBug\fP
.RS 4
The \fBCOUNTER\fP variable is used in most cases to guarantee a unique global identifier for options declared using the PARAM_*() macros\&. However, not all compilers have this support--most notably, gcc < 4\&.3\&. In that case, the \fBLINE\fP macro is used as an attempt to get a unique global identifier, but collisions are still possible, and they produce bizarre error messages\&. See https://github.com/mlpack/mlpack/issues/100 for more information\&. 
.RE
.PP

.PP
Definition at line 578 of file param\&.hpp\&.
.SS "#define PARAM_UMATRIX_IN_REQ(ID, DESC, ALIAS)       \fBPARAM_UMATRIX\fP(ID, DESC, ALIAS, true, true, true)"

.PP
Define a required unsigned matrix input parameter (arma::Mat<size_t>)\&. From the command line, the user can specify the file that holds the matrix, using the name of the matrix parameter with '_file' appended (and the same alias)\&. So for instance, if the name of the matrix parameter was 'mat', the user could specify that the 'mat' matrix was held in matrix\&.csv by giving the parameter
.PP
.PP
.nf
--mat_file matrix\&.csv
.fi
.PP
.PP
\fBParameters\fP
.RS 4
\fIID\fP Name of the parameter\&. 
.br
\fIDESC\fP Description of the parameter (1-2 sentences)\&. Don't use printing macros like PRINT_PARAM_STRING() or PRINT_DATASET() or others here---it will cause problems\&. 
.br
\fIALIAS\fP An alias for the parameter (one letter)\&.
.RE
.PP
\fBBug\fP
.RS 4
The \fBCOUNTER\fP variable is used in most cases to guarantee a unique global identifier for options declared using the PARAM_*() macros\&. However, not all compilers have this support--most notably, gcc < 4\&.3\&. In that case, the \fBLINE\fP macro is used as an attempt to get a unique global identifier, but collisions are still possible, and they produce bizarre error messages\&. See https://github.com/mlpack/mlpack/issues/100 for more information\&. 
.RE
.PP

.PP
Definition at line 607 of file param\&.hpp\&.
.SS "#define PARAM_UMATRIX_OUT(ID, DESC, ALIAS)       \fBPARAM_UMATRIX\fP(ID, DESC, ALIAS, false, true, false)"

.PP
Define an unsigned matrix output parameter (arma::Mat<size_t>)\&. When the program terminates, the matrix will be saved to whatever it was set to by IO::GetParam<arma::Mat<size_t>>(ID) during the program\&. From the command-line, the user may specify the file in which to save the output matrix using a string option that is the name of the matrix parameter with '_file' appended\&. So, for instance, if the name of the output matrix parameter was 'mat', the user could speicfy that the 'mat' matrix should be saved in matrix\&.csv by giving the parameter
.PP
.PP
.nf
--mat_file matrix\&.csv
.fi
.PP
.PP
The output matrix will not be printed on stdout, like the other output option types\&.
.PP
\fBParameters\fP
.RS 4
\fIID\fP Name of the parameter\&. 
.br
\fIDESC\fP Description of the parameter (1-2 sentences)\&. Don't use printing macros like PRINT_PARAM_STRING() or PRINT_DATASET() or others here---it will cause problems\&. 
.br
\fIALIAS\fP An alias for the parameter (one letter)\&.
.RE
.PP
\fBBug\fP
.RS 4
The \fBCOUNTER\fP variable is used in most cases to guarantee a unique global identifier for options declared using the PARAM_*() macros\&. However, not all compilers have this support--most notably, gcc < 4\&.3\&. In that case, the \fBLINE\fP macro is used as an attempt to get a unique global identifier, but collisions are still possible, and they produce bizarre error messages\&. See https://github.com/mlpack/mlpack/issues/100 for more information\&. 
.RE
.PP

.PP
Definition at line 641 of file param\&.hpp\&.
.SS "#define PARAM_UROW(ID, DESC, ALIAS, REQ, TRANS, IN)"
\fBValue:\fP
.PP
.nf
    PARAM(arma::Row<size_t>, ID, DESC, ALIAS, "arma::Row<size_t>", \
    REQ, IN, TRANS, arma::Row<size_t>());
.fi
.PP
Definition at line 1240 of file param\&.hpp\&.
.SS "#define PARAM_UROW_IN(ID, DESC, ALIAS)       \fBPARAM_UROW\fP(ID, DESC, ALIAS, false, true, true)"

.PP
Define an unsigned row vector input parameter (type arma::Row<size_t>)\&. From the command line, the user can specify the file that holds the vector, using the name of the vector parameter with '_file' appended (and the same alias)\&. So for instance, if the name of the vector parameter was 'vec', the user could specify that the 'vec' vector was held in vec\&.csv by giving the parameter:
.PP
.PP
.nf
--vec_file vector\&.csv
.fi
.PP
.PP
\fBParameters\fP
.RS 4
\fIID\fP Name of the parameter\&. 
.br
\fIDESC\fP Description of the parameter (1-2 sentences)\&. Don't use printing macros like PRINT_PARAM_STRING() or PRINT_DATASET() or others here---it will cause problems\&. 
.br
\fIALIAS\fP An alias for the parameter (one letter)\&.
.RE
.PP
\fBBug\fP
.RS 4
The \fBCOUNTER\fP variable is used in most cases to guarantee a unique global identifier for options declared using the PARAM_*() macros\&. However, not all compilers have this support--most notably, gcc < 4\&.3\&. In that case, the \fBLINE\fP macro is used as an attempt to get a unique global identifier, but collisions are still possible, and they produce bizarre error messages\&. See https://github.com/mlpack/mlpack/issues/100 for more information\&. 
.RE
.PP

.PP
Definition at line 783 of file param\&.hpp\&.
.SS "#define PARAM_UROW_OUT(ID, DESC, ALIAS)       \fBPARAM_UROW\fP(ID, DESC, ALIAS, false, true, false)"

.PP
Define an unsigned row vector output parameter (type arma::Row<size_t>)\&. When the program terminates, the vector will be saved to whatever it was set to during the program\&. From the command-line, the user may specify the file in which to save the output vector using a string option that is the name of the matrix parameter with '_file' appended\&. So, for instance, if the name of the output vector parameter was 'vec', the user could specify that the 'vec' vector should be saved in vector\&.csv by giving the parameter:
.PP
.PP
.nf
--vec_file vector\&.csv
.fi
.PP
.PP
The output vector will not be printed on stdout, like the other output option types\&.
.PP
\fBParameters\fP
.RS 4
\fIID\fP Name of the parameter\&. 
.br
\fIDESC\fP Description of the parameter (1-2 sentences)\&. Don't use printing macros like PRINT_PARAM_STRING() or PRINT_DATASET() or others here---it will cause problems\&. 
.br
\fIALIAS\fP An alias for the parameter (one letter)\&.
.RE
.PP
\fBBug\fP
.RS 4
The \fBCOUNTER\fP variable is used in most cases to guarantee a unique global identifier for options declared using the PARAM_*() macros\&. However, not all compilers have this support--most notably, gcc < 4\&.3\&. In that case, the \fBLINE\fP macro is used as an attempt to get a unique global identifier, but collisions are still possible, and they produce bizarre error messages\&. See https://github.com/mlpack/mlpack/issues/100 for more information\&. 
.RE
.PP

.PP
Definition at line 915 of file param\&.hpp\&.
.SS "#define PARAM_VECTOR_IN(T, ID, DESC, ALIAS)       \fBPARAM_IN\fP(std::vector<T>, ID, DESC, ALIAS, std::vector<T>(), false)"

.PP
Define a std::vector input parameter\&. The parameter can then be specified on the command line with --ID=value1,value2,value3\&.
.PP
\fBParameters\fP
.RS 4
\fIT\fP Type of the parameter\&. 
.br
\fIID\fP Name of the parameter\&. 
.br
\fIDESC\fP Quick description of the parameter (1-2 sentences)\&. Don't use printing macros like PRINT_PARAM_STRING() or PRINT_DATASET() or others here---it will cause problems\&. 
.br
\fIALIAS\fP An alias for the parameter (one letter)\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBmlpack::IO\fP, \fBBINDING_NAME()\fP, \fBBINDING_SHORT_DESC()\fP, \fBBINDING_LONG_DESC()\fP, \fBBINDING_EXAMPLE()\fP and \fBBINDING_SEE_ALSO()\fP\&.
.RE
.PP
\fBBug\fP
.RS 4
The \fBCOUNTER\fP variable is used in most cases to guarantee a unique global identifier for options declared using the PARAM_*() macros\&. However, not all compilers have this support--most notably, gcc < 4\&.3\&. In that case, the \fBLINE\fP macro is used as an attempt to get a unique global identifier, but collisions are still possible, and they produce bizarre error messages\&. See https://github.com/mlpack/mlpack/issues/100 for more information\&. 
.RE
.PP

.PP
Definition at line 942 of file param\&.hpp\&.
.SS "#define PARAM_VECTOR_IN_REQ(T, ID, DESC, ALIAS)       \fBPARAM_IN\fP(std::vector<T>, ID, DESC, ALIAS, std::vector<T>(), true);"

.PP
Define a required vector parameter\&. The parameter must then be specified on the command line with --ID=value1,value2,value3\&.
.PP
\fBParameters\fP
.RS 4
\fIT\fP Type of the parameter\&. 
.br
\fIID\fP Name of the parameter\&. 
.br
\fIDESC\fP Quick description of the parameter (1-2 sentences)\&. Don't use printing macros like PRINT_PARAM_STRING() or PRINT_DATASET() or others here---it will cause problems\&. 
.br
\fIALIAS\fP An alias for the parameter (one letter)\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBmlpack::IO\fP, \fBBINDING_NAME()\fP, \fBBINDING_SHORT_DESC()\fP, \fBBINDING_LONG_DESC()\fP, \fBBINDING_EXAMPLE()\fP and \fBBINDING_SEE_ALSO()\fP\&.
.RE
.PP
\fBBug\fP
.RS 4
The \fBCOUNTER\fP variable is used in most cases to guarantee a unique global identifier for options declared using the PARAM_*() macros\&. However, not all compilers have this support--most notably, gcc < 4\&.3\&. In that case, the \fBLINE\fP macro is used as an attempt to get a unique global identifier, but collisions are still possible, and they produce bizarre error messages\&. See https://github.com/mlpack/mlpack/issues/100 for more information\&. 
.RE
.PP

.PP
Definition at line 1208 of file param\&.hpp\&.
.SS "#define PARAM_VECTOR_OUT(T, ID, DESC, ALIAS)       \fBPARAM_OUT\fP(std::vector<T>, ID, DESC, ALIAS, std::vector<T>(), false)"

.PP
Define a vector output parameter\&. This vector will be printed on stdout at the end of the program; for instance, if the parameter name is 'vector' and the vector holds the array { 1, 2, 3, 4 }, the output on stdout would be of the following form:
.PP
.PP
.nf
vector: 1, 2, 3, 4
.fi
.PP
.PP
If the parameter is not set by the end of the program, a fatal runtime error will be issued\&.
.PP
\fBParameters\fP
.RS 4
\fIT\fP Type of the parameter\&. 
.br
\fIID\fP Name of the parameter\&. 
.br
\fIDESC\fP Quick description of the parameter (1-2 sentences)\&. Don't use printing macros like PRINT_PARAM_STRING() or PRINT_DATASET() or others here---it will cause problems\&. 
.br
\fIALIAS\fP An alias for the parameter (one letter)\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBmlpack::IO\fP, \fBBINDING_NAME()\fP, \fBBINDING_SHORT_DESC()\fP, \fBBINDING_LONG_DESC()\fP, \fBBINDING_EXAMPLE()\fP and \fBBINDING_SEE_ALSO()\fP\&.
.RE
.PP
\fBBug\fP
.RS 4
The \fBCOUNTER\fP variable is used in most cases to guarantee a unique global identifier for options declared using the PARAM_*() macros\&. However, not all compilers have this support--most notably, gcc < 4\&.3\&. In that case, the \fBLINE\fP macro is used as an attempt to get a unique global identifier, but collisions are still possible, and they produce bizarre error messages\&. See https://github.com/mlpack/mlpack/issues/100 for more information\&. 
.RE
.PP

.PP
Definition at line 976 of file param\&.hpp\&.
.SS "#define TUPLE_TYPE   std::tuple<\fBmlpack::data::DatasetInfo\fP, arma::mat>"

.PP
Define an input DatasetInfo/matrix parameter\&. From the command line, the user can specify the file that holds the matrix, using the name of the matrix parameter with '_file' appended (and the same alias)\&. So for instance, if the name of the matrix parameter was 'matrix', the user could specify that the 'matrix' matrix was held in file\&.csv by giving the parameter
.PP
.PP
.nf
--matrix_file file\&.csv
.fi
.PP
.PP
Then the DatasetInfo and matrix type could be accessed with
.PP
.PP
.nf
DatasetInfo d = std::move(
    IO::GetParam<std::tuple<DatasetInfo, arma::mat>>("matrix")\&.get<0>());
arma::mat m = std::move(
    IO::GetParam<std::tuple<DatasetInfo, arma::mat>>("matrix")\&.get<1>());
.fi
.PP
.PP
\fBParameters\fP
.RS 4
\fIID\fP Name of the parameter\&. 
.br
\fIDESC\fP Quick description of the parameter (1-2 sentences)\&. Don't use printing macros like PRINT_PARAM_STRING() or PRINT_DATASET() or others here---it will cause problems\&. 
.br
\fIALIAS\fP One-character string representing the alias of the parameter\&.
.RE
.PP
\fBSee also\fP
.RS 4
\fBmlpack::IO\fP, \fBBINDING_NAME()\fP, \fBBINDING_SHORT_DESC()\fP, \fBBINDING_LONG_DESC()\fP, \fBBINDING_EXAMPLE()\fP and \fBBINDING_SEE_ALSO()\fP\&.
.RE
.PP
\fBBug\fP
.RS 4
The \fBCOUNTER\fP variable is used in most cases to guarantee a unique global identifier for options declared using the PARAM_*() macros\&. However, not all compilers have this support--most notably, gcc < 4\&.3\&. In that case, the \fBLINE\fP macro is used as an attempt to get a unique global identifier, but collisions are still possible, and they produce bizarre error messages\&. See https://github.com/mlpack/mlpack/issues/100 for more information\&. 
.RE
.PP

.PP
Definition at line 1016 of file param\&.hpp\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for mlpack from the source code\&.
