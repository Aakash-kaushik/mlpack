.TH "mlpack::bindings::go" 3 "Sun Jun 20 2021" "Version 3.4.2" "mlpack" \" -*- nroff -*-
.ad l
.nh
.SH NAME
mlpack::bindings::go
.SH SYNOPSIS
.br
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBGoOption\fP"
.br
.RI "The Go option class\&. "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "template<typename T > void \fBDefaultParam\fP (\fButil::ParamData\fP &data, const void *, void *output)"
.br
.RI "Return the default value of an option\&. "
.ti -1c
.RI "template<typename T > std::string \fBDefaultParamImpl\fP (\fButil::ParamData\fP &data, const typename boost::disable_if< arma::is_arma_type< T >>::type *=0, const typename boost::disable_if< \fButil::IsStdVector\fP< T >>::type *=0, const typename boost::disable_if< \fBdata::HasSerialize\fP< T >>::type *=0, const typename boost::disable_if< std::is_same< T, std::string >>::type *=0, const typename boost::disable_if< std::is_same< T, std::tuple< \fBmlpack::data::DatasetInfo\fP, arma::mat >>>::type *=0)"
.br
.RI "Return the default value of an option\&. "
.ti -1c
.RI "template<typename T > std::string \fBDefaultParamImpl\fP (\fButil::ParamData\fP &data, const typename boost::disable_if< arma::is_arma_type< T >>::type *=0, const typename boost::enable_if< \fBdata::HasSerialize\fP< T >>::type *=0)"
.br
.RI "Return the default value of a model option (this returns the default filename, or '' if the default is no file)\&. "
.ti -1c
.RI "template<typename T > std::string \fBDefaultParamImpl\fP (\fButil::ParamData\fP &data, const typename boost::enable_if< std::is_same< T, std::string >>::type *=0)"
.br
.RI "Return the default value of a string option\&. "
.ti -1c
.RI "template<typename T > std::string \fBDefaultParamImpl\fP (\fButil::ParamData\fP &data, const typename boost::enable_if< \fButil::IsStdVector\fP< T >>::type *=0)"
.br
.RI "Return the default value of a vector option\&. "
.ti -1c
.RI "template<typename T > std::string \fBDefaultParamImpl\fP (\fButil::ParamData\fP &data, const typename boost::enable_if_c< arma::is_arma_type< T >::value||std::is_same< T, std::tuple< \fBmlpack::data::DatasetInfo\fP, arma::mat >>::value >::type *=0)"
.br
.RI "Return the default value of a matrix option, a tuple option, a serializable option, or a string option (this returns the default filename, or '' if the default is no file)\&. "
.ti -1c
.RI "std::string \fBGetBindingName\fP (const std::string &bindingName)"
.br
.RI "Given the name of a binding, print its Go name\&. "
.ti -1c
.RI "template<typename T > std::string \fBGetGoType\fP (\fButil::ParamData\fP &, const typename boost::disable_if< std::is_same< T, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type *=0, const typename boost::enable_if< arma::is_arma_type< T >>::type *=0)"
.br
.ti -1c
.RI "template<typename T > std::string \fBGetGoType\fP (\fButil::ParamData\fP &, const typename boost::disable_if< \fButil::IsStdVector\fP< T >>::type *=0, const typename boost::disable_if< \fBdata::HasSerialize\fP< T >>::type *=0, const typename boost::disable_if< arma::is_arma_type< T >>::type *=0, const typename boost::disable_if< std::is_same< T, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type *=0)"
.br
.ti -1c
.RI "template<typename T > std::string \fBGetGoType\fP (\fButil::ParamData\fP &, const typename boost::enable_if< std::is_same< T, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type *=0)"
.br
.ti -1c
.RI "template<typename T > std::string \fBGetGoType\fP (\fButil::ParamData\fP &d, const typename boost::disable_if< arma::is_arma_type< T >>::type *=0, const typename boost::enable_if< \fBdata::HasSerialize\fP< T >>::type *=0)"
.br
.ti -1c
.RI "template<typename T > std::string \fBGetGoType\fP (\fButil::ParamData\fP &d, const typename boost::enable_if< \fButil::IsStdVector\fP< T >>::type *=0)"
.br
.ti -1c
.RI "template<> std::string \fBGetGoType< bool >\fP (\fButil::ParamData\fP &, const typename boost::disable_if< \fButil::IsStdVector\fP< bool >>::type *, const typename boost::disable_if< \fBdata::HasSerialize\fP< bool >>::type *, const typename boost::disable_if< arma::is_arma_type< bool >>::type *, const typename boost::disable_if< std::is_same< bool, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type *)"
.br
.ti -1c
.RI "template<> std::string \fBGetGoType< double >\fP (\fButil::ParamData\fP &, const typename boost::disable_if< \fButil::IsStdVector\fP< double >>::type *, const typename boost::disable_if< \fBdata::HasSerialize\fP< double >>::type *, const typename boost::disable_if< arma::is_arma_type< double >>::type *, const typename boost::disable_if< std::is_same< double, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type *)"
.br
.ti -1c
.RI "template<> std::string \fBGetGoType< float >\fP (\fButil::ParamData\fP &, const typename boost::disable_if< \fButil::IsStdVector\fP< float >>::type *, const typename boost::disable_if< \fBdata::HasSerialize\fP< float >>::type *, const typename boost::disable_if< arma::is_arma_type< float >>::type *, const typename boost::disable_if< std::is_same< float, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type *)"
.br
.ti -1c
.RI "template<> std::string \fBGetGoType< int >\fP (\fButil::ParamData\fP &, const typename boost::disable_if< \fButil::IsStdVector\fP< int >>::type *, const typename boost::disable_if< \fBdata::HasSerialize\fP< int >>::type *, const typename boost::disable_if< arma::is_arma_type< int >>::type *, const typename boost::disable_if< std::is_same< int, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type *)"
.br
.ti -1c
.RI "template<> std::string \fBGetGoType< std::string >\fP (\fButil::ParamData\fP &, const typename boost::disable_if< \fButil::IsStdVector\fP< std::string >>::type *, const typename boost::disable_if< \fBdata::HasSerialize\fP< std::string >>::type *, const typename boost::disable_if< arma::is_arma_type< std::string >>::type *, const typename boost::disable_if< std::is_same< std::string, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type *)"
.br
.ti -1c
.RI "void \fBGetOptions\fP (std::vector< std::tuple< std::string, std::string >> &)"
.br
.ti -1c
.RI "template<typename T , typename\&.\&.\&. Args> void \fBGetOptions\fP (std::vector< std::tuple< std::string, std::string >> &results, const std::string &paramName, const T &value, Args\&.\&.\&. args)"
.br
.RI "Assemble a vector of string tuples indicating parameter names and what should be printed for them\&. "
.ti -1c
.RI "template<typename T > void \fBGetParam\fP (\fButil::ParamData\fP &d, const void *, void *output)"
.br
.RI "All Go binding types are exactly what is held in the ParamData, so no special handling is necessary\&. "
.ti -1c
.RI "template<typename T > std::string \fBGetPrintableParam\fP (\fButil::ParamData\fP &data, const typename boost::disable_if< arma::is_arma_type< T >>::type *=0, const typename boost::disable_if< \fButil::IsStdVector\fP< T >>::type *=0, const typename boost::disable_if< \fBdata::HasSerialize\fP< T >>::type *=0, const typename boost::disable_if< std::is_same< T, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type *=0)"
.br
.RI "Print an option of a simple type\&. "
.ti -1c
.RI "template<typename T > std::string \fBGetPrintableParam\fP (\fButil::ParamData\fP &data, const typename boost::disable_if< arma::is_arma_type< T >>::type *=0, const typename boost::enable_if< \fBdata::HasSerialize\fP< T >>::type *=0)"
.br
.RI "Print a serializable class option (this prints the class name)\&. "
.ti -1c
.RI "template<typename T > std::string \fBGetPrintableParam\fP (\fButil::ParamData\fP &data, const typename boost::enable_if< arma::is_arma_type< T >>::type *=0)"
.br
.RI "Print a matrix option (this prints its size)\&. "
.ti -1c
.RI "template<typename T > std::string \fBGetPrintableParam\fP (\fButil::ParamData\fP &data, const typename boost::enable_if< std::is_same< T, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type *=0)"
.br
.RI "Print a combination DatasetInfo/matrix parameter\&. "
.ti -1c
.RI "template<typename T > std::string \fBGetPrintableParam\fP (\fButil::ParamData\fP &data, const typename boost::enable_if< \fButil::IsStdVector\fP< T >>::type *=0)"
.br
.RI "Print a vector option, with spaces between it\&. "
.ti -1c
.RI "template<typename T > void \fBGetPrintableParam\fP (\fButil::ParamData\fP &data, const void *, void *output)"
.br
.RI "Print an option into a std::string\&. "
.ti -1c
.RI "template<typename T > std::string \fBGetPrintableType\fP (\fButil::ParamData\fP &, const typename boost::disable_if< \fButil::IsStdVector\fP< T >>::type *=0, const typename boost::disable_if< \fBdata::HasSerialize\fP< T >>::type *=0, const typename boost::disable_if< arma::is_arma_type< T >>::type *=0, const typename boost::disable_if< std::is_same< T, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type *=0)"
.br
.ti -1c
.RI "template<typename T > std::string \fBGetPrintableType\fP (\fButil::ParamData\fP &, const typename boost::enable_if< arma::is_arma_type< T >>::type *=0, const typename boost::disable_if< std::is_same< T, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type *=0)"
.br
.ti -1c
.RI "template<typename T > std::string \fBGetPrintableType\fP (\fButil::ParamData\fP &, const typename boost::enable_if< std::is_same< T, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type *=0)"
.br
.ti -1c
.RI "template<typename T > std::string \fBGetPrintableType\fP (\fButil::ParamData\fP &d, const typename boost::disable_if< arma::is_arma_type< T >>::type *=0, const typename boost::enable_if< \fBdata::HasSerialize\fP< T >>::type *=0, const typename boost::disable_if< std::is_same< T, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type *=0)"
.br
.ti -1c
.RI "template<typename T > std::string \fBGetPrintableType\fP (\fButil::ParamData\fP &d, const typename boost::enable_if< \fButil::IsStdVector\fP< T >>::type *=0, const typename boost::disable_if< std::is_same< T, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type *=0)"
.br
.ti -1c
.RI "template<typename T > void \fBGetPrintableType\fP (\fButil::ParamData\fP &d, const void *, void *output)"
.br
.ti -1c
.RI "template<> std::string \fBGetPrintableType< bool >\fP (\fButil::ParamData\fP &, const typename boost::disable_if< \fButil::IsStdVector\fP< bool >>::type *, const typename boost::disable_if< \fBdata::HasSerialize\fP< bool >>::type *, const typename boost::disable_if< arma::is_arma_type< bool >>::type *, const typename boost::disable_if< std::is_same< bool, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type *)"
.br
.ti -1c
.RI "template<> std::string \fBGetPrintableType< double >\fP (\fButil::ParamData\fP &, const typename boost::disable_if< \fButil::IsStdVector\fP< double >>::type *, const typename boost::disable_if< \fBdata::HasSerialize\fP< double >>::type *, const typename boost::disable_if< arma::is_arma_type< double >>::type *, const typename boost::disable_if< std::is_same< double, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type *)"
.br
.ti -1c
.RI "template<> std::string \fBGetPrintableType< int >\fP (\fButil::ParamData\fP &, const typename boost::disable_if< \fButil::IsStdVector\fP< int >>::type *, const typename boost::disable_if< \fBdata::HasSerialize\fP< int >>::type *, const typename boost::disable_if< arma::is_arma_type< int >>::type *, const typename boost::disable_if< std::is_same< int, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type *)"
.br
.ti -1c
.RI "template<> std::string \fBGetPrintableType< std::string >\fP (\fButil::ParamData\fP &, const typename boost::disable_if< \fButil::IsStdVector\fP< std::string >>::type *, const typename boost::disable_if< \fBdata::HasSerialize\fP< std::string >>::type *, const typename boost::disable_if< arma::is_arma_type< std::string >>::type *, const typename boost::disable_if< std::is_same< std::string, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type *)"
.br
.ti -1c
.RI "template<typename T > std::string \fBGetType\fP (\fButil::ParamData\fP &, const typename boost::disable_if< \fButil::IsStdVector\fP< T >>::type *=0, const typename boost::disable_if< \fBdata::HasSerialize\fP< T >>::type *=0, const typename boost::disable_if< arma::is_arma_type< T >>::type *=0)"
.br
.ti -1c
.RI "template<typename T > std::string \fBGetType\fP (\fButil::ParamData\fP &, const typename boost::enable_if< arma::is_arma_type< T >>::type *=0)"
.br
.ti -1c
.RI "template<typename T > std::string \fBGetType\fP (\fButil::ParamData\fP &d, const typename boost::disable_if< arma::is_arma_type< T >>::type *=0, const typename boost::enable_if< \fBdata::HasSerialize\fP< T >>::type *=0)"
.br
.ti -1c
.RI "template<typename T > std::string \fBGetType\fP (\fButil::ParamData\fP &d, const typename boost::enable_if< \fButil::IsStdVector\fP< T >>::type *=0)"
.br
.ti -1c
.RI "template<typename T > void \fBGetType\fP (\fButil::ParamData\fP &d, const void *, void *output)"
.br
.RI "Function is used to generate the type names that are used in calls to functions like gonumToArma<type>() or setParam<type>(), and therefore what's returned isn't exactly the Go native type used for that parameter type\&. "
.ti -1c
.RI "template<> std::string \fBGetType< bool >\fP (\fButil::ParamData\fP &, const typename boost::disable_if< \fButil::IsStdVector\fP< bool >>::type *, const typename boost::disable_if< \fBdata::HasSerialize\fP< bool >>::type *, const typename boost::disable_if< arma::is_arma_type< bool >>::type *)"
.br
.ti -1c
.RI "template<> std::string \fBGetType< double >\fP (\fButil::ParamData\fP &, const typename boost::disable_if< \fButil::IsStdVector\fP< double >>::type *, const typename boost::disable_if< \fBdata::HasSerialize\fP< double >>::type *, const typename boost::disable_if< arma::is_arma_type< double >>::type *)"
.br
.ti -1c
.RI "template<> std::string \fBGetType< float >\fP (\fButil::ParamData\fP &, const typename boost::disable_if< \fButil::IsStdVector\fP< float >>::type *, const typename boost::disable_if< \fBdata::HasSerialize\fP< float >>::type *, const typename boost::disable_if< arma::is_arma_type< float >>::type *)"
.br
.ti -1c
.RI "template<> std::string \fBGetType< int >\fP (\fButil::ParamData\fP &, const typename boost::disable_if< \fButil::IsStdVector\fP< int >>::type *, const typename boost::disable_if< \fBdata::HasSerialize\fP< int >>::type *, const typename boost::disable_if< arma::is_arma_type< int >>::type *)"
.br
.ti -1c
.RI "template<> std::string \fBGetType< std::string >\fP (\fButil::ParamData\fP &, const typename boost::disable_if< \fButil::IsStdVector\fP< std::string >>::type *, const typename boost::disable_if< \fBdata::HasSerialize\fP< std::string >>::type *, const typename boost::disable_if< arma::is_arma_type< std::string >>::type *)"
.br
.ti -1c
.RI "bool \fBIgnoreCheck\fP (const std::string &paramName)"
.br
.RI "Print whether or not we should ignore a check on the given parameter\&. "
.ti -1c
.RI "bool \fBIgnoreCheck\fP (const std::vector< std::pair< std::string, bool >> &constraints, const std::string &paramName)"
.br
.RI "Print whether or not we should ignore a check on the given set of constraints\&. "
.ti -1c
.RI "bool \fBIgnoreCheck\fP (const std::vector< std::string > &constraints)"
.br
.RI "Print whether or not we should ignore a check on the given set of constraints\&. "
.ti -1c
.RI "std::string \fBParamString\fP (const std::string &paramName)"
.br
.RI "Given the parameter name, determine what it would actually be when passed to the command line\&. "
.ti -1c
.RI "std::string \fBPrintDataset\fP (const std::string &datasetName)"
.br
.RI "Given the name of a matrix, print it\&. "
.ti -1c
.RI "std::string \fBPrintDefault\fP (const std::string &paramName)"
.br
.RI "Given a parameter name, print its corresponding default value\&. "
.ti -1c
.RI "template<typename T > void \fBPrintDefnInput\fP (\fButil::ParamData\fP &d, const typename boost::disable_if< arma::is_arma_type< T >>::type *=0, const typename boost::disable_if< \fBdata::HasSerialize\fP< T >>::type *=0, const typename boost::disable_if< std::is_same< T, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type *=0)"
.br
.RI "Print input in method definition for a regular parameter type\&. "
.ti -1c
.RI "template<typename T > void \fBPrintDefnInput\fP (\fButil::ParamData\fP &d, const typename boost::disable_if< arma::is_arma_type< T >>::type *=0, const typename boost::enable_if< \fBdata::HasSerialize\fP< T >>::type *=0)"
.br
.RI "Print input in method definition for a serializable model\&. "
.ti -1c
.RI "template<typename T > void \fBPrintDefnInput\fP (\fButil::ParamData\fP &d, const typename boost::enable_if< arma::is_arma_type< T >>::type *=0)"
.br
.RI "Print input in method definition for a matrix type\&. "
.ti -1c
.RI "template<typename T > void \fBPrintDefnInput\fP (\fButil::ParamData\fP &d, const typename boost::enable_if< std::is_same< T, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type *=0)"
.br
.RI "Print input in method definition for a matrix with info type\&. "
.ti -1c
.RI "template<typename T > void \fBPrintDefnInput\fP (\fButil::ParamData\fP &d, const void *, void *)"
.br
.RI "Given parameter information and the current number of spaces for indentation, print the code to process the output to cout\&. "
.ti -1c
.RI "template<typename T > void \fBPrintDefnOutput\fP (\fButil::ParamData\fP &d, const typename boost::disable_if< arma::is_arma_type< T >>::type *=0, const typename boost::disable_if< \fBdata::HasSerialize\fP< T >>::type *=0, const typename boost::disable_if< std::is_same< T, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type *=0)"
.br
.RI "Print output for a regular parameter type\&. "
.ti -1c
.RI "template<typename T > void \fBPrintDefnOutput\fP (\fButil::ParamData\fP &d, const typename boost::disable_if< arma::is_arma_type< T >>::type *=0, const typename boost::enable_if< \fBdata::HasSerialize\fP< T >>::type *=0)"
.br
.RI "Print output for a serializable model\&. "
.ti -1c
.RI "template<typename T > void \fBPrintDefnOutput\fP (\fButil::ParamData\fP &d, const typename boost::enable_if< arma::is_arma_type< T >>::type *=0)"
.br
.RI "Print output for a matrix type\&. "
.ti -1c
.RI "template<typename T > void \fBPrintDefnOutput\fP (\fButil::ParamData\fP &d, const typename boost::enable_if< std::is_same< T, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type *=0)"
.br
.RI "Print output for a matrix with info type\&. "
.ti -1c
.RI "template<typename T > void \fBPrintDefnOutput\fP (\fButil::ParamData\fP &d, const void *, void *)"
.br
.RI "Given parameter information and the current number of spaces for indentation, print the code to process the output to cout\&. "
.ti -1c
.RI "template<typename T > void \fBPrintDoc\fP (\fButil::ParamData\fP &d, const void *input, void *isLower)"
.br
.RI "Print the docstring documentation for a given parameter\&. "
.ti -1c
.RI "void \fBPrintGo\fP (const \fButil::BindingDetails\fP &doc, const std::string &functionName)"
.br
.RI "Given a list of parameter definition and program documentation, print a generated \&.go file to stdout\&. "
.ti -1c
.RI "std::string \fBPrintImport\fP ()"
.br
.RI "Print any import information for the Go binding\&. "
.ti -1c
.RI "std::string \fBPrintInputOptionInfo\fP ()"
.br
.RI "Print any special information about input options\&. "
.ti -1c
.RI "std::string \fBPrintInputOptions\fP ()"
.br
.ti -1c
.RI "template<typename T , typename\&.\&.\&. Args> std::string \fBPrintInputOptions\fP (const std::string &paramName, const T &value, Args\&.\&.\&. args)"
.br
.RI "Print an input option\&. "
.ti -1c
.RI "template<typename T > void \fBPrintInputProcessing\fP (\fButil::ParamData\fP &d, const size_t indent, const typename boost::disable_if< arma::is_arma_type< T >>::type *=0, const typename boost::disable_if< \fBdata::HasSerialize\fP< T >>::type *=0, const typename boost::disable_if< std::is_same< T, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type *=0)"
.br
.RI "Print input processing for a standard option type\&. "
.ti -1c
.RI "template<typename T > void \fBPrintInputProcessing\fP (\fButil::ParamData\fP &d, const size_t indent, const typename boost::disable_if< arma::is_arma_type< T >>::type *=0, const typename boost::enable_if< \fBdata::HasSerialize\fP< T >>::type *=0)"
.br
.RI "Print input processing for a serializable type\&. "
.ti -1c
.RI "template<typename T > void \fBPrintInputProcessing\fP (\fButil::ParamData\fP &d, const size_t indent, const typename boost::enable_if< arma::is_arma_type< T >>::type *=0)"
.br
.RI "Print input processing for a matrix type\&. "
.ti -1c
.RI "template<typename T > void \fBPrintInputProcessing\fP (\fButil::ParamData\fP &d, const size_t indent, const typename boost::enable_if< std::is_same< T, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type *=0)"
.br
.RI "Print input processing for a matrix with info type\&. "
.ti -1c
.RI "template<typename T > void \fBPrintInputProcessing\fP (\fButil::ParamData\fP &d, const void *input, void *)"
.br
.RI "Given parameter information and the current number of spaces for indentation, print the code to process the input to cout\&. "
.ti -1c
.RI "template<typename T > void \fBPrintMethodConfig\fP (\fButil::ParamData\fP &d, const size_t indent, const typename boost::disable_if< arma::is_arma_type< T >>::type *=0, const typename boost::disable_if< \fBdata::HasSerialize\fP< T >>::type *=0, const typename boost::disable_if< std::is_same< T, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type *=0)"
.br
.RI "Print param in configuration struct for a standard option type\&. "
.ti -1c
.RI "template<typename T > void \fBPrintMethodConfig\fP (\fButil::ParamData\fP &d, const size_t indent, const typename boost::disable_if< arma::is_arma_type< T >>::type *=0, const typename boost::enable_if< \fBdata::HasSerialize\fP< T >>::type *=0)"
.br
.RI "Print param in method configuration struct for a serializable type\&. "
.ti -1c
.RI "template<typename T > void \fBPrintMethodConfig\fP (\fButil::ParamData\fP &d, const size_t indent, const typename boost::enable_if< arma::is_arma_type< T >>::type *=0)"
.br
.RI "Print param in configuration struct for a matrix type\&. "
.ti -1c
.RI "template<typename T > void \fBPrintMethodConfig\fP (\fButil::ParamData\fP &d, const size_t indent, const typename boost::enable_if< std::is_same< T, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type *=0)"
.br
.RI "Print param in configuration struct for a matrix with info type\&. "
.ti -1c
.RI "template<typename T > void \fBPrintMethodConfig\fP (\fButil::ParamData\fP &d, const void *input, void *)"
.br
.RI "Given parameter information and the current number of spaces for indentation, print the code to process the input to cout\&. "
.ti -1c
.RI "template<typename T > void \fBPrintMethodInit\fP (\fButil::ParamData\fP &d, const size_t indent, const typename boost::disable_if< arma::is_arma_type< T >>::type *=0, const typename boost::disable_if< \fBdata::HasSerialize\fP< T >>::type *=0, const typename boost::disable_if< std::is_same< T, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type *=0)"
.br
.RI "Print parameter with it's default value for a standard option type\&. "
.ti -1c
.RI "template<typename T > void \fBPrintMethodInit\fP (\fButil::ParamData\fP &d, const size_t indent, const typename boost::disable_if< arma::is_arma_type< T >>::type *=0, const typename boost::enable_if< \fBdata::HasSerialize\fP< T >>::type *=0)"
.br
.RI "Print parameter with its default value for a serializable type\&. "
.ti -1c
.RI "template<typename T > void \fBPrintMethodInit\fP (\fButil::ParamData\fP &d, const size_t indent, const typename boost::enable_if< arma::is_arma_type< T >>::type *=0)"
.br
.RI "Print parameter with its default value for a matrix type\&. "
.ti -1c
.RI "template<typename T > void \fBPrintMethodInit\fP (\fButil::ParamData\fP &d, const size_t indent, const typename boost::enable_if< std::is_same< T, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type *=0)"
.br
.RI "Print parameter with its default value for a matrix with info type\&. "
.ti -1c
.RI "template<typename T > void \fBPrintMethodInit\fP (\fButil::ParamData\fP &d, const void *input, void *)"
.br
.RI "Given parameter information and the current number of spaces for indentation, print the code to process the input to cout\&. "
.ti -1c
.RI "std::string \fBPrintModel\fP (const std::string &modelName)"
.br
.RI "Given the name of a model, print it\&. "
.ti -1c
.RI "std::string \fBPrintOptionalInputs\fP ()"
.br
.ti -1c
.RI "template<typename T , typename\&.\&.\&. Args> std::string \fBPrintOptionalInputs\fP (const std::string &paramName, const T &value, Args\&.\&.\&. args)"
.br
.RI "Print an input option\&. "
.ti -1c
.RI "std::string \fBPrintOutputOptionInfo\fP ()"
.br
.RI "Print any special information about output options\&. "
.ti -1c
.RI "std::string \fBPrintOutputOptions\fP ()"
.br
.ti -1c
.RI "template<typename\&.\&.\&. Args> std::string \fBPrintOutputOptions\fP (Args\&.\&.\&. args)"
.br
.ti -1c
.RI "template<typename T > void \fBPrintOutputProcessing\fP (\fButil::ParamData\fP &d, const size_t indent, const typename boost::disable_if< arma::is_arma_type< T >>::type *=0, const typename boost::disable_if< \fBdata::HasSerialize\fP< T >>::type *=0, const typename boost::disable_if< std::is_same< T, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type *=0)"
.br
.RI "Print output processing for a regular parameter type\&. "
.ti -1c
.RI "template<typename T > void \fBPrintOutputProcessing\fP (\fButil::ParamData\fP &d, const size_t indent, const typename boost::disable_if< arma::is_arma_type< T >>::type *=0, const typename boost::enable_if< \fBdata::HasSerialize\fP< T >>::type *=0)"
.br
.RI "Print output processing for a serializable model\&. "
.ti -1c
.RI "template<typename T > void \fBPrintOutputProcessing\fP (\fButil::ParamData\fP &d, const size_t indent, const typename boost::enable_if< arma::is_arma_type< T >>::type *=0, const typename std::enable_if<!std::is_same< T, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>::value >::type *=0)"
.br
.RI "Print output processing for a matrix type\&. "
.ti -1c
.RI "template<typename T > void \fBPrintOutputProcessing\fP (\fButil::ParamData\fP &d, const size_t indent, const typename boost::enable_if< std::is_same< T, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type *=0)"
.br
.RI "Print output processing for a matrix with info type\&. "
.ti -1c
.RI "template<typename T > void \fBPrintOutputProcessing\fP (\fButil::ParamData\fP &d, const void *, void *)"
.br
.ti -1c
.RI "template<typename T > std::string \fBPrintTypeDoc\fP (\fButil::ParamData\fP &data, const typename boost::disable_if< arma::is_arma_type< T >>::type *=0, const typename boost::disable_if< \fButil::IsStdVector\fP< T >>::type *=0, const typename boost::disable_if< \fBdata::HasSerialize\fP< T >>::type *=0, const typename boost::disable_if< std::is_same< T, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type *=0)"
.br
.RI "Return a string representing the command-line type of an option\&. "
.ti -1c
.RI "template<typename T > std::string \fBPrintTypeDoc\fP (\fButil::ParamData\fP &data, const typename boost::disable_if< arma::is_arma_type< T >>::type *=0, const typename boost::enable_if< \fBdata::HasSerialize\fP< T >>::type *=0)"
.br
.RI "Return a string representing the command-line type of a model\&. "
.ti -1c
.RI "template<typename T > std::string \fBPrintTypeDoc\fP (\fButil::ParamData\fP &data, const typename std::enable_if< arma::is_arma_type< T >::value >::type *=0)"
.br
.RI "Return a string representing the command-line type of a matrix option\&. "
.ti -1c
.RI "template<typename T > std::string \fBPrintTypeDoc\fP (\fButil::ParamData\fP &data, const typename std::enable_if< std::is_same< T, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>::value >::type *=0)"
.br
.RI "Return a string representing the command-line type of a matrix tuple option\&. "
.ti -1c
.RI "template<typename T > std::string \fBPrintTypeDoc\fP (\fButil::ParamData\fP &data, const typename std::enable_if< \fButil::IsStdVector\fP< T >::value >::type *=0)"
.br
.RI "Return a string representing the command-line type of a vector\&. "
.ti -1c
.RI "template<typename T > void \fBPrintTypeDoc\fP (\fButil::ParamData\fP &data, const void *, void *output)"
.br
.RI "Print the command-line type of an option into a string\&. "
.ti -1c
.RI "template<> std::string \fBPrintValue\fP (const bool &value, bool quotes)"
.br
.ti -1c
.RI "template<typename T > std::string \fBPrintValue\fP (const T &value, bool quotes)"
.br
.RI "Given a parameter type, print the corresponding value\&. "
.ti -1c
.RI "template<typename\&.\&.\&. Args> std::string \fBProgramCall\fP (const std::string &\fBprogramName\fP, Args\&.\&.\&. args)"
.br
.RI "Given a name of a binding and a variable number of arguments (and their contents), print the corresponding function call\&. "
.ti -1c
.RI "void \fBStripType\fP (const std::string &inputType, std::string &goStrippedType, std::string &strippedType, std::string &printedType, std::string &defaultsType)"
.br
.RI "Given an input type like, e\&.g\&., 'LogisticRegression<>', return four types that can be used in Go code\&. "
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "std::string \fBprogramName\fP"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "void mlpack::bindings::go::DefaultParam (\fButil::ParamData\fP & data, const void *, void * output)"

.PP
Return the default value of an option\&. This is the function that will be placed into the \fBIO\fP functionMap\&. 
.PP
Definition at line 80 of file default_param\&.hpp\&.
.SS "std::string mlpack::bindings::go::DefaultParamImpl (\fButil::ParamData\fP & data, const typename boost::disable_if< arma::is_arma_type< T >>::type * = \fC0\fP, const typename boost::disable_if< \fButil::IsStdVector\fP< T >>::type * = \fC0\fP, const typename boost::disable_if< \fBdata::HasSerialize\fP< T >>::type * = \fC0\fP, const typename boost::disable_if< std::is_same< T, std::string >>::type * = \fC0\fP, const typename boost::disable_if< std::is_same< T, std::tuple< \fBmlpack::data::DatasetInfo\fP, arma::mat >>>::type * = \fC0\fP)"

.PP
Return the default value of an option\&. This is for regular types\&. 
.SS "std::string mlpack::bindings::go::DefaultParamImpl (\fButil::ParamData\fP & data, const typename boost::disable_if< arma::is_arma_type< T >>::type * = \fC0\fP, const typename boost::enable_if< \fBdata::HasSerialize\fP< T >>::type * = \fC0\fP)"

.PP
Return the default value of a model option (this returns the default filename, or '' if the default is no file)\&. 
.SS "std::string mlpack::bindings::go::DefaultParamImpl (\fButil::ParamData\fP & data, const typename boost::enable_if< std::is_same< T, std::string >>::type * = \fC0\fP)"

.PP
Return the default value of a string option\&. 
.SS "std::string mlpack::bindings::go::DefaultParamImpl (\fButil::ParamData\fP & data, const typename boost::enable_if< \fButil::IsStdVector\fP< T >>::type * = \fC0\fP)"

.PP
Return the default value of a vector option\&. 
.SS "std::string mlpack::bindings::go::DefaultParamImpl (\fButil::ParamData\fP & data, const typename boost::enable_if_c< arma::is_arma_type< T >::value||std::is_same< T, std::tuple< \fBmlpack::data::DatasetInfo\fP, arma::mat >>::value >::type * = \fC0\fP)"

.PP
Return the default value of a matrix option, a tuple option, a serializable option, or a string option (this returns the default filename, or '' if the default is no file)\&. 
.SS "std::string mlpack::bindings::go::GetBindingName (const std::string & bindingName)\fC [inline]\fP"

.PP
Given the name of a binding, print its Go name\&. 
.SS "std::string mlpack::bindings::go::GetGoType (\fButil::ParamData\fP &, const typename boost::disable_if< std::is_same< T, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type * = \fC0\fP, const typename boost::enable_if< arma::is_arma_type< T >>::type * = \fC0\fP)\fC [inline]\fP"

.PP
Definition at line 106 of file get_go_type\&.hpp\&.
.SS "std::string mlpack::bindings::go::GetGoType (\fButil::ParamData\fP &, const typename boost::disable_if< \fButil::IsStdVector\fP< T >>::type * = \fC0\fP, const typename boost::disable_if< \fBdata::HasSerialize\fP< T >>::type * = \fC0\fP, const typename boost::disable_if< arma::is_arma_type< T >>::type * = \fC0\fP, const typename boost::disable_if< std::is_same< T, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type * = \fC0\fP)\fC [inline]\fP"

.PP
Definition at line 26 of file get_go_type\&.hpp\&.
.SS "std::string mlpack::bindings::go::GetGoType (\fButil::ParamData\fP &, const typename boost::enable_if< std::is_same< T, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type * = \fC0\fP)\fC [inline]\fP"

.PP
Definition at line 116 of file get_go_type\&.hpp\&.
.SS "std::string mlpack::bindings::go::GetGoType (\fButil::ParamData\fP & d, const typename boost::disable_if< arma::is_arma_type< T >>::type * = \fC0\fP, const typename boost::enable_if< \fBdata::HasSerialize\fP< T >>::type * = \fC0\fP)\fC [inline]\fP"

.PP
Definition at line 125 of file get_go_type\&.hpp\&.
.PP
References ParamData::cppType, and StripType()\&.
.SS "std::string mlpack::bindings::go::GetGoType (\fButil::ParamData\fP & d, const typename boost::enable_if< \fButil::IsStdVector\fP< T >>::type * = \fC0\fP)\fC [inline]\fP"

.PP
Definition at line 98 of file get_go_type\&.hpp\&.
.SS "std::string \fBmlpack::bindings::go::GetGoType\fP< bool > (\fButil::ParamData\fP &, const typename boost::disable_if< \fButil::IsStdVector\fP< bool >>::type *, const typename boost::disable_if< \fBdata::HasSerialize\fP< bool >>::type *, const typename boost::disable_if< arma::is_arma_type< bool >>::type *, const typename boost::disable_if< std::is_same< bool, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type *)\fC [inline]\fP"

.PP
Definition at line 86 of file get_go_type\&.hpp\&.
.SS "std::string \fBmlpack::bindings::go::GetGoType\fP< double > (\fButil::ParamData\fP &, const typename boost::disable_if< \fButil::IsStdVector\fP< double >>::type *, const typename boost::disable_if< \fBdata::HasSerialize\fP< double >>::type *, const typename boost::disable_if< arma::is_arma_type< double >>::type *, const typename boost::disable_if< std::is_same< double, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type *)\fC [inline]\fP"

.PP
Definition at line 62 of file get_go_type\&.hpp\&.
.SS "std::string \fBmlpack::bindings::go::GetGoType\fP< float > (\fButil::ParamData\fP &, const typename boost::disable_if< \fButil::IsStdVector\fP< float >>::type *, const typename boost::disable_if< \fBdata::HasSerialize\fP< float >>::type *, const typename boost::disable_if< arma::is_arma_type< float >>::type *, const typename boost::disable_if< std::is_same< float, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type *)\fC [inline]\fP"

.PP
Definition at line 50 of file get_go_type\&.hpp\&.
.SS "std::string \fBmlpack::bindings::go::GetGoType\fP< int > (\fButil::ParamData\fP &, const typename boost::disable_if< \fButil::IsStdVector\fP< int >>::type *, const typename boost::disable_if< \fBdata::HasSerialize\fP< int >>::type *, const typename boost::disable_if< arma::is_arma_type< int >>::type *, const typename boost::disable_if< std::is_same< int, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type *)\fC [inline]\fP"

.PP
Definition at line 38 of file get_go_type\&.hpp\&.
.SS "std::string \fBmlpack::bindings::go::GetGoType\fP< std::string > (\fButil::ParamData\fP &, const typename boost::disable_if< \fButil::IsStdVector\fP< std::string >>::type *, const typename boost::disable_if< \fBdata::HasSerialize\fP< std::string >>::type *, const typename boost::disable_if< arma::is_arma_type< std::string >>::type *, const typename boost::disable_if< std::is_same< std::string, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type *)\fC [inline]\fP"

.PP
Definition at line 74 of file get_go_type\&.hpp\&.
.SS "void mlpack::bindings::go::GetOptions (std::vector< std::tuple< std::string, std::string >> &)\fC [inline]\fP"

.SS "void mlpack::bindings::go::GetOptions (std::vector< std::tuple< std::string, std::string >> & results, const std::string & paramName, const T & value, Args\&.\&.\&. args)"

.PP
Assemble a vector of string tuples indicating parameter names and what should be printed for them\&. (For output parameters, we just need to print the value\&.) 
.SS "void mlpack::bindings::go::GetParam (\fButil::ParamData\fP & d, const void *, void * output)"

.PP
All Go binding types are exactly what is held in the ParamData, so no special handling is necessary\&. 
.PP
Definition at line 26 of file get_param\&.hpp\&.
.PP
References ParamData::value\&.
.SS "std::string mlpack::bindings::go::GetPrintableParam (\fButil::ParamData\fP & data, const typename boost::disable_if< arma::is_arma_type< T >>::type * = \fC0\fP, const typename boost::disable_if< \fButil::IsStdVector\fP< T >>::type * = \fC0\fP, const typename boost::disable_if< \fBdata::HasSerialize\fP< T >>::type * = \fC0\fP, const typename boost::disable_if< std::is_same< T, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type * = \fC0\fP)"

.PP
Print an option of a simple type\&. 
.PP
Definition at line 26 of file get_printable_param\&.hpp\&.
.PP
References ParamData::value\&.
.SS "std::string mlpack::bindings::go::GetPrintableParam (\fButil::ParamData\fP & data, const typename boost::disable_if< arma::is_arma_type< T >>::type * = \fC0\fP, const typename boost::enable_if< \fBdata::HasSerialize\fP< T >>::type * = \fC0\fP)"

.PP
Print a serializable class option (this prints the class name)\&. 
.PP
Definition at line 75 of file get_printable_param\&.hpp\&.
.PP
References ParamData::cppType, and ParamData::value\&.
.SS "std::string mlpack::bindings::go::GetPrintableParam (\fButil::ParamData\fP & data, const typename boost::enable_if< arma::is_arma_type< T >>::type * = \fC0\fP)"

.PP
Print a matrix option (this prints its size)\&. 
.PP
Definition at line 59 of file get_printable_param\&.hpp\&.
.PP
References ParamData::value\&.
.SS "std::string mlpack::bindings::go::GetPrintableParam (\fButil::ParamData\fP & data, const typename boost::enable_if< std::is_same< T, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type * = \fC0\fP)"

.PP
Print a combination DatasetInfo/matrix parameter\&. 
.PP
Definition at line 89 of file get_printable_param\&.hpp\&.
.PP
References ParamData::value\&.
.SS "std::string mlpack::bindings::go::GetPrintableParam (\fButil::ParamData\fP & data, const typename boost::enable_if< \fButil::IsStdVector\fP< T >>::type * = \fC0\fP)"

.PP
Print a vector option, with spaces between it\&. 
.PP
Definition at line 43 of file get_printable_param\&.hpp\&.
.PP
References ParamData::value\&.
.SS "void mlpack::bindings::go::GetPrintableParam (\fButil::ParamData\fP & data, const void *, void * output)"

.PP
Print an option into a std::string\&. This should print a short, one-line representation of the object\&. The string will be stored in the output pointer\&.
.PP
\fBParameters\fP
.RS 4
\fIdata\fP Parameter data struct\&. 
.br
\fI*\fP (input) Unused parameter\&. 
.br
\fIoutput\fP Output storage for the string\&. 
.RE
.PP

.PP
Definition at line 114 of file get_printable_param\&.hpp\&.
.SS "std::string mlpack::bindings::go::GetPrintableType (\fButil::ParamData\fP &, const typename boost::disable_if< \fButil::IsStdVector\fP< T >>::type * = \fC0\fP, const typename boost::disable_if< \fBdata::HasSerialize\fP< T >>::type * = \fC0\fP, const typename boost::disable_if< arma::is_arma_type< T >>::type * = \fC0\fP, const typename boost::disable_if< std::is_same< T, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type * = \fC0\fP)\fC [inline]\fP"

.SS "std::string mlpack::bindings::go::GetPrintableType (\fButil::ParamData\fP &, const typename boost::enable_if< arma::is_arma_type< T >>::type * = \fC0\fP, const typename boost::disable_if< std::is_same< T, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type * = \fC0\fP)\fC [inline]\fP"

.SS "std::string mlpack::bindings::go::GetPrintableType (\fButil::ParamData\fP &, const typename boost::enable_if< std::is_same< T, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type * = \fC0\fP)\fC [inline]\fP"

.SS "std::string mlpack::bindings::go::GetPrintableType (\fButil::ParamData\fP & d, const typename boost::disable_if< arma::is_arma_type< T >>::type * = \fC0\fP, const typename boost::enable_if< \fBdata::HasSerialize\fP< T >>::type * = \fC0\fP, const typename boost::disable_if< std::is_same< T, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type * = \fC0\fP)\fC [inline]\fP"

.SS "std::string mlpack::bindings::go::GetPrintableType (\fButil::ParamData\fP & d, const typename boost::enable_if< \fButil::IsStdVector\fP< T >>::type * = \fC0\fP, const typename boost::disable_if< std::is_same< T, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type * = \fC0\fP)\fC [inline]\fP"

.SS "void mlpack::bindings::go::GetPrintableType (\fButil::ParamData\fP & d, const void *, void * output)"

.PP
Definition at line 97 of file get_printable_type\&.hpp\&.
.SS "std::string \fBmlpack::bindings::go::GetPrintableType\fP< bool > (\fButil::ParamData\fP &, const typename boost::disable_if< \fButil::IsStdVector\fP< bool >>::type *, const typename boost::disable_if< \fBdata::HasSerialize\fP< bool >>::type *, const typename boost::disable_if< arma::is_arma_type< bool >>::type *, const typename boost::disable_if< std::is_same< bool, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type *)\fC [inline]\fP"

.SS "std::string \fBmlpack::bindings::go::GetPrintableType\fP< double > (\fButil::ParamData\fP &, const typename boost::disable_if< \fButil::IsStdVector\fP< double >>::type *, const typename boost::disable_if< \fBdata::HasSerialize\fP< double >>::type *, const typename boost::disable_if< arma::is_arma_type< double >>::type *, const typename boost::disable_if< std::is_same< double, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type *)\fC [inline]\fP"

.SS "std::string \fBmlpack::bindings::go::GetPrintableType\fP< int > (\fButil::ParamData\fP &, const typename boost::disable_if< \fButil::IsStdVector\fP< int >>::type *, const typename boost::disable_if< \fBdata::HasSerialize\fP< int >>::type *, const typename boost::disable_if< arma::is_arma_type< int >>::type *, const typename boost::disable_if< std::is_same< int, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type *)\fC [inline]\fP"

.SS "std::string \fBmlpack::bindings::go::GetPrintableType\fP< std::string > (\fButil::ParamData\fP &, const typename boost::disable_if< \fButil::IsStdVector\fP< std::string >>::type *, const typename boost::disable_if< \fBdata::HasSerialize\fP< std::string >>::type *, const typename boost::disable_if< arma::is_arma_type< std::string >>::type *, const typename boost::disable_if< std::is_same< std::string, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type *)\fC [inline]\fP"

.SS "std::string mlpack::bindings::go::GetType (\fButil::ParamData\fP &, const typename boost::disable_if< \fButil::IsStdVector\fP< T >>::type * = \fC0\fP, const typename boost::disable_if< \fBdata::HasSerialize\fP< T >>::type * = \fC0\fP, const typename boost::disable_if< arma::is_arma_type< T >>::type * = \fC0\fP)\fC [inline]\fP"

.PP
Definition at line 25 of file get_type\&.hpp\&.
.SS "std::string mlpack::bindings::go::GetType (\fButil::ParamData\fP &, const typename boost::enable_if< arma::is_arma_type< T >>::type * = \fC0\fP)\fC [inline]\fP"

.PP
Definition at line 93 of file get_type\&.hpp\&.
.SS "std::string mlpack::bindings::go::GetType (\fButil::ParamData\fP & d, const typename boost::disable_if< arma::is_arma_type< T >>::type * = \fC0\fP, const typename boost::enable_if< \fBdata::HasSerialize\fP< T >>::type * = \fC0\fP)\fC [inline]\fP"

.PP
Definition at line 121 of file get_type\&.hpp\&.
.PP
References ParamData::cppType\&.
.SS "std::string mlpack::bindings::go::GetType (\fButil::ParamData\fP & d, const typename boost::enable_if< \fButil::IsStdVector\fP< T >>::type * = \fC0\fP)\fC [inline]\fP"

.PP
Definition at line 85 of file get_type\&.hpp\&.
.SS "void mlpack::bindings::go::GetType (\fButil::ParamData\fP & d, const void *, void * output)"

.PP
Function is used to generate the type names that are used in calls to functions like gonumToArma<type>() or setParam<type>(), and therefore what's returned isn't exactly the Go native type used for that parameter type\&. 
.PP
\fBParameters\fP
.RS 4
\fId\fP Parameter data struct\&. 
.br
\fI*\fP (input) Unused parameter\&. 
.br
\fIoutput\fP Output storage for the string\&. 
.RE
.PP

.PP
Definition at line 140 of file get_type\&.hpp\&.
.SS "std::string \fBmlpack::bindings::go::GetType\fP< bool > (\fButil::ParamData\fP &, const typename boost::disable_if< \fButil::IsStdVector\fP< bool >>::type *, const typename boost::disable_if< \fBdata::HasSerialize\fP< bool >>::type *, const typename boost::disable_if< arma::is_arma_type< bool >>::type *)\fC [inline]\fP"

.PP
Definition at line 75 of file get_type\&.hpp\&.
.SS "std::string \fBmlpack::bindings::go::GetType\fP< double > (\fButil::ParamData\fP &, const typename boost::disable_if< \fButil::IsStdVector\fP< double >>::type *, const typename boost::disable_if< \fBdata::HasSerialize\fP< double >>::type *, const typename boost::disable_if< arma::is_arma_type< double >>::type *)\fC [inline]\fP"

.PP
Definition at line 55 of file get_type\&.hpp\&.
.SS "std::string \fBmlpack::bindings::go::GetType\fP< float > (\fButil::ParamData\fP &, const typename boost::disable_if< \fButil::IsStdVector\fP< float >>::type *, const typename boost::disable_if< \fBdata::HasSerialize\fP< float >>::type *, const typename boost::disable_if< arma::is_arma_type< float >>::type *)\fC [inline]\fP"

.PP
Definition at line 45 of file get_type\&.hpp\&.
.SS "std::string \fBmlpack::bindings::go::GetType\fP< int > (\fButil::ParamData\fP &, const typename boost::disable_if< \fButil::IsStdVector\fP< int >>::type *, const typename boost::disable_if< \fBdata::HasSerialize\fP< int >>::type *, const typename boost::disable_if< arma::is_arma_type< int >>::type *)\fC [inline]\fP"

.PP
Definition at line 35 of file get_type\&.hpp\&.
.SS "std::string \fBmlpack::bindings::go::GetType\fP< std::string > (\fButil::ParamData\fP &, const typename boost::disable_if< \fButil::IsStdVector\fP< std::string >>::type *, const typename boost::disable_if< \fBdata::HasSerialize\fP< std::string >>::type *, const typename boost::disable_if< arma::is_arma_type< std::string >>::type *)\fC [inline]\fP"

.PP
Definition at line 65 of file get_type\&.hpp\&.
.SS "bool mlpack::bindings::go::IgnoreCheck (const std::string & paramName)\fC [inline]\fP"

.PP
Print whether or not we should ignore a check on the given parameter\&. 
.SS "bool mlpack::bindings::go::IgnoreCheck (const std::vector< std::pair< std::string, bool >> & constraints, const std::string & paramName)\fC [inline]\fP"

.PP
Print whether or not we should ignore a check on the given set of constraints\&. 
.SS "bool mlpack::bindings::go::IgnoreCheck (const std::vector< std::string > & constraints)\fC [inline]\fP"

.PP
Print whether or not we should ignore a check on the given set of constraints\&. 
.SS "std::string mlpack::bindings::go::ParamString (const std::string & paramName)\fC [inline]\fP"

.PP
Given the parameter name, determine what it would actually be when passed to the command line\&. 
.SS "std::string mlpack::bindings::go::PrintDataset (const std::string & datasetName)\fC [inline]\fP"

.PP
Given the name of a matrix, print it\&. Here we do not need to modify anything\&. 
.SS "std::string mlpack::bindings::go::PrintDefault (const std::string & paramName)\fC [inline]\fP"

.PP
Given a parameter name, print its corresponding default value\&. 
.SS "void mlpack::bindings::go::PrintDefnInput (\fButil::ParamData\fP & d, const typename boost::disable_if< arma::is_arma_type< T >>::type * = \fC0\fP, const typename boost::disable_if< \fBdata::HasSerialize\fP< T >>::type * = \fC0\fP, const typename boost::disable_if< std::is_same< T, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type * = \fC0\fP)"

.PP
Print input in method definition for a regular parameter type\&. 
.PP
Definition at line 29 of file print_defn_input\&.hpp\&.
.PP
References mlpack::util::CamelCase(), ParamData::name, and ParamData::required\&.
.SS "void mlpack::bindings::go::PrintDefnInput (\fButil::ParamData\fP & d, const typename boost::disable_if< arma::is_arma_type< T >>::type * = \fC0\fP, const typename boost::enable_if< \fBdata::HasSerialize\fP< T >>::type * = \fC0\fP)"

.PP
Print input in method definition for a serializable model\&. 
.PP
Definition at line 80 of file print_defn_input\&.hpp\&.
.PP
References mlpack::util::CamelCase(), ParamData::cppType, ParamData::name, ParamData::required, and StripType()\&.
.SS "void mlpack::bindings::go::PrintDefnInput (\fButil::ParamData\fP & d, const typename boost::enable_if< arma::is_arma_type< T >>::type * = \fC0\fP)"

.PP
Print input in method definition for a matrix type\&. 
.PP
Definition at line 47 of file print_defn_input\&.hpp\&.
.PP
References mlpack::util::CamelCase(), ParamData::name, and ParamData::required\&.
.SS "void mlpack::bindings::go::PrintDefnInput (\fButil::ParamData\fP & d, const typename boost::enable_if< std::is_same< T, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type * = \fC0\fP)"

.PP
Print input in method definition for a matrix with info type\&. 
.PP
Definition at line 63 of file print_defn_input\&.hpp\&.
.PP
References mlpack::util::CamelCase(), ParamData::name, and ParamData::required\&.
.SS "void mlpack::bindings::go::PrintDefnInput (\fButil::ParamData\fP & d, const void *, void *)"

.PP
Given parameter information and the current number of spaces for indentation, print the code to process the output to cout\&. This code assumes that data\&.input is false, and should not be called when data\&.input is true\&. If this is the only output, the results will be different\&.
.PP
The input pointer should be a pointer to a std::tuple<size_t, bool> where the first element is the indentation and the second element is a boolean representing whether or not this is the only output parameter\&.
.PP
\fBParameters\fP
.RS 4
\fId\fP Parameter data struct\&. 
.br
\fI*\fP (input) Pointer to size_t holding the indentation\&. 
.br
\fI*\fP (output) Unused parameter\&. 
.RE
.PP

.PP
Definition at line 112 of file print_defn_input\&.hpp\&.
.SS "void mlpack::bindings::go::PrintDefnOutput (\fButil::ParamData\fP & d, const typename boost::disable_if< arma::is_arma_type< T >>::type * = \fC0\fP, const typename boost::disable_if< \fBdata::HasSerialize\fP< T >>::type * = \fC0\fP, const typename boost::disable_if< std::is_same< T, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type * = \fC0\fP)"

.PP
Print output for a regular parameter type\&. 
.PP
Definition at line 28 of file print_defn_output\&.hpp\&.
.SS "void mlpack::bindings::go::PrintDefnOutput (\fButil::ParamData\fP & d, const typename boost::disable_if< arma::is_arma_type< T >>::type * = \fC0\fP, const typename boost::enable_if< \fBdata::HasSerialize\fP< T >>::type * = \fC0\fP)"

.PP
Print output for a serializable model\&. 
.PP
Definition at line 67 of file print_defn_output\&.hpp\&.
.PP
References ParamData::cppType, and StripType()\&.
.SS "void mlpack::bindings::go::PrintDefnOutput (\fButil::ParamData\fP & d, const typename boost::enable_if< arma::is_arma_type< T >>::type * = \fC0\fP)"

.PP
Print output for a matrix type\&. 
.PP
Definition at line 42 of file print_defn_output\&.hpp\&.
.SS "void mlpack::bindings::go::PrintDefnOutput (\fButil::ParamData\fP & d, const typename boost::enable_if< std::is_same< T, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type * = \fC0\fP)"

.PP
Print output for a matrix with info type\&. 
.PP
Definition at line 54 of file print_defn_output\&.hpp\&.
.SS "void mlpack::bindings::go::PrintDefnOutput (\fButil::ParamData\fP & d, const void *, void *)"

.PP
Given parameter information and the current number of spaces for indentation, print the code to process the output to cout\&. This code assumes that data\&.input is false, and should not be called when data\&.input is true\&. If this is the only output, the results will be different\&.
.PP
The input pointer should be a pointer to a std::tuple<size_t, bool> where the first element is the indentation and the second element is a boolean representing whether or not this is the only output parameter\&.
.PP
\fBParameters\fP
.RS 4
\fId\fP Parameter data struct\&. 
.br
\fI*\fP (input) Pointer to size_t holding the indentation\&. 
.br
\fI*\fP (output) Unused parameter\&. 
.RE
.PP

.PP
Definition at line 93 of file print_defn_output\&.hpp\&.
.SS "void mlpack::bindings::go::PrintDoc (\fButil::ParamData\fP & d, const void * input, void * isLower)"

.PP
Print the docstring documentation for a given parameter\&. You are responsible for setting up the line---this does not handle indentation or anything\&. This is meant to produce a line of documentation describing a single parameter\&.
.PP
The indent parameter (void* input, which should be a pointer to a size_t) should be passed to know how much to indent for a new line\&.
.PP
\fBParameters\fP
.RS 4
\fId\fP Parameter data struct\&. 
.br
\fIinput\fP Pointer to size_t containing indent\&. 
.br
\fIisLower\fP is pointer to bool if isLower is true then parameter is Output or Required Input\&. 
.RE
.PP

.PP
Definition at line 39 of file print_doc\&.hpp\&.
.PP
References mlpack::util::CamelCase(), ParamData::cppType, ParamData::desc, mlpack::util::HyphenateString(), if(), ParamData::name, ParamData::required, and ParamData::value\&.
.SS "void mlpack::bindings::go::PrintGo (const \fButil::BindingDetails\fP & doc, const std::string & functionName)"

.PP
Given a list of parameter definition and program documentation, print a generated \&.go file to stdout\&. 
.PP
\fBParameters\fP
.RS 4
\fIdoc\fP Documentation for the program\&. 
.br
\fIfunctionName\fP Name of the function (i\&.e\&. 'pca')\&. 
.RE
.PP

.SS "std::string mlpack::bindings::go::PrintImport ()\fC [inline]\fP"

.PP
Print any import information for the Go binding\&. 
.SS "std::string mlpack::bindings::go::PrintInputOptionInfo ()\fC [inline]\fP"

.PP
Print any special information about input options\&. 
.SS "std::string mlpack::bindings::go::PrintInputOptions ()\fC [inline]\fP"

.SS "std::string mlpack::bindings::go::PrintInputOptions (const std::string & paramName, const T & value, Args\&.\&.\&. args)"

.PP
Print an input option\&. This will throw an exception if the parameter does not exist in \fBIO\fP\&. 
.SS "void mlpack::bindings::go::PrintInputProcessing (\fButil::ParamData\fP & d, const size_t indent, const typename boost::disable_if< arma::is_arma_type< T >>::type * = \fC0\fP, const typename boost::disable_if< \fBdata::HasSerialize\fP< T >>::type * = \fC0\fP, const typename boost::disable_if< std::is_same< T, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type * = \fC0\fP)"

.PP
Print input processing for a standard option type\&. This gives us code like:
.PP
// Detect if the parameter was passed; set if so\&. if param\&.Name != nil { setParam<d\&.cppType>('paramName', param\&.Name) setPassed('paramName') }
.PP
Definition at line 29 of file print_input_processing\&.hpp\&.
.PP
References mlpack::util::CamelCase(), ParamData::cppType, ParamData::name, ParamData::required, and ParamData::value\&.
.SS "void mlpack::bindings::go::PrintInputProcessing (\fButil::ParamData\fP & d, const size_t indent, const typename boost::disable_if< arma::is_arma_type< T >>::type * = \fC0\fP, const typename boost::enable_if< \fBdata::HasSerialize\fP< T >>::type * = \fC0\fP)"

.PP
Print input processing for a serializable type\&. This gives us code like:
.PP
// Detect if the parameter was passed; set if so\&. if param\&.Name != nil { set<ModelType>('paramName', param\&.Name) setPassed('paramName') }
.PP
Definition at line 250 of file print_input_processing\&.hpp\&.
.PP
References mlpack::util::CamelCase(), ParamData::cppType, ParamData::name, ParamData::required, and StripType()\&.
.SS "void mlpack::bindings::go::PrintInputProcessing (\fButil::ParamData\fP & d, const size_t indent, const typename boost::enable_if< arma::is_arma_type< T >>::type * = \fC0\fP)"

.PP
Print input processing for a matrix type\&. This gives us code like:
.PP
// Detect if the parameter was passed; set if so\&. if param\&.Name != nil { gonumToArma<type>('paramName', param\&.Name) setPassed('paramName') }
.PP
Definition at line 129 of file print_input_processing\&.hpp\&.
.PP
References mlpack::util::CamelCase(), ParamData::name, and ParamData::required\&.
.SS "void mlpack::bindings::go::PrintInputProcessing (\fButil::ParamData\fP & d, const size_t indent, const typename boost::enable_if< std::is_same< T, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type * = \fC0\fP)"

.PP
Print input processing for a matrix with info type\&. This gives us code like:
.PP
// Detect if the parameter was passed; set if so\&. if param\&.Name != nil { gonumToArmaMatWithInfo<type>('paramName', param\&.Name) setPassed('paramName') }
.PP
Definition at line 189 of file print_input_processing\&.hpp\&.
.PP
References mlpack::util::CamelCase(), ParamData::name, and ParamData::required\&.
.SS "void mlpack::bindings::go::PrintInputProcessing (\fButil::ParamData\fP & d, const void * input, void *)"

.PP
Given parameter information and the current number of spaces for indentation, print the code to process the input to cout\&. This code assumes that data\&.input is true, and should not be called when data\&.input is false\&.
.PP
The number of spaces to indent should be passed through the input pointer\&.
.PP
\fBParameters\fP
.RS 4
\fId\fP Parameter data struct\&. 
.br
\fIinput\fP Pointer to size_t holding the indentation\&. 
.br
\fI*\fP (output) Unused parameter\&. 
.RE
.PP

.PP
Definition at line 320 of file print_input_processing\&.hpp\&.
.SS "void mlpack::bindings::go::PrintMethodConfig (\fButil::ParamData\fP & d, const size_t indent, const typename boost::disable_if< arma::is_arma_type< T >>::type * = \fC0\fP, const typename boost::disable_if< \fBdata::HasSerialize\fP< T >>::type * = \fC0\fP, const typename boost::disable_if< std::is_same< T, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type * = \fC0\fP)"

.PP
Print param in configuration struct for a standard option type\&. 
.PP
Definition at line 29 of file print_method_config\&.hpp\&.
.PP
References mlpack::util::CamelCase(), ParamData::name, and ParamData::required\&.
.SS "void mlpack::bindings::go::PrintMethodConfig (\fButil::ParamData\fP & d, const size_t indent, const typename boost::disable_if< arma::is_arma_type< T >>::type * = \fC0\fP, const typename boost::enable_if< \fBdata::HasSerialize\fP< T >>::type * = \fC0\fP)"

.PP
Print param in method configuration struct for a serializable type\&. 
.PP
Definition at line 129 of file print_method_config\&.hpp\&.
.PP
References mlpack::util::CamelCase(), ParamData::name, and ParamData::required\&.
.SS "void mlpack::bindings::go::PrintMethodConfig (\fButil::ParamData\fP & d, const size_t indent, const typename boost::enable_if< arma::is_arma_type< T >>::type * = \fC0\fP)"

.PP
Print param in configuration struct for a matrix type\&. 
.PP
Definition at line 64 of file print_method_config\&.hpp\&.
.PP
References mlpack::util::CamelCase(), ParamData::name, and ParamData::required\&.
.SS "void mlpack::bindings::go::PrintMethodConfig (\fButil::ParamData\fP & d, const size_t indent, const typename boost::enable_if< std::is_same< T, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type * = \fC0\fP)"

.PP
Print param in configuration struct for a matrix with info type\&. 
.PP
Definition at line 96 of file print_method_config\&.hpp\&.
.PP
References mlpack::util::CamelCase(), ParamData::name, and ParamData::required\&.
.SS "void mlpack::bindings::go::PrintMethodConfig (\fButil::ParamData\fP & d, const void * input, void *)"

.PP
Given parameter information and the current number of spaces for indentation, print the code to process the input to cout\&. This code assumes that data\&.input is true, and should not be called when data\&.input is false\&.
.PP
The number of spaces to indent should be passed through the input pointer\&.
.PP
\fBParameters\fP
.RS 4
\fId\fP Parameter data struct\&. 
.br
\fIinput\fP Pointer to size_t holding the indentation\&. 
.br
\fI*\fP (output) Unused parameter\&. 
.RE
.PP

.PP
Definition at line 170 of file print_method_config\&.hpp\&.
.SS "void mlpack::bindings::go::PrintMethodInit (\fButil::ParamData\fP & d, const size_t indent, const typename boost::disable_if< arma::is_arma_type< T >>::type * = \fC0\fP, const typename boost::disable_if< \fBdata::HasSerialize\fP< T >>::type * = \fC0\fP, const typename boost::disable_if< std::is_same< T, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type * = \fC0\fP)"

.PP
Print parameter with it's default value for a standard option type\&. 
.PP
Definition at line 29 of file print_method_init\&.hpp\&.
.PP
References mlpack::util::CamelCase(), ParamData::cppType, ParamData::name, ParamData::required, and ParamData::value\&.
.SS "void mlpack::bindings::go::PrintMethodInit (\fButil::ParamData\fP & d, const size_t indent, const typename boost::disable_if< arma::is_arma_type< T >>::type * = \fC0\fP, const typename boost::enable_if< \fBdata::HasSerialize\fP< T >>::type * = \fC0\fP)"

.PP
Print parameter with its default value for a serializable type\&. 
.PP
Definition at line 151 of file print_method_init\&.hpp\&.
.PP
References mlpack::util::CamelCase(), ParamData::name, and ParamData::required\&.
.SS "void mlpack::bindings::go::PrintMethodInit (\fButil::ParamData\fP & d, const size_t indent, const typename boost::enable_if< arma::is_arma_type< T >>::type * = \fC0\fP)"

.PP
Print parameter with its default value for a matrix type\&. 
.PP
Definition at line 86 of file print_method_init\&.hpp\&.
.PP
References mlpack::util::CamelCase(), ParamData::name, and ParamData::required\&.
.SS "void mlpack::bindings::go::PrintMethodInit (\fButil::ParamData\fP & d, const size_t indent, const typename boost::enable_if< std::is_same< T, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type * = \fC0\fP)"

.PP
Print parameter with its default value for a matrix with info type\&. 
.PP
Definition at line 118 of file print_method_init\&.hpp\&.
.PP
References mlpack::util::CamelCase(), ParamData::name, and ParamData::required\&.
.SS "void mlpack::bindings::go::PrintMethodInit (\fButil::ParamData\fP & d, const void * input, void *)"

.PP
Given parameter information and the current number of spaces for indentation, print the code to process the input to cout\&. This code assumes that data\&.input is true, and should not be called when data\&.input is false\&.
.PP
The number of spaces to indent should be passed through the input pointer\&.
.PP
\fBParameters\fP
.RS 4
\fId\fP Parameter data struct\&. 
.br
\fIinput\fP Pointer to size_t holding the indentation\&. 
.br
\fI*\fP (output) Unused parameter\&. 
.RE
.PP

.PP
Definition at line 192 of file print_method_init\&.hpp\&.
.SS "std::string mlpack::bindings::go::PrintModel (const std::string & modelName)\fC [inline]\fP"

.PP
Given the name of a model, print it\&. Here we do not need to modify anything\&. 
.SS "std::string mlpack::bindings::go::PrintOptionalInputs ()\fC [inline]\fP"

.SS "std::string mlpack::bindings::go::PrintOptionalInputs (const std::string & paramName, const T & value, Args\&.\&.\&. args)"

.PP
Print an input option\&. This will throw an exception if the parameter does not exist in \fBIO\fP\&. 
.SS "std::string mlpack::bindings::go::PrintOutputOptionInfo ()\fC [inline]\fP"

.PP
Print any special information about output options\&. 
.SS "std::string mlpack::bindings::go::PrintOutputOptions ()\fC [inline]\fP"

.SS "std::string mlpack::bindings::go::PrintOutputOptions (Args\&.\&.\&. args)"

.SS "void mlpack::bindings::go::PrintOutputProcessing (\fButil::ParamData\fP & d, const size_t indent, const typename boost::disable_if< arma::is_arma_type< T >>::type * = \fC0\fP, const typename boost::disable_if< \fBdata::HasSerialize\fP< T >>::type * = \fC0\fP, const typename boost::disable_if< std::is_same< T, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type * = \fC0\fP)"

.PP
Print output processing for a regular parameter type\&. This gives us code like:
.PP
<paramName> := GetParam<Type>('paramName')
.PP
Definition at line 29 of file print_output_processing\&.hpp\&.
.PP
References mlpack::util::CamelCase(), and ParamData::name\&.
.SS "void mlpack::bindings::go::PrintOutputProcessing (\fButil::ParamData\fP & d, const size_t indent, const typename boost::disable_if< arma::is_arma_type< T >>::type * = \fC0\fP, const typename boost::enable_if< \fBdata::HasSerialize\fP< T >>::type * = \fC0\fP)"

.PP
Print output processing for a serializable model\&. This gives us code like:
.PP
var modelOut <Type> modelOut\&.get<Type>('paramName')
.PP
Definition at line 109 of file print_output_processing\&.hpp\&.
.PP
References mlpack::util::CamelCase(), ParamData::cppType, ParamData::name, and StripType()\&.
.SS "void mlpack::bindings::go::PrintOutputProcessing (\fButil::ParamData\fP & d, const size_t indent, const typename boost::enable_if< arma::is_arma_type< T >>::type * = \fC0\fP, const typename std::enable_if<!std::is_same< T, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>::value >::type * = \fC0\fP)"

.PP
Print output processing for a matrix type\&. This gives us code like:
.PP
var <paramName>Ptr mlpackArma <paramName> := <paramName>\fIptr\&.ArmaToGonum\fP<Type>('paramName')
.PP
Definition at line 56 of file print_output_processing\&.hpp\&.
.PP
References mlpack::util::CamelCase(), and ParamData::name\&.
.SS "void mlpack::bindings::go::PrintOutputProcessing (\fButil::ParamData\fP & d, const size_t indent, const typename boost::enable_if< std::is_same< T, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type * = \fC0\fP)"

.PP
Print output processing for a matrix with info type\&. This gives us code like:
.PP
var <paramName>_ptr mlpackArma <paramName> := <paramName>Ptr\&.ArmaToGonumWithInfo<Type>('paramName')
.PP
Definition at line 83 of file print_output_processing\&.hpp\&.
.PP
References mlpack::util::CamelCase(), and ParamData::name\&.
.SS "void mlpack::bindings::go::PrintOutputProcessing (\fButil::ParamData\fP & d, const void *, void *)"

.PP
\fBParameters\fP
.RS 4
\fId\fP Parameter data struct\&. 
.br
\fI*\fP (input) Unused parameter\&. 
.br
\fI*\fP (output) Unused parameter\&. 
.RE
.PP

.PP
Definition at line 141 of file print_output_processing\&.hpp\&.
.SS "std::string mlpack::bindings::go::PrintTypeDoc (\fButil::ParamData\fP & data, const typename boost::disable_if< arma::is_arma_type< T >>::type * = \fC0\fP, const typename boost::disable_if< \fButil::IsStdVector\fP< T >>::type * = \fC0\fP, const typename boost::disable_if< \fBdata::HasSerialize\fP< T >>::type * = \fC0\fP, const typename boost::disable_if< std::is_same< T, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>>::type * = \fC0\fP)"

.PP
Return a string representing the command-line type of an option\&. 
.SS "std::string mlpack::bindings::go::PrintTypeDoc (\fButil::ParamData\fP & data, const typename boost::disable_if< arma::is_arma_type< T >>::type * = \fC0\fP, const typename boost::enable_if< \fBdata::HasSerialize\fP< T >>::type * = \fC0\fP)"

.PP
Return a string representing the command-line type of a model\&. 
.SS "std::string mlpack::bindings::go::PrintTypeDoc (\fButil::ParamData\fP & data, const typename std::enable_if< arma::is_arma_type< T >::value >::type * = \fC0\fP)"

.PP
Return a string representing the command-line type of a matrix option\&. 
.SS "std::string mlpack::bindings::go::PrintTypeDoc (\fButil::ParamData\fP & data, const typename std::enable_if< std::is_same< T, std::tuple< \fBdata::DatasetInfo\fP, arma::mat >>::value >::type * = \fC0\fP)"

.PP
Return a string representing the command-line type of a matrix tuple option\&. 
.SS "std::string mlpack::bindings::go::PrintTypeDoc (\fButil::ParamData\fP & data, const typename std::enable_if< \fButil::IsStdVector\fP< T >::value >::type * = \fC0\fP)"

.PP
Return a string representing the command-line type of a vector\&. 
.SS "void mlpack::bindings::go::PrintTypeDoc (\fButil::ParamData\fP & data, const void *, void * output)"

.PP
Print the command-line type of an option into a string\&. 
.PP
Definition at line 72 of file print_type_doc\&.hpp\&.
.SS "std::string mlpack::bindings::go::PrintValue (const bool & value, bool quotes)\fC [inline]\fP"

.SS "std::string mlpack::bindings::go::PrintValue (const T & value, bool quotes)\fC [inline]\fP"

.PP
Given a parameter type, print the corresponding value\&. 
.SS "std::string mlpack::bindings::go::ProgramCall (const std::string & programName, Args\&.\&.\&. args)"

.PP
Given a name of a binding and a variable number of arguments (and their contents), print the corresponding function call\&. 
.SS "void mlpack::bindings::go::StripType (const std::string & inputType, std::string & goStrippedType, std::string & strippedType, std::string & printedType, std::string & defaultsType)\fC [inline]\fP"

.PP
Given an input type like, e\&.g\&., 'LogisticRegression<>', return four types that can be used in Go code\&. goStrippedType will be a type with lower first letter of parameter name so it is of unexported type in GoDoc (e\&.g\&. 'logisticRegression'), strippedType will be a type with no template parameters (e\&.g\&. 'LogisticRegression'), printedType will be a printable type with the template parameters (e\&.g\&. 'LogisticRegression<>'), and defaultsType will be a printable type with a default template parameter (e\&.g\&. 'LogisticRegression\\<T\\>') that can be used for class definitions\&. 
.PP
Definition at line 30 of file strip_type\&.hpp\&.
.PP
Referenced by GetGoType(), PrintDefnInput(), PrintDefnOutput(), PrintInputProcessing(), and PrintOutputProcessing()\&.
.SH "Variable Documentation"
.PP 
.SS "std::string programName\fC [extern]\fP"

.PP
Referenced by GoOption< T >::GoOption(), and ProgramNameWrapper::ProgramNameWrapper()\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for mlpack from the source code\&.
